#include "CProductThread.h"



CProductThread::CProductThread()
{
}


CProductThread::~CProductThread()
{
}

int CProductThread::SetProductThread(CProductThread *productThread)
{
	m_cProductThread = productThread;
	m_cProductThread->SetPlatformThread(productThread);
	return 0;
}

ULONG RTFCNDCL CProductThread::IOScanThread(void * nContext)
{
	int nError = 0;

	m_cIO->Connect();

	nError = m_cIO->IOScanThread(smProductIO->ucInput, smProductIO->ucOutput);
	IOScanThreadSetOutputBeforeExitSoftwareAndDisconnect();
	m_cIO->Disconnect();
	//Disconnect
	smProductEvent->RTHD_RMAIN_IO_SCAN_END.Set = true;
	return nError;
}
#pragma region Motion Controller Thread
ULONG CProductThread::MC1Thread(void * nContext)
{
	CMotionLibrary *cMC1 = (CMotionLibrary*)nContext;
	int nError = 0;
	bool SlowMode = false;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("MC1 thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->InitializeMotionController7Done.Set == true
			&& smProductEvent->InitializeMotionController6Done.Set == true
			&& smProductEvent->InitializeMotionController5Done.Set == true)
			break;
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		nError = cMC1->Connect(m_cProductMotorControl->m_motorConfiguration[0].Axis);
		if (nError == 0)
		{
			m_cLogger->WriteLog("Connect to motion controller 1.\n");
			break;
		}
		else if (nError != 0)
		{
			m_cLogger->WriteLog("Error during connect to motion controller 1.\n");
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartInitializeMotionController1.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInitializeMotionController1.Set = false;
			nError = m_cProductMotorControl->MotionController1Initialize(cMC1);
			if (nError == 0)
			{
				smProductEvent->InitializeMotionController1Done.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error during initialize motion controller 1 %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1YAxisMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1YAxisMotorStop.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorStop(cMC1);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1YAxisMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error stop Pick And Place 1 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
		}
		if (smProductEvent->StartPickAndPlace1YAxisMotorOff.Set == true)
		{
			char a = *smProductProduction->InputLotID;
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1YAxisMotorOff.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorOff(cMC1);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1YAxisMotorOffDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error off Pick And Place 1 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
		}
		if (smProductEvent->StartInputTrayTableXAxisMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableXAxisMotorStop.Set = false;
			nError = m_cProductMotorControl->InputTrayTableXAxisMotorStop(cMC1);
			if (nError == 0)
			{
				smProductEvent->InputTrayTableXAxisMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error stop Input Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
		}
		if (smProductEvent->StartInputTrayTableYAxisMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableYAxisMotorStop.Set = false;
			nError = m_cProductMotorControl->InputTrayTableYAxisMotorStop(cMC1);
			if (nError == 0)
			{
				smProductEvent->InputTrayTableYAxisMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error stop Input Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
		}
		if (smProductEvent->StartInputTrayTableZAxisMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableZAxisMotorStop.Set = false;
			nError = m_cProductMotorControl->InputTrayTableZAxisMotorStop(cMC1);
			if (nError == 0)
			{
				smProductEvent->InputTrayTableZAxisMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error stop Input Tray Table Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->JobSlow.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			if (SlowMode == false)
			{
				//nError = cMC4Galil->SendCommand("vSLOW=1");
				nError = cMC1->SetControllerVariable(m_cProductMotorControl->m_motorConfiguration[0].ControllerDetails, "vSLOW", 1);
				nError += cMC1->SendCommand(m_cProductMotorControl->m_motorConfiguration[0].ControllerDetails, "XQ#SLOW,0");
				Sleep(5);
				if (nError == 0)
				{
					SlowMode = true;
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error during set all MC1 slow on %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					//return nError;
				}
			}
		}
		else if (smProductEvent->JobSlow.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			if (SlowMode == true)
			{
				nError = cMC1->SetControllerVariable(m_cProductMotorControl->m_motorConfiguration[0].ControllerDetails, "vSLOW", 0);
				nError += cMC1->SendCommand(m_cProductMotorControl->m_motorConfiguration[0].ControllerDetails, "XQ#SLOW,0");
				Sleep(5);
				if (nError == 0)
				{
					SlowMode = false;
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error during set all MC1 slow off %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					//return nError;
				}
			}
			else if (SlowMode == true)
			{
				nError = cMC1->SetControllerVariable(m_cProductMotorControl->m_motorConfiguration[0].ControllerDetails, "vSLOW", 0);
				nError += cMC1->SendCommand(m_cProductMotorControl->m_motorConfiguration[0].ControllerDetails, "XQ#SLOW,0");
				if (nError == 0)
				{
					SlowMode = false;
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error during set MC1 slow off %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					//return nError;
				}
			}
		}
#pragma region Read Encoder during Teach Mode
		if (smProductEvent->GTCH_RTCH_TEACH_MODE.Set == true)
		{
			//Read encoder value
			int nPosition;
			int nFeedback;
			//Fuji-Galil
			//if(smProductGeneral->nTeachPointMotorType == 1)
			{
				if (smProductGeneral->nTeachPointCardNo == 0)
				{
#pragma region Pick And Place 1 Y Axis Motor
					if (smProductGeneral->nTeachPointAxis == 108)
					{
						if (smProductCustomize->EnablePickAndPlace1YAxisMotor == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->PickAndPlace1YAxisMotorStopDone.Set = false;
								smProductEvent->StartPickAndPlace1YAxisMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}

							char cReceive[80] = "";
							smProductGeneral->nMotorEncoderPosition = (int)(((double)cMC1->GetEncoderPosition(m_cProductMotorControl->m_motorConfiguration[0].Axis)));
							nError = cMC1->SendReceiveCommand(m_cProductMotorControl->m_motorConfiguration[0].ControllerDetails, "MG _TSA", cReceive);
							if (nError == 0)
							{
								int foundAcknowledge = 99;
								for (int i = 0; i < strlen(cReceive); i++)
								{
									if (i > foundAcknowledge)
									{
										cReceive[i] = '\0';
									}
									if (cReceive[i] == ':')
									{
										foundAcknowledge = i;
									}
								}
								nFeedback = (int)atof(cReceive);
								memset(cReceive, 0, sizeof(cReceive));
								if ((nFeedback & 0x02) == 0x02)
									smProductGeneral->nMotorHomeSensor = 1;
								else
									smProductGeneral->nMotorHomeSensor = 0;
								if ((nFeedback & 0x04) == 0x04)
									smProductGeneral->nMotorReverseLimit = 0;
								else
									smProductGeneral->nMotorReverseLimit = 1;
								if ((nFeedback & 0x08) == 0x08)
									smProductGeneral->nMotorForwardLimit = 0;
								else
									smProductGeneral->nMotorForwardLimit = 1;
								if ((nFeedback & 0x20) == 0x20)
									smProductGeneral->nMotorOnStatus = 0;
								else
									smProductGeneral->nMotorOnStatus = 1;
								if ((nFeedback & 0x80) == 0x80)
									smProductGeneral->nMotorMovingStatus = 1;
								else
									smProductGeneral->nMotorMovingStatus = 0;
								if (m_cProductIOControl->IsPickAndPlace1YAxisMotorReady() == true)
									smProductGeneral->nMotorAlarmOn = 0;
								else
									smProductGeneral->nMotorAlarmOn = 1;
							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder Pick And Place 1 Y Axis Motor status.\n");
							}
						}
						else
						{
							m_cLogger->WriteLog("Pick And Place 1 Y Axis Motor is not enable.\n");
						}
					}
#pragma endregion
#pragma region Input Tray Table X Axis Motor
					if (smProductGeneral->nTeachPointAxis == 101)
					{
						if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->InputTrayTableXAxisMotorStopDone.Set = false;
								smProductEvent->StartInputTrayTableXAxisMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}
							char cReceive[80] = "";
							smProductGeneral->nMotorEncoderPosition = (signed int)(((double)cMC1->GetEncoderPosition(m_cProductMotorControl->m_motorConfiguration[1].Axis)));///m_motorConfiguration[1].UnitInOnePulse);
							nError = cMC1->SendReceiveCommand(m_cProductMotorControl->m_motorConfiguration[1].ControllerDetails, "MG _TSB", cReceive);
							if (nError == 0)
							{
								int foundAcknowledge = 99;
								for (int i = 0; i < strlen(cReceive); i++)
								{
									if (i > foundAcknowledge)
									{
										cReceive[i] = '\0';
									}
									if (cReceive[i] == ':')
									{
										foundAcknowledge = i;
									}
								}
								nFeedback = (int)atof(cReceive);
								memset(cReceive, 0, sizeof(cReceive));
								if ((nFeedback & 0x02) == 0x02)
									smProductGeneral->nMotorHomeSensor = 1;
								else
									smProductGeneral->nMotorHomeSensor = 0;
								if ((nFeedback & 0x04) == 0x04)
									smProductGeneral->nMotorReverseLimit = 0;
								else
									smProductGeneral->nMotorReverseLimit = 1;
								if ((nFeedback & 0x08) == 0x08)
									smProductGeneral->nMotorForwardLimit = 0;
								else
									smProductGeneral->nMotorForwardLimit = 1;
								if ((nFeedback & 0x20) == 0x20)
									smProductGeneral->nMotorOnStatus = 0;
								else
									smProductGeneral->nMotorOnStatus = 1;
								if ((nFeedback & 0x80) == 0x80)
									smProductGeneral->nMotorMovingStatus = 1;
								else
									smProductGeneral->nMotorMovingStatus = 0;
								if (m_cProductIOControl->IsInputTrayTableXAxisMotorReady() == true)
									smProductGeneral->nMotorAlarmOn = 0;
								else
									smProductGeneral->nMotorAlarmOn = 1;
							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder Input Tray Table X Axis Motor status.\n");
							}
						}
						else
						{
							m_cLogger->WriteLog("Input Tray Table X Axis Motor is not enable.\n");
						}
					}
#pragma endregion
#pragma region Input Tray Table Y Axis
					if (smProductGeneral->nTeachPointAxis == 102)
					{
						if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->InputTrayTableYAxisMotorStopDone.Set = false;
								smProductEvent->StartInputTrayTableYAxisMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}
							char cReceive[80] = "";
							smProductGeneral->nMotorEncoderPosition = (signed int)((double)cMC1->GetEncoderPosition(m_cProductMotorControl->m_motorConfiguration[2].Axis));
							nError = cMC1->SendReceiveCommand(m_cProductMotorControl->m_motorConfiguration[2].ControllerDetails, "MG _TSC", cReceive);
							if (nError == 0)
							{
								int foundAcknowledge = 99;
								for (int i = 0; i < strlen(cReceive); i++)
								{
									if (i > foundAcknowledge)
									{
										cReceive[i] = '\0';
									}
									if (cReceive[i] == ':')
									{
										foundAcknowledge = i;
									}
								}
								nFeedback = (int)atof(cReceive);
								memset(cReceive, 0, sizeof(cReceive));
								if ((nFeedback & 0x02) == 0x02)
									smProductGeneral->nMotorHomeSensor = 1;
								else
									smProductGeneral->nMotorHomeSensor = 0;
								if ((nFeedback & 0x04) == 0x04)
									smProductGeneral->nMotorReverseLimit = 0;
								else
									smProductGeneral->nMotorReverseLimit = 1;
								if ((nFeedback & 0x08) == 0x08)
									smProductGeneral->nMotorForwardLimit = 0;
								else
									smProductGeneral->nMotorForwardLimit = 1;
								if ((nFeedback & 0x20) == 0x20)
									smProductGeneral->nMotorOnStatus = 0;
								else
									smProductGeneral->nMotorOnStatus = 1;
								if ((nFeedback & 0x80) == 0x80)
									smProductGeneral->nMotorMovingStatus = 1;
								else
									smProductGeneral->nMotorMovingStatus = 0;
								if (m_cProductIOControl->IsInputTrayTableYAxisMotorReady() == true)
									smProductGeneral->nMotorAlarmOn = 0;
								else
									smProductGeneral->nMotorAlarmOn = 1;
							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder Input Tray Table Y Axis Motor status.\n");
							}
						}
						else
						{
							m_cLogger->WriteLog("Input Tray Table Y Axis Motor is not enable.\n");
						}
					}
#pragma endregion
#pragma region Input Tray Table Z Axis
					if (smProductGeneral->nTeachPointAxis == 103)
					{
						if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
								smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}
							char cReceive[80] = "";
							smProductGeneral->nMotorEncoderPosition = (signed int)cMC1->GetEncoderPosition(m_cProductMotorControl->m_motorConfiguration[3].Axis);
							nError = cMC1->SendReceiveCommand(m_cProductMotorControl->m_motorConfiguration[3].ControllerDetails, "MG _TSD", cReceive);
							if (nError == 0)
							{
								int foundAcknowledge = 99;
								for (int i = 0; i < strlen(cReceive); i++)
								{
									if (i > foundAcknowledge)
									{
										cReceive[i] = '\0';
									}
									if (cReceive[i] == ':')
									{
										foundAcknowledge = i;
									}
								}
								nFeedback = (int)atof(cReceive);
								memset(cReceive, 0, sizeof(cReceive));
								if ((nFeedback & 0x02) == 0x02)
									smProductGeneral->nMotorHomeSensor = 1;
								else
									smProductGeneral->nMotorHomeSensor = 0;
								if ((nFeedback & 0x04) == 0x04)
									smProductGeneral->nMotorReverseLimit = 0;
								else
									smProductGeneral->nMotorReverseLimit = 1;
								if ((nFeedback & 0x08) == 0x08)
									smProductGeneral->nMotorForwardLimit = 0;
								else
									smProductGeneral->nMotorForwardLimit = 1;
								if ((nFeedback & 0x20) == 0x20)
									smProductGeneral->nMotorOnStatus = 0;
								else
									smProductGeneral->nMotorOnStatus = 1;
								if ((nFeedback & 0x80) == 0x80)
									smProductGeneral->nMotorMovingStatus = 1;
								else
									smProductGeneral->nMotorMovingStatus = 0;
								if (m_cProductIOControl->IsInputTrayTableZAxisMotorReady() == true)
									smProductGeneral->nMotorAlarmOn = 0;
								else
									smProductGeneral->nMotorAlarmOn = 1;
							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder Input Tray Table Z Axis Motor status.\n");
							}
						}
						else
						{
							m_cLogger->WriteLog("Input Tray Table Z Axis Motor is not enable.\n");
						}
					}
#pragma endregion
				}
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
#pragma endregion
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	cMC1->SendCommand(m_cProductMotorControl->m_motorConfiguration[0].ControllerDetails, "HX0;HX1;HX2;HX3;ST;MO");
	cMC1->Disconnect(m_cProductMotorControl->m_motorConfiguration[0].Axis);
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("MC1 thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_MC1_END.Set = true;

	return 0;
}
ULONG CProductThread::MC2Thread(void * nContext)
{
	CMotionLibrary *cMC2 = (CMotionLibrary*)nContext;
	int nError = 0;
	bool SlowMode = false;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("MC2 thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->InitializeMotionController7Done.Set == true
			&& smProductEvent->InitializeMotionController6Done.Set == true
			&& smProductEvent->InitializeMotionController5Done.Set == true)
			break;
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		nError = cMC2->Connect(m_cProductMotorControl->m_motorConfiguration[4].Axis);
		if (nError == 0)
		{
			m_cLogger->WriteLog("Connect to motion controller 2.\n");
			break;
		}
		else if (nError != 0)
		{
			m_cLogger->WriteLog("Error during connect to motion controller 2.\n");
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartInitializeMotionController2.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInitializeMotionController2.Set = false;
			nError = m_cProductMotorControl->MotionController2Initialize(cMC2);
			if (nError == 0)
			{
				smProductEvent->InitializeMotionController2Done.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error during initialize motion controller 2 %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
		}
		if (smProductEvent->StartPickAndPlace2YAxisMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2YAxisMotorStop.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorStop(cMC2);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2YAxisMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error stop Pick And Place 2 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
		}
		if (smProductEvent->StartPickAndPlace2YAxisMotorOff.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2YAxisMotorOff.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorOff(cMC2);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2YAxisMotorOffDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error off Pick And Place 2 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
		}
		if (smProductEvent->StartOutputTrayTableXAxisMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableXAxisMotorStop.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableXAxisMotorStop(cMC2);
			if (nError == 0)
			{
				smProductEvent->OutputTrayTableXAxisMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error stop Output Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
		}
		if (smProductEvent->StartOutputTrayTableYAxisMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableYAxisMotorStop.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableYAxisMotorStop(cMC2);
			if (nError == 0)
			{
				smProductEvent->OutputTrayTableYAxisMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error stop Output Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
		}
		if (smProductEvent->StartOutputTrayTableZAxisMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableZAxisMotorStop(cMC2);
			if (nError == 0)
			{
				smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error stop Output Tray Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
		}
		if (smProductEvent->JobSlow.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			if (SlowMode == false)
			{
				nError = cMC2->SetControllerVariable(m_cProductMotorControl->m_motorConfiguration[4].ControllerDetails, "vSLOW", 1);
				nError += cMC2->SendCommand(m_cProductMotorControl->m_motorConfiguration[4].ControllerDetails, "XQ#SLOW,0");
				if (nError == 0)
				{
					SlowMode = true;
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error during set all MC2 slow on %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				}
			}
		}
		else if (smProductEvent->JobSlow.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			if (SlowMode == true)
			{
				nError = cMC2->SetControllerVariable(m_cProductMotorControl->m_motorConfiguration[4].ControllerDetails, "vSLOW", 0);
				nError += cMC2->SendCommand(m_cProductMotorControl->m_motorConfiguration[4].ControllerDetails, "XQ#SLOW,0");
				if (nError == 0)
				{
					SlowMode = false;
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error during set all MC2 slow off %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				}
			}
			else if (SlowMode == true)
			{
				nError = cMC2->SetControllerVariable(m_cProductMotorControl->m_motorConfiguration[4].ControllerDetails, "vSLOW", 0);
				nError += cMC2->SendCommand(m_cProductMotorControl->m_motorConfiguration[4].ControllerDetails, "XQ#SLOW,0");
				if (nError == 0)
				{
					SlowMode = false;
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error during set MC2 slow off %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				}
			}
		}
#pragma region Read Encoder during Teach Mode
		if (smProductEvent->GTCH_RTCH_TEACH_MODE.Set == true)
		{
			//Read encoder value
			int nPosition;
			int nFeedback;
			//Fuji-Galil
			//if(smProductGeneral->nTeachPointMotorType == 1)
			{
				if (smProductGeneral->nTeachPointCardNo == 0)
				{
#pragma region Pick And Place 2 Y Axis Motor
					if (smProductGeneral->nTeachPointAxis == 112)
					{
						if (smProductCustomize->EnablePickAndPlace2YAxisMotor == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->PickAndPlace2YAxisMotorStopDone.Set = false;
								smProductEvent->StartPickAndPlace2YAxisMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}
							char cReceive[80] = "";
							smProductGeneral->nMotorEncoderPosition = (int)(((double)cMC2->GetEncoderPosition(m_cProductMotorControl->m_motorConfiguration[4].Axis)));
							nError = cMC2->SendReceiveCommand(m_cProductMotorControl->m_motorConfiguration[4].ControllerDetails, "MG _TSA", cReceive);
							if (nError == 0)
							{
								int foundAcknowledge = 99;
								for (int i = 0; i < strlen(cReceive); i++)
								{
									if (i > foundAcknowledge)
									{
										cReceive[i] = '\0';
									}
									if (cReceive[i] == ':')
									{
										foundAcknowledge = i;
									}
								}
								nFeedback = (int)atof(cReceive);
								memset(cReceive, 0, sizeof(cReceive));
								if ((nFeedback & 0x02) == 0x02)
									smProductGeneral->nMotorHomeSensor = 1;
								else
									smProductGeneral->nMotorHomeSensor = 0;
								if ((nFeedback & 0x04) == 0x04)
									smProductGeneral->nMotorReverseLimit = 0;
								else
									smProductGeneral->nMotorReverseLimit = 1;
								if ((nFeedback & 0x08) == 0x08)
									smProductGeneral->nMotorForwardLimit = 0;
								else
									smProductGeneral->nMotorForwardLimit = 1;
								if ((nFeedback & 0x20) == 0x20)
									smProductGeneral->nMotorOnStatus = 0;
								else
									smProductGeneral->nMotorOnStatus = 1;
								if ((nFeedback & 0x80) == 0x80)
									smProductGeneral->nMotorMovingStatus = 1;
								else
									smProductGeneral->nMotorMovingStatus = 0;
								if (m_cProductIOControl->IsPickAndPlace2YAxisMotorReady() == true)
									smProductGeneral->nMotorAlarmOn = 0;
								else
									smProductGeneral->nMotorAlarmOn = 1;
							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder Pick And Place 2 Y Axis Motor status.\n");
							}
						}
						else
						{
							m_cLogger->WriteLog("Pick And Place 2 Y Axis Motor is not enabled.\n");
						}
					}
#pragma endregion
#pragma region Output Tray Table X Axis Motor
					if (smProductGeneral->nTeachPointAxis == 104)
					{
						if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->OutputTrayTableXAxisMotorStopDone.Set = false;
								smProductEvent->StartOutputTrayTableXAxisMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}
							char cReceive[80] = "";
							smProductGeneral->nMotorEncoderPosition = (signed int)(((double)cMC2->GetEncoderPosition(m_cProductMotorControl->m_motorConfiguration[5].Axis)));///m_motorConfiguration[1].UnitInOnePulse);
							nError = cMC2->SendReceiveCommand(m_cProductMotorControl->m_motorConfiguration[5].ControllerDetails, "MG _TSB", cReceive);
							if (nError == 0)
							{
								int foundAcknowledge = 99;
								for (int i = 0; i < strlen(cReceive); i++)
								{
									if (i > foundAcknowledge)
									{
										cReceive[i] = '\0';
									}
									if (cReceive[i] == ':')
									{
										foundAcknowledge = i;
									}
								}
								nFeedback = (int)atof(cReceive);
								memset(cReceive, 0, sizeof(cReceive));
								if ((nFeedback & 0x02) == 0x02)
									smProductGeneral->nMotorHomeSensor = 1;
								else
									smProductGeneral->nMotorHomeSensor = 0;
								if ((nFeedback & 0x04) == 0x04)
									smProductGeneral->nMotorReverseLimit = 0;
								else
									smProductGeneral->nMotorReverseLimit = 1;
								if ((nFeedback & 0x08) == 0x08)
									smProductGeneral->nMotorForwardLimit = 0;
								else
									smProductGeneral->nMotorForwardLimit = 1;
								if ((nFeedback & 0x20) == 0x20)
									smProductGeneral->nMotorOnStatus = 0;
								else
									smProductGeneral->nMotorOnStatus = 1;
								if ((nFeedback & 0x80) == 0x80)
									smProductGeneral->nMotorMovingStatus = 1;
								else
									smProductGeneral->nMotorMovingStatus = 0;
								if (m_cProductIOControl->IsOutputTrayTableXAxisMotorReady() == true)
									smProductGeneral->nMotorAlarmOn = 0;
								else
									smProductGeneral->nMotorAlarmOn = 1;
							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder Output Tray Table X Axis Motor status.\n");
							}
						}
						else
						{
							m_cLogger->WriteLog("Output Tray Table X Axis Motor is not enabled.\n");
						}
					}
#pragma endregion
#pragma region Output Tray Table Y Axis Motor
					if (smProductGeneral->nTeachPointAxis == 105)
					{
						if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->OutputTrayTableYAxisMotorStopDone.Set = false;
								smProductEvent->StartOutputTrayTableYAxisMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}
							char cReceive[80] = "";
							smProductGeneral->nMotorEncoderPosition = (int)(((double)cMC2->GetEncoderPosition(m_cProductMotorControl->m_motorConfiguration[6].Axis)));
							nError = cMC2->SendReceiveCommand(m_cProductMotorControl->m_motorConfiguration[6].ControllerDetails, "MG _TSC", cReceive);
							if (nError == 0)
							{
								int foundAcknowledge = 99;
								for (int i = 0; i < strlen(cReceive); i++)
								{
									if (i > foundAcknowledge)
									{
										cReceive[i] = '\0';
									}
									if (cReceive[i] == ':')
									{
										foundAcknowledge = i;
									}
								}
								nFeedback = (int)atof(cReceive);
								memset(cReceive, 0, sizeof(cReceive));
								if ((nFeedback & 0x02) == 0x02)
									smProductGeneral->nMotorHomeSensor = 1;
								else
									smProductGeneral->nMotorHomeSensor = 0;
								if ((nFeedback & 0x04) == 0x04)
									smProductGeneral->nMotorReverseLimit = 0;
								else
									smProductGeneral->nMotorReverseLimit = 1;
								if ((nFeedback & 0x08) == 0x08)
									smProductGeneral->nMotorForwardLimit = 0;
								else
									smProductGeneral->nMotorForwardLimit = 1;
								if ((nFeedback & 0x20) == 0x20)
									smProductGeneral->nMotorOnStatus = 0;
								else
									smProductGeneral->nMotorOnStatus = 1;
								if ((nFeedback & 0x80) == 0x80)
									smProductGeneral->nMotorMovingStatus = 1;
								else
									smProductGeneral->nMotorMovingStatus = 0;
								if (m_cProductIOControl->IsOutputTrayTableYAxisMotorReady() == true)
									smProductGeneral->nMotorAlarmOn = 0;
								else
									smProductGeneral->nMotorAlarmOn = 1;
							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder Output Tray Table Y Axis Motor status.\n");
							}
						}
						else
						{
							m_cLogger->WriteLog("Output Tray Table Y Axis Motor is not enable.\n");
						}
					}
#pragma endregion
#pragma region Output Tray Table Z Axis Motor
					if (smProductGeneral->nTeachPointAxis == 106)
					{
						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
								smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}
							char cReceive[80] = "";
							smProductGeneral->nMotorEncoderPosition = (signed int)(((double)cMC2->GetEncoderPosition(m_cProductMotorControl->m_motorConfiguration[7].Axis)));///m_motorConfiguration[1].UnitInOnePulse);
							nError = cMC2->SendReceiveCommand(m_cProductMotorControl->m_motorConfiguration[7].ControllerDetails, "MG _TSD", cReceive);
							if (nError == 0)
							{
								int foundAcknowledge = 99;
								for (int i = 0; i < strlen(cReceive); i++)
								{
									if (i > foundAcknowledge)
									{
										cReceive[i] = '\0';
									}
									if (cReceive[i] == ':')
									{
										foundAcknowledge = i;
									}
								}
								nFeedback = (int)atof(cReceive);
								memset(cReceive, 0, sizeof(cReceive));
								if ((nFeedback & 0x02) == 0x02)
									smProductGeneral->nMotorHomeSensor = 1;
								else
									smProductGeneral->nMotorHomeSensor = 0;
								if ((nFeedback & 0x04) == 0x04)
									smProductGeneral->nMotorReverseLimit = 0;
								else
									smProductGeneral->nMotorReverseLimit = 1;
								if ((nFeedback & 0x08) == 0x08)
									smProductGeneral->nMotorForwardLimit = 0;
								else
									smProductGeneral->nMotorForwardLimit = 1;
								if ((nFeedback & 0x20) == 0x20)
									smProductGeneral->nMotorOnStatus = 0;
								else
									smProductGeneral->nMotorOnStatus = 1;
								if ((nFeedback & 0x80) == 0x80)
									smProductGeneral->nMotorMovingStatus = 1;
								else
									smProductGeneral->nMotorMovingStatus = 0;
								if (m_cProductIOControl->IsOutputTrayTableZAxisMotorReady() == true)
									smProductGeneral->nMotorAlarmOn = 0;
								else
									smProductGeneral->nMotorAlarmOn = 1;
							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder Output Tray Table Z Axis Motor status.\n");
							}
						}
						else
						{
							m_cLogger->WriteLog("Output Tray Table Z Axis Motor is not enabled.\n");
						}
					}
#pragma endregion
				}
			}
			m_cProductShareVariables->m_lnPeriod_500ms.QuadPart = 5000000;
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
#pragma endregion
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	cMC2->SendCommand(m_cProductMotorControl->m_motorConfiguration[4].ControllerDetails, "HX0;HX1;HX2;HX3;ST;MO");
	cMC2->Disconnect(m_cProductMotorControl->m_motorConfiguration[4].Axis);
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("MC2 thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_MC2_END.Set = true;

	return 0;
}
ULONG CProductThread::MC3Thread(void * nContext)
{
	CMotionLibrary *cMC3 = (CMotionLibrary*)nContext;
	int nError = 0;
	bool SlowMode = false;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("MC3 thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->InitializeMotionController7Done.Set == true
			&& smProductEvent->InitializeMotionController6Done.Set == true
			&& smProductEvent->InitializeMotionController5Done.Set == true)
			break;
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		nError = cMC3->Connect(m_cProductMotorControl->m_motorConfiguration[8].Axis);
		if (nError == 0)
		{
			m_cLogger->WriteLog("Connect to motion controller 3.\n");
			break;
		}
		else if (nError != 0)
		{
			m_cLogger->WriteLog("Error during connect to motion controller 3.\n");
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartInitializeMotionController3.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInitializeMotionController3.Set = false;
			nError = m_cProductMotorControl->MotionController3Initialize(cMC3);
			if (nError == 0)
			{
				smProductEvent->InitializeMotionController3Done.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error during initialize motion controller 3 %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
		}
		if (smProductEvent->StartInputVisionModuleMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputVisionModuleMotorStop.Set = false;
			nError = m_cProductMotorControl->InputVisionModuleMotorStop(cMC3);
			if (nError == 0)
			{
				smProductEvent->InputVisionModuleMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error stop Input Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
		}
		if (smProductEvent->StartS1VisionModuleMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS1VisionModuleMotorStop.Set = false;
			nError = m_cProductMotorControl->S1VisionModuleMotorStop(cMC3);
			if (nError == 0)
			{
				smProductEvent->S1VisionModuleMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error stop S1 Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
		}
		if (smProductEvent->StartS2VisionModuleMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS2VisionModuleMotorStop.Set = false;
			nError = m_cProductMotorControl->S2VisionModuleMotorStop(cMC3);
			if (nError == 0)
			{
				smProductEvent->S2VisionModuleMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error stop S2 Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
		}
		if (smProductEvent->StartS3VisionModuleMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS3VisionModuleMotorStop.Set = false;
			nError = m_cProductMotorControl->S3VisionModuleMotorStop(cMC3);
			if (nError == 0)
			{
				smProductEvent->S3VisionModuleMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error stop S3 Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
		}
		if (smProductEvent->JobSlow.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			if (SlowMode == false)
			{
				nError = cMC3->SetControllerVariable(m_cProductMotorControl->m_motorConfiguration[8].ControllerDetails, "vSLOW", 1);
				nError += cMC3->SendCommand(m_cProductMotorControl->m_motorConfiguration[8].ControllerDetails, "XQ#SLOW,0");
				if (nError == 0)
				{
					SlowMode = true;
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error during set all MC3 slow on %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					//return nError;
				}
			}
		}
		else if (smProductEvent->JobSlow.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			if (SlowMode == true)
			{
				nError = cMC3->SetControllerVariable(m_cProductMotorControl->m_motorConfiguration[8].ControllerDetails, "vSLOW", 0);
				nError += cMC3->SendCommand(m_cProductMotorControl->m_motorConfiguration[8].ControllerDetails, "XQ#SLOW,0");
				if (nError == 0)
				{
					SlowMode = false;
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error during set all MC3 slow off %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					//return nError;
				}
			}
			else if (SlowMode == true)
			{
				nError = cMC3->SetControllerVariable(m_cProductMotorControl->m_motorConfiguration[8].ControllerDetails, "vSLOW", 0);
				nError += cMC3->SendCommand(m_cProductMotorControl->m_motorConfiguration[8].ControllerDetails, "XQ#SLOW,0");
				if (nError == 0)
				{
					SlowMode = false;
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error during set MC3 slow off %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					//return nError;
				}
			}
		}
#pragma region Read Encoder during Teach Mode
		if (smProductEvent->GTCH_RTCH_TEACH_MODE.Set == true)
		{
			//Read encoder value
			int nPosition;
			int nFeedback;
			//Fuji-Galil
			//if(smProductGeneral->nTeachPointMotorType == 1)
			{
				if (smProductGeneral->nTeachPointCardNo == 0)
				{
#pragma region Input Vision Module Motor
					if (smProductGeneral->nTeachPointAxis == 115)
					{
						if (smProductCustomize->EnableInputVisionMotor == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->InputVisionModuleMotorStopDone.Set = false;
								smProductEvent->StartInputVisionModuleMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}
							char cReceive[80] = "";
							smProductGeneral->nMotorEncoderPosition = (int)(((double)cMC3->GetEncoderPosition(m_cProductMotorControl->m_motorConfiguration[8].Axis)));
							nError = cMC3->SendReceiveCommand(m_cProductMotorControl->m_motorConfiguration[8].ControllerDetails, "MG _TSA", cReceive);
							if (nError == 0)
							{
								int foundAcknowledge = 99;
								for (int i = 0; i < strlen(cReceive); i++)
								{
									if (i > foundAcknowledge)
									{
										cReceive[i] = '\0';
									}
									if (cReceive[i] == ':')
									{
										foundAcknowledge = i;
									}
								}
								nFeedback = (int)atof(cReceive);
								memset(cReceive, 0, sizeof(cReceive));
								if ((nFeedback & 0x02) == 0x02)
									smProductGeneral->nMotorHomeSensor = 1;
								else
									smProductGeneral->nMotorHomeSensor = 0;
								if ((nFeedback & 0x04) == 0x04)
									smProductGeneral->nMotorReverseLimit = 0;
								else
									smProductGeneral->nMotorReverseLimit = 1;
								if ((nFeedback & 0x08) == 0x08)
									smProductGeneral->nMotorForwardLimit = 0;
								else
									smProductGeneral->nMotorForwardLimit = 1;
								if ((nFeedback & 0x20) == 0x20)
									smProductGeneral->nMotorOnStatus = 0;
								else
									smProductGeneral->nMotorOnStatus = 1;
								if ((nFeedback & 0x80) == 0x80)
									smProductGeneral->nMotorMovingStatus = 1;
								else
									smProductGeneral->nMotorMovingStatus = 0;
								if (m_cProductIOControl->IsInputVisionModuleMotorReady() == true)
									smProductGeneral->nMotorAlarmOn = 0;
								else
									smProductGeneral->nMotorAlarmOn = 1;
							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder Input Vision Module Motor status.\n");
							}
						}
						else
						{
							m_cLogger->WriteLog("Input Vision Module Motor is not enable.\n");
						}
					}
#pragma endregion
#pragma region S2 Vision Module Motor
					if (smProductGeneral->nTeachPointAxis == 116)
					{
						if (smProductCustomize->EnableS2VisionMotor == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->S2VisionModuleMotorStopDone.Set = false;
								smProductEvent->StartS2VisionModuleMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}
							char cReceive[80] = "";
							smProductGeneral->nMotorEncoderPosition = (signed int)(((double)cMC3->GetEncoderPosition(m_cProductMotorControl->m_motorConfiguration[10].Axis)));///m_motorConfiguration[1].UnitInOnePulse);
							nError = cMC3->SendReceiveCommand(m_cProductMotorControl->m_motorConfiguration[10].ControllerDetails, "MG _TSC", cReceive);
							if (nError == 0)
							{
								int foundAcknowledge = 99;
								for (int i = 0; i < strlen(cReceive); i++)
								{
									if (i > foundAcknowledge)
									{
										cReceive[i] = '\0';
									}
									if (cReceive[i] == ':')
									{
										foundAcknowledge = i;
									}
								}
								nFeedback = (int)atof(cReceive);
								memset(cReceive, 0, sizeof(cReceive));
								if ((nFeedback & 0x02) == 0x02)
									smProductGeneral->nMotorHomeSensor = 1;
								else
									smProductGeneral->nMotorHomeSensor = 0;
								if ((nFeedback & 0x04) == 0x04)
									smProductGeneral->nMotorReverseLimit = 0;
								else
									smProductGeneral->nMotorReverseLimit = 1;
								if ((nFeedback & 0x08) == 0x08)
									smProductGeneral->nMotorForwardLimit = 0;
								else
									smProductGeneral->nMotorForwardLimit = 1;
								if ((nFeedback & 0x20) == 0x20)
									smProductGeneral->nMotorOnStatus = 0;
								else
									smProductGeneral->nMotorOnStatus = 1;
								if ((nFeedback & 0x80) == 0x80)
									smProductGeneral->nMotorMovingStatus = 1;
								else
									smProductGeneral->nMotorMovingStatus = 0;
								if (m_cProductIOControl->IsS2VisionModuleMotorReady() == true)
									smProductGeneral->nMotorAlarmOn = 0;
								else
									smProductGeneral->nMotorAlarmOn = 1;
							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder S2 Vision Module Motor status.\n");
							}
						}
						else
						{
							m_cLogger->WriteLog("S2 Vision Module Motor is not enabled.\n");
						}
					}
#pragma endregion
#pragma region S1 Vision Module Motor
					if (smProductGeneral->nTeachPointAxis == 117)
					{
						if (smProductCustomize->EnableS1VisionMotor == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->S1VisionModuleMotorStopDone.Set = false;
								smProductEvent->StartS1VisionModuleMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}
							char cReceive[80] = "";
							smProductGeneral->nMotorEncoderPosition = (signed int)(((double)cMC3->GetEncoderPosition(m_cProductMotorControl->m_motorConfiguration[9].Axis)));///m_motorConfiguration[1].UnitInOnePulse);
							nError = cMC3->SendReceiveCommand(m_cProductMotorControl->m_motorConfiguration[9].ControllerDetails, "MG _TSB", cReceive);
							if (nError == 0)
							{
								int foundAcknowledge = 99;
								for (int i = 0; i < strlen(cReceive); i++)
								{
									if (i > foundAcknowledge)
									{
										cReceive[i] = '\0';
									}
									if (cReceive[i] == ':')
									{
										foundAcknowledge = i;
									}
								}
								nFeedback = (int)atof(cReceive);
								memset(cReceive, 0, sizeof(cReceive));
								if ((nFeedback & 0x02) == 0x02)
									smProductGeneral->nMotorHomeSensor = 1;
								else
									smProductGeneral->nMotorHomeSensor = 0;
								if ((nFeedback & 0x04) == 0x04)
									smProductGeneral->nMotorReverseLimit = 0;
								else
									smProductGeneral->nMotorReverseLimit = 1;
								if ((nFeedback & 0x08) == 0x08)
									smProductGeneral->nMotorForwardLimit = 0;
								else
									smProductGeneral->nMotorForwardLimit = 1;
								if ((nFeedback & 0x20) == 0x20)
									smProductGeneral->nMotorOnStatus = 0;
								else
									smProductGeneral->nMotorOnStatus = 1;
								if ((nFeedback & 0x80) == 0x80)
									smProductGeneral->nMotorMovingStatus = 1;
								else
									smProductGeneral->nMotorMovingStatus = 0;
								if (m_cProductIOControl->IsS1VisionModuleMotorReady() == true)
									smProductGeneral->nMotorAlarmOn = 0;
								else
									smProductGeneral->nMotorAlarmOn = 1;
							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder S1 Vision Module Motor status.\n");
							}
						}
						else
						{
							m_cLogger->WriteLog("S1 Vision Module Motor is not enabled.\n");
						}
					}
#pragma endregion
#pragma region S3 Vision Module Motor
					if (smProductGeneral->nTeachPointAxis == 121)
					{
						if (smProductCustomize->EnableS3VisionMotor == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->S3VisionModuleMotorStopDone.Set = false;
								smProductEvent->StartS3VisionModuleMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}
							char cReceive[80] = "";
							smProductGeneral->nMotorEncoderPosition = (signed int)(((double)cMC3->GetEncoderPosition(m_cProductMotorControl->m_motorConfiguration[11].Axis)));///m_motorConfiguration[1].UnitInOnePulse);
							nError = cMC3->SendReceiveCommand(m_cProductMotorControl->m_motorConfiguration[11].ControllerDetails, "MG _TSD", cReceive);
							if (nError == 0)
							{
								int foundAcknowledge = 99;
								for (int i = 0; i < strlen(cReceive); i++)
								{
									if (i > foundAcknowledge)
									{
										cReceive[i] = '\0';
									}
									if (cReceive[i] == ':')
									{
										foundAcknowledge = i;
									}
								}
								nFeedback = (int)atof(cReceive);
								memset(cReceive, 0, sizeof(cReceive));
								if ((nFeedback & 0x02) == 0x02)
									smProductGeneral->nMotorHomeSensor = 1;
								else
									smProductGeneral->nMotorHomeSensor = 0;
								if ((nFeedback & 0x04) == 0x04)
									smProductGeneral->nMotorReverseLimit = 0;
								else
									smProductGeneral->nMotorReverseLimit = 1;
								if ((nFeedback & 0x08) == 0x08)
									smProductGeneral->nMotorForwardLimit = 0;
								else
									smProductGeneral->nMotorForwardLimit = 1;
								if ((nFeedback & 0x20) == 0x20)
									smProductGeneral->nMotorOnStatus = 0;
								else
									smProductGeneral->nMotorOnStatus = 1;
								if ((nFeedback & 0x80) == 0x80)
									smProductGeneral->nMotorMovingStatus = 1;
								else
									smProductGeneral->nMotorMovingStatus = 0;
								if (m_cProductIOControl->IsS3VisionModuleMotorReady() == true)
									smProductGeneral->nMotorAlarmOn = 0;
								else
									smProductGeneral->nMotorAlarmOn = 1;
							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder S3 Vision Module Motor status.\n");
							}
						}
						else
						{
							m_cLogger->WriteLog("S3 Vision Module Motor is not enabled.\n");
						}
					}
#pragma endregion

				}
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
#pragma endregion
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	cMC3->SendCommand(m_cProductMotorControl->m_motorConfiguration[8].ControllerDetails, "HX0;HX1;HX2;HX3;ST;MO;");
	cMC3->Disconnect(m_cProductMotorControl->m_motorConfiguration[8].Axis);
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("MC3 thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_MC3_END.Set = true;

	return 0;
}
ULONG CProductThread::MC4Thread(void * nContext)
{
	CMotionLibrary *cMC4 = (CMotionLibrary*)nContext;
	int nError = 0;
	bool SlowMode = false;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("MC4 thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->InitializeMotionController7Done.Set == true 
			&& smProductEvent->InitializeMotionController6Done.Set==true
			&& smProductEvent->InitializeMotionController5Done.Set == true)
			break;
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	cMC4->SendCommand(m_cProductMotorControl->m_motorConfiguration[12].ControllerDetails, "HX0;HX1;HX2;HX3;ST;MO;");
	cMC4->Disconnect(m_cProductMotorControl->m_motorConfiguration[12].Axis);
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("MC4 thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_MC4_END.Set = true;

	return 0;
}
ULONG CProductThread::MC5Thread(void * nContext)//PNP 1
{
	CMotionLibrary *cMC5 = (CMotionLibrary*)nContext;
	int nError = 0;
	bool SlowMode = false;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("MC5 thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->InitializeMotionController7Done.Set == true)
			break;
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductEvent->InitializeMotionController5Done.Set = false;
	if (smProductCustomize->EnablePickAndPlace1XAxisMotor == true)
	{
		nError = m_cProductMotorControl->AgitoTCPIPConnect(0, "192.168.1.10", 50000);
	}
	if (nError != 0)
	{
		m_cLogger->WriteLog("Error connect Pick And Place 1 X Axis Motor.\n");
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1s);
		if (smProductCustomize->EnablePickAndPlace1XAxisMotor == true)
		{
			nError = m_cProductMotorControl->AgitoTCPIPConnect(0, "192.168.1.10", 50000);
		}
		if (nError != 0)
		{
			m_cLogger->WriteLog("Error connect Pick And Place 1 X Axis Motor.\n");
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1s);
		}
		else
		{
			smProductEvent->InitializeMotionController5Done.Set = true;
			m_cLogger->WriteLog("Connect Pick And Place 1 X Axis Motor successfully.\n");
		}
	}
	else
	{
		smProductEvent->InitializeMotionController5Done.Set = true;
		m_cLogger->WriteLog("Connect Pick And Place 1 X Axis Motor successfully.\n");
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartPickAndPlace1XAxisMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1XAxisMotorStop.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1XAxisMotorStop(cMC5);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1XAxisMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error stop Pick And Place 1 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1XAxisMotorOff.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1XAxisMotorOff.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1XAxisMotorOff(cMC5);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1XAxisMotorOffDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error off Pick And Place 1 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->JobSlow.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			if (SlowMode == false)
			{
				//nError = cMC4Galil->SendCommand("vSLOW=1");
				nError = m_cProductMotorControl->AgitoMotorSpeed(0,0, 10000, 500, 25000, 25000);
				Sleep(5);
				if (nError == 0)
				{
					SlowMode = true;
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error during set all MC5 slow on %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					//return nError;
				}
			}
		}
		else if (smProductEvent->JobSlow.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			if (SlowMode == true)
			{
				nError = m_cProductMotorControl->AgitoMotorSpeed(0,0, 50000, 500, 250000, 250000);
				Sleep(5);
				if (nError == 0)
				{
					SlowMode = false;
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error during set all MC5 slow off %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					//return nError;
				}
			}
		}
#pragma region Read Encoder during Teach Mode
		if (smProductEvent->GTCH_RTCH_TEACH_MODE.Set == true)
		{
			//Read encoder value
			int nPosition;
			int nFeedback;
			//Fuji-Galil
			//if(smProductGeneral->nTeachPointMotorType == 1)
			{
				if (smProductGeneral->nTeachPointCardNo == 0)
				{
#pragma region Pick And Place 1 X Axis
					if (smProductGeneral->nTeachPointAxis == 107)
					{
						if (smProductCustomize->EnablePickAndPlace1XAxisMotor == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->PickAndPlace1XAxisMotorStopDone.Set = false;
								smProductEvent->StartPickAndPlace1XAxisMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}
							char cReceive[80] = "";
							int ReturnResult = 0;
							smProductGeneral->nMotorEncoderPosition = m_cProductMotorControl->ReadAgitoMotorPosition(0,0,0);
							nError = 0;
							if (nError == 0)
							{

								nFeedback = (int)atof(cReceive);
								memset(cReceive, 0, sizeof(cReceive));

								ReturnResult = m_cProductMotorControl->ReadAgitoMotorHomeStat(0,0);
								if (ReturnResult == 1)
									smProductGeneral->nMotorHomeSensor = 1;
								else
									smProductGeneral->nMotorHomeSensor = 0;

								ReturnResult = m_cProductMotorControl->ReadAgitoMotorLimit(0,0);
								if (ReturnResult == 1)
									smProductGeneral->nMotorReverseLimit = 1;
								else
									smProductGeneral->nMotorReverseLimit = 0;
								if (ReturnResult == 2)
									smProductGeneral->nMotorForwardLimit = 1;
								else
									smProductGeneral->nMotorForwardLimit = 0;
								if (ReturnResult == 3)
								{
									smProductGeneral->nMotorReverseLimit = 1;
									smProductGeneral->nMotorForwardLimit = 0;
								}

								ReturnResult = m_cProductMotorControl->ReadAgitoMotorOnOff(0,0);
								if (ReturnResult == 1)
									smProductGeneral->nMotorOnStatus = 1;
								else
									smProductGeneral->nMotorOnStatus = 0;

								ReturnResult = m_cProductMotorControl->ReadAgitoMotorMoving(0,0);
								if (ReturnResult == 1)
									smProductGeneral->nMotorMovingStatus = 1;
								else
									smProductGeneral->nMotorMovingStatus = 0;

								if (m_cProductIOControl->IsPickAndPlace1XAxisMotorReady() == true)
									smProductGeneral->nMotorAlarmOn = 0;
								else
									smProductGeneral->nMotorAlarmOn = 1;
							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder Pick And Place 1 X Axis Motor status.\n");
							}
						}
						else
						{
							m_cLogger->WriteLog("Pick And Place 1 X Axis Motor is not enabled.\n");
						}
					}
#pragma endregion
				}
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
#pragma endregion
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductMotorControl->AgitoStopMotor(0, 0);
	m_cProductMotorControl->AgitoServoOn(0, 0, 0);
	m_cProductMotorControl->AgitoClosePort(0);
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("MC5 thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_MC5_END.Set = true;
	return 0;
}
ULONG CProductThread::MC6Thread(void * nContext) //PNP2
{
	CMotionLibrary *cMC6 = (CMotionLibrary*)nContext;
	int nError = 0;
	bool SlowMode = false;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("MC6 thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->InitializeMotionController5Done.Set == true && smProductEvent->InitializeMotionController7Done.Set == true)
		{
			m_cLogger->WriteLog("Start connect Pick and place 2 x axis motor.\n");
			break;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductEvent->InitializeMotionController6Done.Set = false;
	if (smProductCustomize->EnablePickAndPlace2XAxisMotor == true)
	{
		nError = m_cProductMotorControl->AgitoTCPIPConnect1(1, "192.168.1.11", 50000);
	}
	if (nError != 0)
	{
		m_cLogger->WriteLog("Error connect Pick And Place 2 X Axis Motor.\n");
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1s);
		if (smProductCustomize->EnablePickAndPlace2XAxisMotor == true)
		{
			nError = m_cProductMotorControl->AgitoTCPIPConnect1(1, "192.168.1.11", 50000);
		}
		if (nError != 0)
		{
			m_cLogger->WriteLog("Error connect Pick And Place 2 X Axis Motor.\n");
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1s);
		}
		else
		{
			smProductEvent->InitializeMotionController6Done.Set = true;
			m_cLogger->WriteLog("Connect Pick And Place 2 X Axis Motor successfully.\n");
		}
	}
	else
	{
		smProductEvent->InitializeMotionController6Done.Set = true;
		m_cLogger->WriteLog("Connect Pick And Place 2 X Axis Motor successfully.\n");
	}	
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartPickAndPlace2XAxisMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2XAxisMotorStop.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2XAxisMotorStop(cMC6);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2XAxisMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error stop Pick And Place 2 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2XAxisMotorOff.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2XAxisMotorOff.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2XAxisMotorOff(cMC6);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2XAxisMotorOffDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error off Pick And Place 2 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->JobSlow.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			if (SlowMode == false)
			{
				nError = m_cProductMotorControl->AgitoMotorSpeed1(1,0, 10000, 500, 25000, 25000);
				if (nError == 0)
				{
					SlowMode = true;
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error during set all MC6 slow on %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				}
			}
		}
		else if (smProductEvent->JobSlow.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			if (SlowMode == true)
			{
				nError = m_cProductMotorControl->AgitoMotorSpeed1(1, 0, 50000, 500, 250000, 250000);
				if (nError == 0)
				{
					SlowMode = false;
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error during set all MC6 slow off %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				}
			}
		}
#pragma region Read Encoder during Teach Mode
		if (smProductEvent->GTCH_RTCH_TEACH_MODE.Set == true)
		{
			//Read encoder value
			int nPosition;
			int nFeedback;
			//Fuji-Galil
			//if(smProductGeneral->nTeachPointMotorType == 1)
			{
				if (smProductGeneral->nTeachPointCardNo == 0)
				{
#pragma region Pick And Place 2 X Axis
					if (smProductGeneral->nTeachPointAxis == 111)
					{
						if (smProductCustomize->EnablePickAndPlace2XAxisMotor == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->PickAndPlace2XAxisMotorStopDone.Set = false;
								smProductEvent->StartPickAndPlace2XAxisMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}
							char cReceive[80] = "";
							int ReturnResult = 0;
							smProductGeneral->nMotorEncoderPosition = m_cProductMotorControl->ReadAgitoMotorPosition(1,0,0);
							nError = 0;
							if (nError == 0)
							{

								nFeedback = (int)atof(cReceive);
								memset(cReceive, 0, sizeof(cReceive));

								ReturnResult = m_cProductMotorControl->ReadAgitoMotorHomeStat(1,0);
								if (ReturnResult == 1)
									smProductGeneral->nMotorHomeSensor = 1;
								else
									smProductGeneral->nMotorHomeSensor = 0;

								ReturnResult = m_cProductMotorControl->ReadAgitoMotorLimit(1,0);
								if (ReturnResult == 1)
									smProductGeneral->nMotorReverseLimit = 1;
								else
									smProductGeneral->nMotorReverseLimit = 0;
								if (ReturnResult == 2)
									smProductGeneral->nMotorForwardLimit = 1;
								else
									smProductGeneral->nMotorForwardLimit = 0;
								if (ReturnResult == 3)
								{
									smProductGeneral->nMotorReverseLimit = 1;
									smProductGeneral->nMotorForwardLimit = 0;
								}

								ReturnResult = m_cProductMotorControl->ReadAgitoMotorOnOff(1,0);
								if (ReturnResult == 1)
									smProductGeneral->nMotorOnStatus = 1;
								else
									smProductGeneral->nMotorOnStatus = 0;

								ReturnResult = m_cProductMotorControl->ReadAgitoMotorMoving(1,0);
								if (ReturnResult == 1)
									smProductGeneral->nMotorMovingStatus = 1;
								else
									smProductGeneral->nMotorMovingStatus = 0;

								if (m_cProductIOControl->IsPickAndPlace2XAxisMotorReady() == true)
									smProductGeneral->nMotorAlarmOn = 0;
								else
									smProductGeneral->nMotorAlarmOn = 1;
							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder Pick And Place 2 X Axis Motor status.\n");
							}
						}
						else
						{
							m_cLogger->WriteLog("Pick And Place 2 X Axis Motor is not enable.\n");
						}
					}
#pragma endregion
				}
			}
			m_cProductShareVariables->m_lnPeriod_500ms.QuadPart = 5000000;
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
#pragma endregion
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductMotorControl->AgitoStopMotor(1, 0);
	m_cProductMotorControl->AgitoServoOn(1, 0, 0);
	m_cProductMotorControl->AgitoClosePort(1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("MC6 thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_MC6_END.Set = true;

	return 0;
}
ULONG CProductThread::MC7Thread(void * nContext) //THK
{
	CMotionLibrary *cMC7 = (CMotionLibrary*)nContext;
	int nError = 0;
	bool SlowMode = false;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("MC7 thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	if (smProductSetting->EnablePH[0])
		RtPrintf("mProductCustomize->EnablePickAndPlace1Module enable\n");
	else
		RtPrintf("mProductCustomize->EnablePickAndPlace1Module disable\n");
	if (smProductSetting->EnablePH[1])
		RtPrintf("mProductCustomize->EnablePickAndPlace2Module enable\n");
	else
		RtPrintf("mProductCustomize->EnablePickAndPlace2Module disable\n");
	if (smProductCustomize->EnableMotionController7 == false)
	{
		smProductEvent->InitializeMotionController7Done.Set = true;
		smProductEvent->RTHD_RMAIN_MC7_END.Set = true;
		return 0;
	}

	nError = m_cProductMotorControl->THKDisconnect(0);
	if (nError == 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Disconnect To THK done.\n");
	}
	else if (nError != 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Disconnect THK 1 index Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		//return nError;
	}
	nError = m_cMotion->m_kingstarController->KSInitialize();
	if (nError == 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Initialized to THK done.\n");
	}
	else if (nError != 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Initialize THK  index Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Try reInitializing THK.\n");
		nError = m_cMotion->m_kingstarController->KSInitialize();
		if (nError == 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Initialized to THK done.\n");
		}
		else
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Try reInitialize THK fail.\n");
	}
	smProductEvent->InitializeMotionController7Done.Set = false;
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Start connect to THK.\n");
	nError = m_cProductMotorControl->THKConnect(0);
	if (nError == 0)
	{
		smProductEvent->InitializeMotionController7Done.Set = true;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Connected to THK done.\n");
	}
	else if (nError != 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error connect THK 1 index Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Start KingStar Reconnect.\n");
		RtPrintf("Start KingStar Reconnect.\n");
		nError = m_cProductMotorControl->THKReconnect(0);
		if (nError == 0)
		{
			smProductEvent->InitializeMotionController7Done.Set = true;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Connected to THK done.\n");
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error connect To KingStar %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
	}

	/*else
	{
		RtPrintf("EnablePickAndPlaceModule is disabled.\n");
		m_cProductShareVariables->UpdateMessageToGUIAndLog("EnablePickAndPlaceModule is disabled.\n");
		nError = m_cMotion->m_kingstarController->KSInitialize();
		if (nError == 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Initialized to THK done.\n");
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Initialize THK 1 index Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		smProductModuleStatus->IsKingStarConnected = false;
		smProductEvent->InitializeEtherCATDone.Set = true;
	}*/

	//while (smProductEvent->ExitRTX.Set == false)
	//{
	//	if (smProductEvent->InitializeEtherCATDone.Set == true)
	//		break;
	//	RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	//}
	while (smProductEvent->ExitRTX.Set == false)
	{

		if (smProductEvent->StartPickAndPlace1ZAxisMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisMotorStop.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorStop(cMC7);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1ZAxisMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Stop Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisMotorOff.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisMotorOff.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorOff(cMC7);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1ZAxisMotorOffDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Off Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ZAxisMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ZAxisMotorStop.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorStop(cMC7);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2ZAxisMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Stop Pick And Place 2 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ZAxisMotorOff.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ZAxisMotorOff.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorOff(cMC7);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2ZAxisMotorOffDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Off Pick And Place 2 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ThetaAxisMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ThetaAxisMotorStop.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1ThetaAxisMotorStop(cMC7);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1ThetaAxisMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Stop Pick And Place 1 Theta Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ThetaAxisMotorStop.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ThetaAxisMotorStop.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2ThetaAxisMotorStop(cMC7);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2ThetaAxisMotorStopDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Stop Pick And Place 2 Theta Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1THKMotorOff.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1THKMotorOff.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1THKMotorOff(cMC7);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1THKMotorOffDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Off Pick And Place 1 THK Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2THKMotorOff.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2THKMotorOff.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2THKMotorOff(cMC7);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2THKMotorOffDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Off Pick And Place 2 THK Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->JobSlow.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			if (SlowMode == false)
			{
				//nError = cMC4Galil->SendCommand("vSLOW=1");
				//nError = cMC4->SetControllerVariable(m_cProductMotorControl->m_motorConfiguration[12].ControllerDetails, "vSLOW", 1);
				//nError = cMC4->SendCommand(m_cProductMotorControl->m_motorConfiguration[12].ControllerDetails, "XQ#SLOW,0");
				if (nError == 0)
				{
					SlowMode = true;
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error during set all MC7 slow on %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				}
			}
		}
		else if (smProductEvent->JobSlow.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			if (SlowMode == true)
			{
				//nError = cMC4->SetControllerVariable(m_cProductMotorControl->m_motorConfiguration[12].ControllerDetails, "vSLOW", 0);
				//nError = cMC4->SendCommand(m_cProductMotorControl->m_motorConfiguration[12].ControllerDetails, "XQ#SLOW,0");
				if (nError == 0)
				{
					SlowMode = false;
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error during set all MC7 slow off %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				}
			}
			else if (SlowMode == true)
			{
				//nError = cMC4->SetControllerVariable(m_cProductMotorControl->m_motorConfiguration[12].ControllerDetails, "vSLOW", 0);
				//nError = cMC4->SendCommand(m_cProductMotorControl->m_motorConfiguration[12].ControllerDetails, "XQ#SLOW,0");
				if (nError == 0)
				{
					SlowMode = false;
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error during set MC7 slow off %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				}
			}
		}
#pragma region Read Encoder during Teach Mode
		if (smProductEvent->GTCH_RTCH_TEACH_MODE.Set == true)
		{
			//Read encoder value
			int nPosition;
			int nFeedback;
			//Fuji-Galil
			//if(smProductGeneral->nTeachPointMotorType == 1)
			{
				if (smProductGeneral->nTeachPointCardNo == 0)
				{
#pragma region Pick And Place 1 Z Axis Motor
					if (smProductGeneral->nTeachPointAxis == 109)
					{
						if (smProductCustomize->EnablePickAndPlace1Module == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->PickAndPlace1ZAxisMotorStopDone.Set = false;
								smProductEvent->StartPickAndPlace1ZAxisMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}
							char cReceive[80] = "";
							signed long encoderValue = 0;
							m_cProductMotorControl->THKReadEncoderValue(0, 0, &encoderValue);
							smProductGeneral->nMotorEncoderPosition = encoderValue;
							if (m_cProductMotorControl->THKReadMotorServoStatus(0, 0) == 0)
							{

							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder Pick And Place 1 Z Axis Motor status.\n");
							}
							m_cProductMotorControl->THKReadPressureValue(0, &smProductProduction->THK1CurrentPressureValue);
							m_cProductMotorControl->THKReadForceValue(0, &smProductProduction->THK1CurrentForceValue);
							m_cProductMotorControl->THKReadFlowRateValue(0, &smProductProduction->THK1CurrentFlowRate);
						}
						else
						{
							m_cLogger->WriteLog("Pick And Place 1 Z Axis Motor is not enable.\n");
						}
					}
#pragma endregion
#pragma region Pick And Place 1 Rotation Axis Motor
					if (smProductGeneral->nTeachPointAxis == 110)
					{
						if (smProductCustomize->EnablePickAndPlace1Module == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->PickAndPlace1ThetaAxisMotorStopDone.Set = false;
								smProductEvent->StartPickAndPlace1ThetaAxisMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}
							char cReceive[80] = "";
							signed long encoderValue = 0;
							m_cProductMotorControl->THKReadEncoderValue(0, 1, &encoderValue);
							/*if (encoderValue < 0)
							{
								encoderValue = 180000 - encoderValue;
							}*/
							smProductGeneral->nMotorEncoderPosition = encoderValue;
							//nError = cMC4->SendReceiveCommand(m_cProductMotorControl->m_motorConfiguration[12].ControllerDetails, "MG _TSA", cReceive);
							if (m_cProductMotorControl->THKReadMotorServoStatus(0, 1) == 0)
							{

							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder Pick And Place 1 Rotation Axis Motor status.\n");
							}
							m_cProductMotorControl->THKReadPressureValue(0, &smProductProduction->THK1CurrentPressureValue);
							m_cProductMotorControl->THKReadForceValue(0, &smProductProduction->THK1CurrentForceValue);
							m_cProductMotorControl->THKReadFlowRateValue(0, &smProductProduction->THK1CurrentFlowRate);
						}
						else
						{
							m_cLogger->WriteLog("Pick And Place 1 Rotation Axis Motor is not enable.\n");
						}
					}
#pragma endregion
#pragma region Pick And Place 2 Z Axis Motor
					if (smProductGeneral->nTeachPointAxis == 113)
					{
						if (smProductCustomize->EnablePickAndPlace2Module == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->PickAndPlace2ZAxisMotorStopDone.Set = false;
								smProductEvent->StartPickAndPlace2ZAxisMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}
							char cReceive[80] = "";
							signed long encoderValue = 0;
							m_cProductMotorControl->THKReadEncoderValue(1, 0, &encoderValue);
							smProductGeneral->nMotorEncoderPosition = encoderValue;
							//nError = cMC4->SendReceiveCommand(m_cProductMotorControl->m_motorConfiguration[12].ControllerDetails, "MG _TSA", cReceive);
							if (m_cProductMotorControl->THKReadMotorServoStatus(1, 0) == 0)
							{

							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder Pick And Place 2 Z Axis Motor status.\n");
							}
							m_cProductMotorControl->THKReadPressureValue(1, &smProductProduction->THK2CurrentPressureValue);
							m_cProductMotorControl->THKReadForceValue(1, &smProductProduction->THK2CurrentForceValue);
							m_cProductMotorControl->THKReadFlowRateValue(1, &smProductProduction->THK2CurrentFlowRate);
						}
						else
						{
							m_cLogger->WriteLog("Pick And Place 2 Z Axis is not enable.\n");
						}
					}
#pragma endregion
#pragma region Pick And Place 2 Rotation Axis Motor
					if (smProductGeneral->nTeachPointAxis == 114)
					{
						if (smProductCustomize->EnablePickAndPlace2Module == true)
						{
							if (smProductEvent->GTCH_RTCH_MOTOR_STOP.Set == true)
							{
								smProductEvent->PickAndPlace2ThetaAxisMotorStopDone.Set = false;
								smProductEvent->StartPickAndPlace2ThetaAxisMotorStop.Set = true;
								smProductEvent->GTCH_RTCH_MOTOR_STOP.Set = false;
								continue;
							}
							char cReceive[80] = "";
							signed long encoderValue = 0;
							m_cProductMotorControl->THKReadEncoderValue(1, 1, &encoderValue);
						/*	if (encoderValue < 0)
							{
								encoderValue = 180000 - encoderValue;
							}*/
							smProductGeneral->nMotorEncoderPosition = encoderValue;
							//nError = cMC4->SendReceiveCommand(m_cProductMotorControl->m_motorConfiguration[12].ControllerDetails, "MG _TSA", cReceive);
							if (m_cProductMotorControl->THKReadMotorServoStatus(1, 1) == 0)
							{

							}
							else
							{
								m_cLogger->WriteLog("Error during read encoder Pick And Place 2 Theta Axis Motor status.\n");
							}
							m_cProductMotorControl->THKReadPressureValue(1, &smProductProduction->THK2CurrentPressureValue);
							m_cProductMotorControl->THKReadForceValue(1, &smProductProduction->THK2CurrentForceValue);
							m_cProductMotorControl->THKReadFlowRateValue(1, &smProductProduction->THK2CurrentFlowRate);
						}
						else
						{
							m_cLogger->WriteLog("Pick And Place 2 Theta Axis is not enabled.\n");
						}
					}
#pragma endregion

#pragma endregion
				}
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}

		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Start disconnect to THK.\n");
	nError = m_cProductMotorControl->THKDisconnect(0);
	if (nError == 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Disconnect to THK done.\n");
	}
	else if (nError != 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Disconnect THK 1 index Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		//return nError;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("MC7 thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_MC7_END.Set = true;

	return 0;
}
#pragma endregion

#pragma region Motor Thread
ULONG CProductThread::PickAndPlace1YAxisMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Pick And Place 1 Y Axis thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartPickAndPlace1YAxisMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1YAxisMotorHome.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1YAxisMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home Pick And Place 1 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1YAxisMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1YAxisMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick And Place 1 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1YAxisMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1YAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMove(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1YAxisMotorMoveDone.Set = true;
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("UPH: Pick And Place 1 Y Axis Motor Test %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Pick And Place 1 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1YAxisMotorMoveCurve.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1YAxisMotorMoveCurve.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMoveCurve(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{
					smProductEvent->PickAndPlace1YAxisMotorMoveCurve.Set = false;
				}
				smProductEvent->PickAndPlace1YAxisMotorMoveCurveDone.Set = true;
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("UPH: Pick And Place 1 Y Axis Motor Test Curve %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Pick And Place 1 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1YAxisMotorMoveToInputPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1YAxisMotorMoveToInputPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMoveToInputPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{
					//smProductEvent->PickAndPlace1YAxisMotorMoveCurve.Set = false;
				}
				smProductEvent->PickAndPlace1YAxisMotorMoveToInputPositionDone.Set = true;
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("UPH: Pick And Place 1 Y Axis Motor Test %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Input Position Pick And Place 1 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1YAxisMotorMoveToInputPositionCurve.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1YAxisMotorMoveToInputPositionCurve.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMoveToInputPositionCurve(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{
					smProductEvent->PickAndPlace1YAxisMotorMoveCurve.Set = false;
				}
				smProductEvent->PickAndPlace1YAxisMotorMoveToInputPositionCurveDone.Set = true;
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("UPH: Pick And Place 1 Y Axis Motor Test Curve %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Input Position Pick And Place 1 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1YAxisMotorMoveToS1Position.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1YAxisMotorMoveToS1Position.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMoveToS1Position(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1YAxisMotorMoveToS1PositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move S1 Position Pick And Place 1 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1YAxisMotorMoveToS3Position.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1YAxisMotorMoveToS3Position.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMoveToS3Position(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1YAxisMotorMoveToS3PositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move S3 Position Pick And Place 1 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1YAxisMotorMoveToOutputPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1YAxisMotorMoveToOutputPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMoveToOutputPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{
					//smProductEvent->PickAndPlace1YAxisMotorMoveCurve.Set = false;
				}
				smProductEvent->PickAndPlace1YAxisMotorMoveToOutputPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Output Position Pick And Place 1 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1YAxisMotorMoveToOutputPositionCurve.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1YAxisMotorMoveToOutputPositionCurve.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMoveToOutputPositionCurve(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{
					smProductEvent->PickAndPlace1YAxisMotorMoveCurve.Set = false;
				}
				smProductEvent->PickAndPlace1YAxisMotorMoveToOutputPositionCurveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Output Position Curve Pick And Place 1 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1YAxisMotorMoveToStandbyPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1YAxisMotorMoveToStandbyPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMoveToStandbyPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1YAxisMotorMoveToStandbyPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Standby Position Pick And Place 1 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Pick And Place 1 Y Axis Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_PICK_AND_PLACE_1_Y_AXIS_MOTOR_END.Set = true;

	return nError;
}

ULONG CProductThread::InputTrayTableXAxisMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Input Tray Table X Axis thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartInputTrayTableXAxisMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableXAxisMotorHome.Set = false;
			nError = m_cProductMotorControl->InputTrayTableXAxisMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->InputTrayTableXAxisMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home Input Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputTrayTableXAxisMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableXAxisMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->InputTrayTableXAxisMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Input Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputTrayTableXAxisMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableXAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->InputTrayTableXAxisMotorMove(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->InputTrayTableXAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Input Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputTrayTableXAxisMotorMoveLoad.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableXAxisMotorMoveLoad.Set = false;
			nError = m_cProductMotorControl->InputTrayTableXAxisMotorMoveLoad(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->InputTrayTableXAxisMotorMoveLoadDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Load Input Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputTrayTableXAxisMotorMoveUnload.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableXAxisMotorMoveUnload.Set = false;
			nError = m_cProductMotorControl->InputTrayTableXAxisMotorMoveUnload(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->InputTrayTableXAxisMotorMoveUnloadDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move unload Input Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputTrayTableXAxisMotorMoveCenter.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableXAxisMotorMoveCenter.Set = false;
			nError = m_cProductMotorControl->InputTrayTableXAxisMotorMoveCenter(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->InputTrayTableXAxisMotorMoveCenterDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move center Input Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Input Tray Table X Axis Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_INPUT_TRAY_TABLE_X_AXIS_MOTOR_END.Set = true;
	return nError;
}

ULONG CProductThread::InputTrayTableYAxisMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Input Tray Table Y Axis thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartInputTrayTableYAxisMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableYAxisMotorHome.Set = false;
			nError = m_cProductMotorControl->InputTrayTableYAxisMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->InputTrayTableYAxisMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home Input Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputTrayTableYAxisMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableYAxisMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->InputTrayTableYAxisMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Input Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputTrayTableYAxisMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableYAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->InputTrayTableYAxisMotorMove(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->InputTrayTableYAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("UPH: move Input Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);

			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Input Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputTrayTableYAxisMotorMoveLoad.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableYAxisMotorMoveLoad.Set = false;
			nError = m_cProductMotorControl->InputTrayTableYAxisMotorMoveLoad(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->InputTrayTableYAxisMotorMoveLoadDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Load Input Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputTrayTableYAxisMotorMoveUnload.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableYAxisMotorMoveUnload.Set = false;
			nError = m_cProductMotorControl->InputTrayTableYAxisMotorMoveUnload(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->InputTrayTableYAxisMotorMoveUnloadDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move unload Input Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputTrayTableYAxisMotorMoveCenter.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableYAxisMotorMoveCenter.Set = false;
			nError = m_cProductMotorControl->InputTrayTableYAxisMotorMoveCenter(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->InputTrayTableYAxisMotorMoveCenterDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move center Input Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}

		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Input Tray Table Y Axis Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_INPUT_TRAY_TABLE_Y_AXIS_MOTOR_END.Set = true;

	return nError;
}

ULONG CProductThread::InputTrayTableZAxisMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Input Tray Table Z Axis thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartInputTrayTableZAxisMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableZAxisMotorHome.Set = false;
			nError = m_cProductMotorControl->InputTrayTableZAxisMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->InputTrayTableZAxisMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home Input Tray Table Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputTrayTableZAxisMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableZAxisMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->InputTrayTableZAxisMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Input Tray Table Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputTrayTableZAxisMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableZAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->InputTrayTableZAxisMotorMove(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->InputTrayTableZAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Input Tray Table Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputTrayTableZAxisMotorMoveDown.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableZAxisMotorMoveDown.Set = false;
			nError = m_cProductMotorControl->InputTrayTableZAxisMotorMoveDown(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Down Input Tray Table Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputTrayTableZAxisMotorMoveLoad.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableZAxisMotorMoveLoad.Set = false;
			nError = m_cProductMotorControl->InputTrayTableZAxisMotorMoveLoad(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->InputTrayTableZAxisMotorMoveLoadDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move load Input Tray Table Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputTrayTableZAxisMotorMoveSingulation.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableZAxisMotorMoveSingulation.Set = false;
			nError = m_cProductMotorControl->InputTrayTableZAxisMotorMoveSingulation(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Singulation Position Input Tray Table Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputTrayTableZAxisMotorMoveUnload.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableZAxisMotorMoveUnload.Set = false;
			nError = m_cProductMotorControl->InputTrayTableZAxisMotorMoveUnload(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->InputTrayTableZAxisMotorMoveUnloadDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move unload Input Tray Table Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Input Tray Table Z Axis Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_INPUT_TRAY_TABLE_Z_AXIS_MOTOR_END.Set = true;

	return nError;
}

ULONG CProductThread::PickAndPlace2YAxisMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Pick And Place 2 Y Axis thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartPickAndPlace2YAxisMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2YAxisMotorHome.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2YAxisMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home Pick And Place 2 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2YAxisMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2YAxisMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick And Place 2 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2YAxisMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2YAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMove(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2YAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Pick And Place 2 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2YAxisMotorMoveCurve.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2YAxisMotorMoveCurve.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMoveCurve(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{
					smProductEvent->PickAndPlace2YAxisMotorMoveCurve.Set = false;
				}
				smProductEvent->PickAndPlace2YAxisMotorMoveCurveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Pick And Place 2 Y Axis Curve Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2YAxisMotorMoveToInputPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2YAxisMotorMoveToInputPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMoveToInputPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{
					//smProductEvent->PickAndPlace2YAxisMotorMoveCurve.Set = false;
				}
				smProductEvent->PickAndPlace2YAxisMotorMoveToInputPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Input Position Pick And Place 2 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2YAxisMotorMoveToInputPositionCurve.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2YAxisMotorMoveToInputPositionCurve.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMoveToInputPositionCurve(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{
					smProductEvent->PickAndPlace2YAxisMotorMoveCurve.Set = false;
				}
				smProductEvent->PickAndPlace2YAxisMotorMoveToInputPositionCurveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Input Position Pick And Place 2 Y Axis Curve Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2YAxisMotorMoveToS1Position.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2YAxisMotorMoveToS1Position.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMoveToS1Position(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2YAxisMotorMoveToS1PositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move S1 Pick And Place 2 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2YAxisMotorMoveToS3Position.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2YAxisMotorMoveToS3Position.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMoveToS3Position(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2YAxisMotorMoveToS3PositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move S3 Position Pick And Place 2 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2YAxisMotorMoveToOutputPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2YAxisMotorMoveToOutputPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMoveToOutputPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{
					//smProductEvent->PickAndPlace2YAxisMotorMoveCurve.Set = false;
				}
				smProductEvent->PickAndPlace2YAxisMotorMoveToOutputPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Output Position Pick And Place 2 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2YAxisMotorMoveToOutputPositionCurve.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2YAxisMotorMoveToOutputPositionCurve.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMoveToOutputPositionCurve(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{
					smProductEvent->PickAndPlace2YAxisMotorMoveCurve.Set = false;
				}
				smProductEvent->PickAndPlace2YAxisMotorMoveToOutputPositionCurveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Output Curve Position Pick And Place 2 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2YAxisMotorMoveToStandbyPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2YAxisMotorMoveToStandbyPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMoveToStandbyPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2YAxisMotorMoveToStandbyPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move standvby Pick And Place 2 Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Pick And Place 2 Y Axis Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_PICK_AND_PLACE_2_Y_AXIS_MOTOR_END.Set = true;

	return nError;
}

ULONG CProductThread::OutputTrayTableXAxisMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Output Tray Table X Axis thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartOutputTrayTableXAxisMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableXAxisMotorHome.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableXAxisMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->OutputTrayTableXAxisMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home Output Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableXAxisMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableXAxisMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableXAxisMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Output Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableXAxisMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableXAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableXAxisMotorMove(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Output Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableXAxisMotorMoveLoad.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableXAxisMotorMoveLoad.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableXAxisMotorMoveLoad(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->OutputTrayTableXAxisMotorMoveLoadDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Load Output Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableXAxisMotorMoveUnload.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableXAxisMotorMoveUnload.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableXAxisMotorMoveUnload(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->OutputTrayTableXAxisMotorMoveUnloadDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move unload Output Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableXAxisMotorMoveCenter.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableXAxisMotorMoveCenter.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableXAxisMotorMoveCenter(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->OutputTrayTableXAxisMotorMoveCenterDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Center Output Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableXAxisMotorMoveRejectTrayCenter.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableXAxisMotorMoveRejectTrayCenter.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableXAxisMotorMoveRejectTrayCenter(cMotion, 0);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->OutputTrayTableXAxisMotorMoveRejectTrayCenterDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move reject tray WCenter Output Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableXAxisMotorMoveManualLoadUnload.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableXAxisMotorMoveManualLoadUnload.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableXAxisMotorMoveManualLoadUnload(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->OutputTrayTableXAxisMotorMoveManualLoadUnloadDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move manual load unload Output Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}

		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Output Tray Table X Axis Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_OUTPUT_TRAY_TABLE_X_AXIS_MOTOR_END.Set = true;

	return nError;
}

ULONG CProductThread::OutputTrayTableYAxisMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Output Tray Table Y Axis thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartOutputTrayTableYAxisMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableYAxisMotorHome.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableYAxisMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->OutputTrayTableYAxisMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home Output Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableYAxisMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableYAxisMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableYAxisMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Output Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableYAxisMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableYAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableYAxisMotorMove(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Output Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableYAxisMotorMoveLoad.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableYAxisMotorMoveLoad.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableYAxisMotorMoveLoad(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->OutputTrayTableYAxisMotorMoveLoadDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move load Output Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableYAxisMotorMoveUnload.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableYAxisMotorMoveUnload.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableYAxisMotorMoveUnload(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->OutputTrayTableYAxisMotorMoveUnloadDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move unload Output Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableYAxisMotorMoveCenter.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableYAxisMotorMoveCenter.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableYAxisMotorMoveCenter(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->OutputTrayTableYAxisMotorMoveCenterDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move center Output Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableYAxisMotorMoveRejectTrayCenter.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableYAxisMotorMoveRejectTrayCenter.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableYAxisMotorMoveRejectTrayCenter(cMotion, 0);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->OutputTrayTableYAxisMotorMoveRejectTrayCenterDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move reject tray center Output Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableYAxisMotorMoveManualLoadUnload.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableYAxisMotorMoveManualLoadUnload.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableYAxisMotorMoveManualLoadUnload(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->OutputTrayTableYAxisMotorMoveManualLoadUnloadDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move manual load unload Output Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}

		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Output Tray Table Y Axis Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_OUTPUT_TRAY_TABLE_Y_AXIS_MOTOR_END.Set = true;

	return nError;
}

ULONG CProductThread::OutputTrayTableZAxisMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Output Tray Table Z Axis thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartOutputTrayTableZAxisMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableZAxisMotorHome.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableZAxisMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->OutputTrayTableZAxisMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home Output Tray Table Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableZAxisMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableZAxisMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableZAxisMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Output Tray Table Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableZAxisMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableZAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableZAxisMotorMove(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->OutputTrayTableZAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Output Tray Table Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableZAxisMotorMoveDown.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableZAxisMotorMoveDown.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableZAxisMotorMoveDown(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Down Output Tray Table Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableZAxisMotorMoveLoad.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableZAxisMotorMoveLoad.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableZAxisMotorMoveLoad(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->OutputTrayTableZAxisMotorMoveLoadDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move load Output Tray Table Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableZAxisMotorMoveSingulation.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableZAxisMotorMoveSingulation.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableZAxisMotorMoveSingulation(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Singulation Output Tray Table Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartOutputTrayTableZAxisMotorMoveUnload.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableZAxisMotorMoveUnload.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableZAxisMotorMoveUnload(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->OutputTrayTableZAxisMotorMoveUnloadDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move unload Output Tray Table Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Output Tray Table Z Axis Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_OUTPUT_TRAY_TABLE_Z_AXIS_MOTOR_END.Set = true;

	return nError;
}

ULONG CProductThread::InputVisionModuleMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Input Vision Module thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartInputVisionModuleMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputVisionModuleMotorHome.Set = false;
			nError = m_cProductMotorControl->InputVisionModuleMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->InputVisionModuleMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home Input Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputVisionModuleMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputVisionModuleMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->InputVisionModuleMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->InputVisionModuleMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Input Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputVisionModuleMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputVisionModuleMotorMove.Set = false;
			nError = m_cProductMotorControl->InputVisionModuleMotorMove(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->InputVisionModuleMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Input Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartInputVisionModuleMotorMoveFocusPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputVisionModuleMotorMoveFocusPosition.Set = false;
			nError = m_cProductMotorControl->InputVisionModuleMotorMoveFocusPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->InputVisionModuleMotorMoveFocusPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move focus position Input Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}

		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Input Vision Module Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_INPUT_VISION_MODULE_MOTOR_END.Set = true;

	return nError;
}

ULONG CProductThread::S2VisionModuleMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("S2 Vision Module thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartS2VisionModuleMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS2VisionModuleMotorHome.Set = false;
			nError = m_cProductMotorControl->S2VisionModuleMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->S2VisionModuleMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home S2 Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartS2VisionModuleMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS2VisionModuleMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->S2VisionModuleMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->S2VisionModuleMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up S2 Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartS2VisionModuleMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS2VisionModuleMotorMove.Set = false;
			nError = m_cProductMotorControl->S2VisionModuleMotorMove(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->S2VisionModuleMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move S2 Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartS2VisionModuleMotorMoveFocusPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS2VisionModuleMotorMoveFocusPosition.Set = false;
			nError = m_cProductMotorControl->S2VisionModuleMotorMoveFocusPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->S2VisionModuleMotorMoveFocusPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move focus position S2 Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}

		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("S2 Vision Module Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_S2_VISION_MODULE_MOTOR_END.Set = true;

	return nError;
}

ULONG CProductThread::S1VisionModuleMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("S1 Vision Module thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartS1VisionModuleMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS1VisionModuleMotorHome.Set = false;
			nError = m_cProductMotorControl->S1VisionModuleMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->S1VisionModuleMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home Side Wall Vision Left Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartS1VisionModuleMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS1VisionModuleMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->S1VisionModuleMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->S1VisionModuleMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Side Wall Vision Left Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartS1VisionModuleMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS1VisionModuleMotorMove.Set = false;
			nError = m_cProductMotorControl->S1VisionModuleMotorMove(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->S1VisionModuleMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Side Wall Vision Left Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartS1VisionModuleMotorMoveFocusPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS1VisionModuleMotorMoveFocusPosition.Set = false;
			nError = m_cProductMotorControl->S1VisionModuleMotorMoveFocusPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->S1VisionModuleMotorMoveFocusPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Reference Focus Position Side Wall Vision Left Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Side Wall Vision Left Module Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_SIDE_WALL_VISION_LEFT_MODULE_MOTOR_END.Set = true;

	return nError;
}

ULONG CProductThread::S3VisionModuleMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("S3 Vision Module thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartS3VisionModuleMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS3VisionModuleMotorHome.Set = false;
			nError = m_cProductMotorControl->S3VisionModuleMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->S3VisionModuleMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home S3 Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartS3VisionModuleMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS3VisionModuleMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->S3VisionModuleMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->S3VisionModuleMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up S3 Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartS3VisionModuleMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS3VisionModuleMotorMove.Set = false;
			nError = m_cProductMotorControl->S3VisionModuleMotorMove(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->S3VisionModuleMotorMoveDone.Set = true;
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("UPH: S3 Vision Module Motor Test %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move S3 Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartS3VisionModuleMotorMoveFocusPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS3VisionModuleMotorMoveFocusPosition.Set = false;
			nError = m_cProductMotorControl->S3VisionModuleMotorMoveFocusPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->S3VisionModuleMotorMoveFocusPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move focus position S3 Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("S3 Vision Module Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_S3_VISION_MODULE_MOTOR_END.Set = true;

	return nError;
}

ULONG CProductThread::PickAndPlace1XAxisMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Pick And Place 1 X Axis thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartPickAndPlace1XAxisMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1XAxisMotorHome.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1XAxisMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1XAxisMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home Pick And Place 1 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1XAxisMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1XAxisMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1XAxisMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick And Place 1 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1XAxisMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1XAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1XAxisMotorMove(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1XAxisMotorMoveDone.Set = true;
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("UPH: Pick And Place 1 X Axis Motor Test %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Pick And Place 1 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1XAxisMotorMoveToInputPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1XAxisMotorMoveToInputPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1XAxisMotorMoveToInputPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1XAxisMotorMoveToInputPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Input Position Pick And Place 1 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1XAxisMotorMoveToS1Position.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1XAxisMotorMoveToS1Position.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1XAxisMotorMoveToS1Position(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1XAxisMotorMoveToS1PositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move S1 Position Pick And Place 1 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1XAxisMotorMoveToS3Position.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1XAxisMotorMoveToS3Position.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1XAxisMotorMoveToS3Position(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1XAxisMotorMoveToS3PositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move S3 Position Pick And Place 1 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1XAxisMotorMoveToOutputPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1XAxisMotorMoveToOutputPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1XAxisMotorMoveToOutputPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1XAxisMotorMoveToOutputPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Output Position Pick And Place 1 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1XAxisMotorMoveToParkingPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1XAxisMotorMoveToParkingPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1XAxisMotorMoveToParkingPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1XAxisMotorMoveToParkingPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Parking Position Pick And Place 1 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1XAxisMotorEnableTriggerPoint.Set == true)
		{
			m_cLogger->WriteLog("Start Set Trigerring End Start for Pick And Place X Axis Motor.\n");
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1XAxisMotorEnableTriggerPoint.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1XAxisMotorEnablePositionTrigger(cMotion);

			if (nError == 0)
			{
				smProductEvent->PickAndPlace1XAxisMotorEnableTriggerPointDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Set Enable Trigger for Pick And Place 1 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}

		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Pick And Place 1 X Axis Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_PICK_AND_PLACE_1_X_AXIS_MOTOR_END.Set = true;

	return nError;
}

ULONG CProductThread::PickAndPlace2XAxisMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Pick And Place 2 X Axis thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartPickAndPlace2XAxisMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2XAxisMotorHome.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2XAxisMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2XAxisMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home Pick And Place 2 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2XAxisMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2XAxisMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2XAxisMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick And Place 2 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2XAxisMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2XAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2XAxisMotorMove(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2XAxisMotorMoveDone.Set = true;
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("UPH: Pick And Place 2 X Axis Motor Test %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Pick And Place 2 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2XAxisMotorMoveToInputPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2XAxisMotorMoveToInputPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2XAxisMotorMoveToInputPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2XAxisMotorMoveToInputPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Input Position Pick And Place 2 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2XAxisMotorMoveToS1Position.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2XAxisMotorMoveToS1Position.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2XAxisMotorMoveToS1Position(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2XAxisMotorMoveToS1PositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move S1 Pick And Place 2 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2XAxisMotorMoveToS3Position.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2XAxisMotorMoveToS3Position.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2XAxisMotorMoveToS3Position(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2XAxisMotorMoveToS3PositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move S3 Position Pick And Place 2 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2XAxisMotorMoveToOutputPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2XAxisMotorMoveToOutputPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2XAxisMotorMoveToOutputPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2XAxisMotorMoveToOutputPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Output Position Pick And Place 2 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2XAxisMotorMoveToParkingPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2XAxisMotorMoveToParkingPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2XAxisMotorMoveToParkingPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2XAxisMotorMoveToParkingPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Parking Position Pick And Place 2 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2XAxisMotorEnableTriggerPoint.Set == true)
		{
			m_cLogger->WriteLog("Start Set Trigerring End Start for Pick And Place X Axis Motor.\n");
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2XAxisMotorEnableTriggerPoint.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2XAxisMotorEnablePositionTrigger(cMotion);

			if (nError == 0)
			{
				smProductEvent->PickAndPlace2XAxisMotorEnableTriggerPointDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Set Enable Trigger for Pick And Place 2 X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Pick And Place 2 X Axis Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_PICK_AND_PLACE_2_X_AXIS_MOTOR_END.Set = true;

	return nError;
}

ULONG CProductThread::PickAndPlace1ZAxisMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnDelayIn100ns;
	LONGLONG  lConvert1msTo100ns = 10000;
	m_cLogger->WriteLog("Pick And Place 1 Z Axis thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartPickAndPlace1ZAxisMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisMotorHome.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1ZAxisMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisMotorMove.Set = false;
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue1(0, (signed long)smProductProduction->PickAndPlace1ZAxisMovePosition);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Rotation Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}

			nError = m_cProductMotorControl->THKMoveUpSequence(0);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1ZAxisMotorMoveDone.Set = true;
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("UPH: Pick And Place 1 Z Axis Motor Test %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisMotorMoveUpPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisMotorMoveUpPosition.Set = false;
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue1(0, (signed long)(smProductTeachPoint->PickAndPlace1ZAxisUpPosition + signed long(smProductSetting->UnitThickness_um)));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Rotation Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}

			nError = m_cProductMotorControl->THKMoveUpSequence(0);
			//nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveUpPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1ZAxisMotorMoveUpPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Up Position Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisMotorMoveToInputTrayDownPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisMotorMoveToInputTrayDownPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveInputDownPosition(cMotion, true);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1ZAxisMotorMoveToInputTrayDownPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move to Input tray down position Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisMotorMoveToOutputTrayDownPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisMotorMoveToOutputTrayDownPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveOutputDownPosition(cMotion, true);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1ZAxisMotorMoveToOutputTrayDownPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move to Output Tray Down Position Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisMotorMoveUpPositionAndRotate.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisMotorMoveUpPositionAndRotate.Set = false;

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

			nError = m_cProductMotorControl->THKSetTargetValue2(0, (signed long)smProductProduction->PickAndPlace1ZAxisMovePosition);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Up Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Force to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Force, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue7(0, (signed long)smProductProduction->PickAndPlace1ThetaAxisMovePosition);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Rotation Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			
			nError = m_cProductMotorControl->THKMoveUpWithRotationSequence(0);
			//nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveInputDownPosition(cMotion, false);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1ZAxisMotorMoveUpPositionAndRotateDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move to Input tray Softlanding position Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisMotorMoveToInputTraySoftlandingPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisMotorMoveToInputTraySoftlandingPosition.Set = false;

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

			nError = m_cProductMotorControl->THKSetTargetValue1(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtInputTrayTouchingPosition
				- (signed long)smProductSetting->InputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um
				+ (signed long)smProductSetting->PickingGap_um + (signed long)smProductSetting->Picking1SoftlandingDistance_um);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Softlanding Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Force to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Force, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue2(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtInputTrayTouchingPosition
				- (signed long)smProductSetting->InputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PickingGap_um);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Picking Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue4(0, (double)smProductSetting->PickUpHead1Force);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Force Target %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Done setting up Pick Up 1 Force Target to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Force, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//	- (signed long)smProductSetting->PocketDepthJedec_um + (signed long)smProductSetting->UnitThickness_um
				//	+ (signed long)smProductSetting->PickingGapAtInputJedecTray_um + (signed long)smProductSetting->PickingSoftlandingDistanceAtInputJedecTray_um), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue6(0, (signed long)smProductSetting->PickUpHead1Pressure);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Pressure Value %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Down Position Before Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue8(0, (signed long)((double)((double)smProductSetting->PickingSoftlandingSpeed_percent / 100.0) * (double)500));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Softlanding Speed %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Down Position With Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue10(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOn_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position Before Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Picking to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPickingAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue11(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOn_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position With Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue12(0, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPicking_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Picking %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			
			
			nError = m_cProductMotorControl->THKSoftlandingPick(0);
			//nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveInputDownPosition(cMotion, false);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1ZAxisMotorMoveToInputTraySoftlandingPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move to Input tray Softlanding position Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisMotorMoveToOutputTraySoftlandingPositionForPicking.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisMotorMoveToOutputTraySoftlandingPositionForPicking.Set = false;

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

			nError = m_cProductMotorControl->THKSetTargetValue1(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtOutputTrayTouchingPosition
				- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um
				+ (signed long)smProductSetting->PickingGap_um_Output + (signed long)smProductSetting->PickingSoftlandingDistance_um_Output);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Softlanding Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Force to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Force, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue2(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtOutputTrayTouchingPosition
				- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PickingGap_um_Output);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Picking Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue4(0, (double)smProductSetting->PickUpHead1Force);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Force Target %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Down Position to %lf in %ums.\n", (double)((signed long)smProductTeachPoint->PickAndPlacePickupHead1ZAxisAtInputJedecTrayTouchingPosition
				//	- (signed long)smProductSetting->PocketDepthJedec_um + (signed long)smProductSetting->UnitThickness_um
				//	+ (signed long)smProductSetting->PickingGapAtInputJedecTray_um + (signed long)smProductSetting->PickingSoftlandingDistanceAtInputJedecTray_um), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue6(0, (signed long)smProductSetting->PickUpHead1Pressure);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Pressure Value %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Down Position Before Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue8(0, (signed long)((double)((double)smProductSetting->PickingSoftlandingSpeed_percent_Output / 100.0) * (double)500));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Softlanding Speed %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Down Position With Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue10(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOn_ms_Output);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position Before Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Picking to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPickingAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue11(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOn_ms_Output);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position With Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue12(0, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPicking_ms_Output);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Picking %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}

			nError = m_cProductMotorControl->THKSoftlandingPick(0);
			//nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveInputDownPosition(cMotion, false);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1ZAxisMotorMoveToOutputTraySoftlandingPositionForPickingDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move to Output tray Softlanding position for picking Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisMotorMoveToOutputTraySoftlandingPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisMotorMoveToOutputTraySoftlandingPosition.Set = false;
			//nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveOutputDownPosition(cMotion, false);
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue1(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtOutputTrayTouchingPosition
				- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um
				+ (signed long)smProductSetting->PlacementGap_um + (signed long)smProductSetting->PlacementSoftlandingDistance_um);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Place Softlanding Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Force to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Force, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue3(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtOutputTrayTouchingPosition
				- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PlacementGap_um);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Placement Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue5(0, (double)smProductSetting->PickUpHead1PlaceForce);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Place Force Target %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Down Position to %lf in %ums.\n", (double)((signed long)smProductTeachPoint->PickAndPlacePickupHead1ZAxisAtInputJedecTrayTouchingPosition
				//	- (signed long)smProductSetting->PocketDepthJedec_um + (signed long)smProductSetting->UnitThickness_um
				//	+ (signed long)smProductSetting->PickingGapAtInputJedecTray_um + (signed long)smProductSetting->PickingSoftlandingDistanceAtInputJedecTray_um), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue6(0, (signed long)smProductSetting->PickUpHead1PlacePressure);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Place Pressure Value %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Down Position Before Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue9(0, (signed long)((double)((double)smProductSetting->PlacementSoftlandingSpeed_percent / 100.0) * (double)500));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Place Softlanding Speed %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Down Position With Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue10(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforePurging_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position Before Purging %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Picking to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPickingAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue11(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithPurging_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position With Purging %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue12(0, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPlacement_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Placement %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			if (smProductSetting->EnablePlaceSoftlanding == true)
			{
				nError = m_cProductMotorControl->THKSoftlandingPlace(0);
			}
			else
			{
				nError = m_cProductMotorControl->THKPlace(0);
			}
			if (nError == 0)
			{
				lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayForPickupHeadAtDownPositionAfterPurging_ms;
				RtSleepFt(&lnDelayIn100ns);
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1ZAxisMotorMoveToOutputTraySoftlandingPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move to Output Tray Softlanding Position Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisReleaseAndOffValve.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisReleaseAndOffValve.Set = false;
			nError = m_cProductMotorControl->THKReleaseValveOn(0);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Release Valve Pick And Place 1 THK Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayForPickupHeadAtDownPositionWithPurgingAtInput_ms;
			RtSleepFt(&lnDelayIn100ns);
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Pick And Place 1 THK Motor Delay %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			nError += m_cProductMotorControl->THKReleaseValveOff(0);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1ZAxisReleaseAndOffValveDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Pickup Head 1 Release and off Valve %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisMotorSoftlandingPickS1AndS3Ceramic.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisMotorSoftlandingPickS1AndS3Ceramic.Set = false;

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

			nError = m_cProductMotorControl->THKSetTargetValue1(0, (signed long)-11000);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Softlanding Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Force to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Force, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue2(0, (signed long)-15000);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Picking Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue4(0, (double)0.3);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Force Target %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Down Position to %lf in %ums.\n", (double)((signed long)smProductTeachPoint->PickAndPlacePickupHead1ZAxisAtInputJedecTrayTouchingPosition
				//	- (signed long)smProductSetting->PocketDepthJedec_um + (signed long)smProductSetting->UnitThickness_um
				//	+ (signed long)smProductSetting->PickingGapAtInputJedecTray_um + (signed long)smProductSetting->PickingSoftlandingDistanceAtInputJedecTray_um), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue6(0, (signed long)-40);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Pressure Value %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Down Position Before Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue8(0, (signed long)((double)((double)5/ 100.0) * (double)500));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Softlanding Speed %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Down Position With Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue10(0, (signed long)0);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position Before Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Picking to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPickingAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue11(0, (signed long)2000);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position With Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue12(0, (signed long)0);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Picking %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}


			nError = m_cProductMotorControl->THKSoftlandingPick(0);
			//nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveInputDownPosition(cMotion, false);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1ZAxisMotorSoftlandingPickS1AndS3CeramicDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Pick S1 or S3 Ceramic Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisMotorSoftlandingPlaceS1AndS3Ceramic.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisMotorSoftlandingPlaceS1AndS3Ceramic.Set = false;
			//nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveOutputDownPosition(cMotion, false);
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue1(0, (signed long)-11000);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Place Softlanding Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Force to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Force, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue3(0, (signed long)-15000);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Placement Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue5(0, (double)0.2);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Place Force Target %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Down Position to %lf in %ums.\n", (double)((signed long)smProductTeachPoint->PickAndPlacePickupHead1ZAxisAtInputJedecTrayTouchingPosition
				//	- (signed long)smProductSetting->PocketDepthJedec_um + (signed long)smProductSetting->UnitThickness_um
				//	+ (signed long)smProductSetting->PickingGapAtInputJedecTray_um + (signed long)smProductSetting->PickingSoftlandingDistanceAtInputJedecTray_um), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue6(0, (signed long)-70);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Place Pressure Value %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Down Position Before Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue9(0, (signed long)((double)((double)5 / 100.0) * (double)500));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Place Softlanding Speed %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Down Position With Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue10(0, (signed long)2000);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position Before Purging %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Picking to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPickingAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue11(0, (signed long)2000);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position With Purging %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue12(0, (signed long)0);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Placement %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSoftlandingPlace(0);
			if (nError == 0)
			{
				lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)3000;
				RtSleepFt(&lnDelayIn100ns);
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1ZAxisMotorSoftlandingPlaceS1AndS3CeramicDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Place S1 or S3 ceramic Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisMotorSoftlandingPickSWCeramic.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisMotorSoftlandingPickSWCeramic.Set = false;

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

			nError = m_cProductMotorControl->THKSetTargetValue1(0, (signed long)-11000);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Softlanding Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Force to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Force, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue2(0, (signed long)-15000);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Picking Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue4(0, (double)0.3);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Force Target %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Down Position to %lf in %ums.\n", (double)((signed long)smProductTeachPoint->PickAndPlacePickupHead1ZAxisAtInputJedecTrayTouchingPosition
				//	- (signed long)smProductSetting->PocketDepthJedec_um + (signed long)smProductSetting->UnitThickness_um
				//	+ (signed long)smProductSetting->PickingGapAtInputJedecTray_um + (signed long)smProductSetting->PickingSoftlandingDistanceAtInputJedecTray_um), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue6(0, (signed long)-40);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Pressure Value %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Down Position Before Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue8(0, (signed long)((double)((double)5 / 100.0) * (double)500));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Softlanding Speed %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Down Position With Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue10(0, (signed long)0);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position Before Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Picking to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPickingAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue11(0, (signed long)2000);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position With Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue12(0, (signed long)0);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Picking %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}


			nError = m_cProductMotorControl->THKSoftlandingPick(0);
			//nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveInputDownPosition(cMotion, false);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1ZAxisMotorSoftlandingPickSWCeramicDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Pick SW or Setup Ceramic Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisMotorSoftlandingPlaceSWCeramic.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisMotorSoftlandingPlaceSWCeramic.Set = false;
			//nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveOutputDownPosition(cMotion, false);
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue1(0, (signed long)-11000);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Place Softlanding Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Force to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Force, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue3(0, (signed long)-15000);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Placement Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue5(0, (double)0.2);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Place Force Target %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Down Position to %lf in %ums.\n", (double)((signed long)smProductTeachPoint->PickAndPlacePickupHead1ZAxisAtInputJedecTrayTouchingPosition
				//	- (signed long)smProductSetting->PocketDepthJedec_um + (signed long)smProductSetting->UnitThickness_um
				//	+ (signed long)smProductSetting->PickingGapAtInputJedecTray_um + (signed long)smProductSetting->PickingSoftlandingDistanceAtInputJedecTray_um), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue6(0, (signed long)-70);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Place Pressure Value %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Down Position Before Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue9(0, (signed long)((double)((double)5 / 100.0) * (double)500));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Place Softlanding Speed %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Down Position With Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue10(0, (signed long)1000);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position Before Purging %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Picking to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPickingAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue11(0, (signed long)1000);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position With Purging %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue12(0, (signed long)0);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Placement %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSoftlandingPlace(0);
			if (nError == 0)
			{
				lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)3000;
				RtSleepFt(&lnDelayIn100ns);
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1ZAxisMotorSoftlandingPlaceSWCeramicDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Place S1 or S3 ceramic Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisOffVacuum.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisOffVacuum.Set = false;
			nError = m_cProductMotorControl->THKVacuumValveOff(0);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1ZAxisOffVacuumDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Pickup Head 1 Off Vacuum %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisOnValve.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisOnValve.Set = false;
			nError = m_cProductMotorControl->THKReleaseValveOn(0);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1ZAxisOnValveDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Pickup Head 1 On Valve %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ZAxisOffValve.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ZAxisOffValve.Set = false;
			nError = m_cProductMotorControl->THKReleaseValveOff(0);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1ZAxisOffValveDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Pickup Head 1 Off Valve %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Pick And Place 1 Z Axis Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_PICK_AND_PLACE_1_Z_AXIS_MOTOR_END.Set = true;

	return nError;
}

ULONG CProductThread::PickAndPlace2ZAxisMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnDelayIn100ns;
	LONGLONG  lConvert1msTo100ns = 10000;
	m_cLogger->WriteLog("Pick And Place 2 Z Axis thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartPickAndPlace2ZAxisMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ZAxisMotorHome.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2ZAxisMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home Pick And Place 2 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ZAxisMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ZAxisMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick And Place 2 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ZAxisMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ZAxisMotorMove.Set = false;
			if (smProductProduction->PickAndPlace2ZAxisMovePosition > smProductTeachPoint->PickAndPlace2ZAxisForwardLimitPosition ||
				smProductProduction->PickAndPlace2ZAxisMovePosition < smProductTeachPoint->PickAndPlace2ZAxisReverseLimitPosition)
			{
				sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 Z Limit\n");
				m_cProductShareVariables->triggerUpdateMessage();
				m_cLogger->WriteLog("Position is out of Pick And Place 2 Z Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
			nError = m_cProductMotorControl->THKSetTargetValue1(1, (signed long)smProductProduction->PickAndPlace2ZAxisMovePosition);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Z Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}

			nError = m_cProductMotorControl->THKMoveUpSequence(1);
			//nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorMove(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2ZAxisMotorMoveDone.Set = true;
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("UPH: Pick And Place 2 Z Axis Motor Test %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Pick And Place 2 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ZAxisMotorMoveUpPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ZAxisMotorMoveUpPosition.Set = false;
			nError = m_cProductMotorControl->THKSetTargetValue1(1, (signed long)(smProductTeachPoint->PickAndPlace2ZAxisUpPosition + signed long(smProductSetting->UnitThickness_um)));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Z Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}

			nError = m_cProductMotorControl->THKMoveUpSequence(1);
			//nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorMoveUpPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2ZAxisMotorMoveUpPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Up Position Pick And Place 2 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ZAxisMotorMoveToInputTrayDownPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ZAxisMotorMoveToInputTrayDownPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorMoveInputDownPosition(cMotion, true);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2ZAxisMotorMoveToInputTrayDownPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move to Input tray down position Pick And Place 2 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ZAxisMotorMoveToOutputTrayDownPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ZAxisMotorMoveToOutputTrayDownPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorMoveOutputDownPosition(cMotion, true);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2ZAxisMotorMoveToOutputTrayDownPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move to Output Tray Down Position Pick And Place 2 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ZAxisMotorMoveToInputTraySoftlandingPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ZAxisMotorMoveToInputTraySoftlandingPosition.Set = false;
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

			nError = m_cProductMotorControl->THKSetTargetValue1(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtInputTrayTouchingPosition
				- (signed long)smProductSetting->InputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um
				+ (signed long)smProductSetting->PickingGap_um + (signed long)smProductSetting->Picking2SoftlandingDistance_um);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Softlanding Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Force to %lf in %ums.\n", (double)smProductSetting->PickUpHead2Force, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue2(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtInputTrayTouchingPosition
				- (signed long)smProductSetting->InputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PickingGap_um);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Picking Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead2Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue4(1, (double)smProductSetting->PickUpHead2Force);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Force Target %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Done setting up Pick Up 2 Force Target to %lf in %ums.\n", (double)smProductSetting->PickUpHead2Force, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Down Position to %lf in %ums.\n", (double)((signed long)smProductTeachPoint->PickAndPlacePickUpHead2ZAxisAtInputJedecTrayTouchingPosition
				//	- (signed long)smProductSetting->PocketDepthJedec_um + (signed long)smProductSetting->UnitThickness_um
				//	+ (signed long)smProductSetting->PickingGapAtInputJedecTray_um + (signed long)smProductSetting->PickingSoftlandingDistanceAtInputJedecTray_um), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue6(1, (signed long)smProductSetting->PickUpHead2Pressure);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Pressure Value %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Delay For Pickup Head At Down Position Before Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue8(1, (signed long)((double)((double)smProductSetting->PickingSoftlandingSpeed_percent / 100.0) * (double)500));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Softlanding Speed %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Delay For Pickup Head At Down Position With Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue10(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOn_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Down Position Before Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Delay For Pickup Head At Softlanding Position For Picking to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPickingAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue11(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOn_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Down Position With Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue12(1, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPicking_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Softlanding Position For Picking %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}


			nError = m_cProductMotorControl->THKSoftlandingPick(1);
			//nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorMoveInputDownPosition(cMotion, false);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2ZAxisMotorMoveToInputTraySoftlandingPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move to Input tray Softlanding position Pick And Place 2 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ZAxisMotorMoveToOutputTraySoftlandingPositionForPicking.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ZAxisMotorMoveToOutputTraySoftlandingPositionForPicking.Set = false;

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

			nError = m_cProductMotorControl->THKSetTargetValue1(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtOutputTrayTouchingPosition
				- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um
				+ (signed long)smProductSetting->PickingGap_um_Output + (signed long)smProductSetting->PickingSoftlandingDistance_um_Output);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Softlanding Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Force to %lf in %ums.\n", (double)smProductSetting->PickUpHead2Force, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue2(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtOutputTrayTouchingPosition
				- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PickingGap_um_Output);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Picking Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead2Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue4(1, (double)smProductSetting->PickUpHead2Force);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Force Target %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Down Position to %lf in %ums.\n", (double)((signed long)smProductTeachPoint->PickAndPlacePickUpHead2ZAxisAtInputJedecTrayTouchingPosition
				//	- (signed long)smProductSetting->PocketDepthJedec_um + (signed long)smProductSetting->UnitThickness_um
				//	+ (signed long)smProductSetting->PickingGapAtInputJedecTray_um + (signed long)smProductSetting->PickingSoftlandingDistanceAtInputJedecTray_um), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue6(1, (signed long)smProductSetting->PickUpHead2Pressure);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Pressure Value %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Delay For Pickup Head At Down Position Before Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue8(1, (signed long)((double)((double)smProductSetting->PickingSoftlandingSpeed_percent_Output / 100.0) * (double)500));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Softlanding Speed %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Delay For Pickup Head At Down Position With Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue10(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOn_ms_Output);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Down Position Before Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Delay For Pickup Head At Softlanding Position For Picking to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPickingAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue11(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOn_ms_Output);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Down Position With Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue12(1, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPicking_ms_Output);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Softlanding Position For Picking %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}


			nError = m_cProductMotorControl->THKSoftlandingPick(1);
			//nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveInputDownPosition(cMotion, false);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2ZAxisMotorMoveToOutputTraySoftlandingPositionForPickingDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move to Output tray Softlanding position for picking Pick And Place 2 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ZAxisMotorMoveToOutputTraySoftlandingPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ZAxisMotorMoveToOutputTraySoftlandingPosition.Set = false;

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue1(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtOutputTrayTouchingPosition
				- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um
				+ (signed long)smProductSetting->PlacementGap_um + (signed long)smProductSetting->PlacementSoftlandingDistance_um);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Place Softlanding Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Force to %lf in %ums.\n", (double)smProductSetting->PickUpHead2Force, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue3(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtOutputTrayTouchingPosition
				- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um 
				+ (signed long)smProductSetting->PlacementGap_um);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Placement Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead2Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue5(1, (double)smProductSetting->PickUpHead2PlaceForce);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Place Force Target %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Down Position to %lf in %ums.\n", (double)((signed long)smProductTeachPoint->PickAndPlacePickUpHead2ZAxisAtInputJedecTrayTouchingPosition
				//	- (signed long)smProductSetting->PocketDepthJedec_um + (signed long)smProductSetting->UnitThickness_um
				//	+ (signed long)smProductSetting->PickingGapAtInputJedecTray_um + (signed long)smProductSetting->PickingSoftlandingDistanceAtInputJedecTray_um), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue6(1, (signed long)smProductSetting->PickUpHead2PlacePressure);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Place Pressure Value %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Delay For Pickup Head At Down Position Before Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue9(1, (signed long)((double)((double)smProductSetting->PlacementSoftlandingSpeed_percent / 100.0) * (double)500));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Place Softlanding Speed %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Delay For Pickup Head At Down Position With Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue10(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforePurging_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Down Position Before Purging %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Delay For Pickup Head At Softlanding Position For Picking to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPickingAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue11(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithPurging_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Down Position With Purging %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue12(1, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPlacement_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Softlanding Position For Placement %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 2 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			if (smProductSetting->EnablePlaceSoftlanding == true)
			{
				nError = m_cProductMotorControl->THKSoftlandingPlace(1);
			}
			else
			{
				nError = m_cProductMotorControl->THKPlace(1);
			}
			//nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorMoveOutputDownPosition(cMotion, false);
			if (nError == 0)
			{
				lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayForPickupHeadAtDownPositionAfterPurging_ms;
				RtSleepFt(&lnDelayIn100ns);
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2ZAxisMotorMoveToOutputTraySoftlandingPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move to Output Tray Softlanding Position Pick And Place 2 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ZAxisMotorMoveUpPositionAndRotate.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ZAxisMotorMoveUpPositionAndRotate.Set = false;

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

			nError = m_cProductMotorControl->THKSetTargetValue2(1, (signed long)smProductProduction->PickAndPlace2ZAxisMovePosition);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Up Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Force to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Force, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue7(1, (signed long)smProductProduction->PickAndPlace2ThetaAxisMovePosition);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Rotation Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}

			nError = m_cProductMotorControl->THKMoveUpWithRotationSequence(1);
			//nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveInputDownPosition(cMotion, false);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2ZAxisMotorMoveUpPositionAndRotateDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move to Input tray Softlanding position Pick And Place 2 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ZAxisReleaseAndOffValve.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ZAxisReleaseAndOffValve.Set = false;
			nError = m_cProductMotorControl->THKReleaseValveOn(1);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Release Valve Pick And Place 2 THK Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayForPickupHeadAtDownPositionWithPurgingAtInput_ms;
			RtSleepFt(&lnDelayIn100ns);
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Pick And Place 2 THK Motor Delay %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			nError += m_cProductMotorControl->THKReleaseValveOff(1);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2ZAxisReleaseAndOffValveDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Pickup Head 2 Release and off Valve %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ZAxisOffVacuum.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ZAxisOffVacuum.Set = false;
			nError = m_cProductMotorControl->THKVacuumValveOff(1);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2ZAxisOffVacuumDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Pickup Head 2 Off Vacuum %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ZAxisOnValve.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ZAxisOnValve.Set = false;
			nError = m_cProductMotorControl->THKReleaseValveOn(1);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2ZAxisOnValveDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Pickup Head 2 On Valve %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ZAxisOffValve.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ZAxisOffValve.Set = false;
			nError = m_cProductMotorControl->THKReleaseValveOff(1);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2ZAxisOffValveDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error Pickup Head 2 Off Valve %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Pick And Place 2 Z Axis Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_PICK_AND_PLACE_2_Z_AXIS_MOTOR_END.Set = true;

	return nError;
}

ULONG CProductThread::PickAndPlace1ThetaAxisMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Pick And Place 1 Theta Axis thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartPickAndPlace1ThetaAxisMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ThetaAxisMotorHome.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1ThetaAxisMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1ThetaAxisMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home Pick And Place 1 Theta Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ThetaAxisMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ThetaAxisMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1ThetaAxisMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick And Place 1 Theta Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ThetaAxisMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ThetaAxisMotorMove.Set = false;
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue7(0, (signed long)smProductProduction->PickAndPlace1ThetaAxisMovePosition);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Rotation Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}

			nError = m_cProductMotorControl->THKRotationSequence(0);
			//nError = m_cProductMotorControl->PickAndPlace1ThetaAxisMotorMove(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1ThetaAxisMotorMoveDone.Set = true;
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("UPH: Pick And Place 1 Theta Axis Motor Test %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Pick And Place 1 Theta Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace1ThetaAxisMotorMoveStandbyPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1ThetaAxisMotorMoveStandbyPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1ThetaAxisMotorMoveStandbyPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace1ThetaAxisMotorMoveStandbyPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move standby Position Pick And Place 1 Theta Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}

		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Pick And Place 1 Theta Axis Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_PICK_AND_PLACE_1_T_AXIS_MOTOR_END.Set = true;

	return nError;
}
ULONG CProductThread::PickAndPlace2ThetaAxisMotorThread(void * nContext)
{
	CMotionLibrary *cMotion = (CMotionLibrary*)nContext;
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Pick And Place 2 Theta Axis thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->StartPickAndPlace2ThetaAxisMotorHome.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ThetaAxisMotorHome.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2ThetaAxisMotorHome(cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2ThetaAxisMotorHomeDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error home Pick And Place 2 Theta Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ThetaAxisMotorSettingUp.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ThetaAxisMotorSettingUp.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2ThetaAxisMotorSettingUp(cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set = true;
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick And Place 2 Theta Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ThetaAxisMotorMove.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ThetaAxisMotorMove.Set = false;
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue7(1, (signed long)smProductProduction->PickAndPlace2ThetaAxisMovePosition);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Rotation Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}

			nError = m_cProductMotorControl->THKRotationSequence(1);
			//nError = m_cProductMotorControl->PickAndPlace2ThetaAxisMotorMove(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2ThetaAxisMotorMoveDone.Set = true;
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("UPH: Pick And Place 2 Theta Axis Motor Test %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move Pick And Place 2 Theta Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		if (smProductEvent->StartPickAndPlace2ThetaAxisMotorMoveStandbyPosition.Set == true)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2ThetaAxisMotorMoveStandbyPosition.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2ThetaAxisMotorMoveStandbyPosition(cMotion);
			if (nError == 0)
			{
				if (smProductEvent->JobMode.Set == true)
				{

				}
				smProductEvent->PickAndPlace2ThetaAxisMotorMoveStandbyPositionDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move standby Position Pick And Place 2 Theta Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}

		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Pick And Place 2 Theta Axis Motor thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_PICK_AND_PLACE_2_T_AXIS_MOTOR_END.Set = true;

	return nError;
}
#pragma endregion

#pragma region Vision Thread
ULONG CProductThread::InputVisionThread(void * nContext) // Only for input vision get xytheta
{
	int nError = 0;
	int nSequenceNo = 0;
	bool bAlarm = false;
	bool bRetry = false;
	bool bLearnUnit = false;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnDelayIn100ns;
	LONGLONG  lConvert1msTo100ns = 10000;
	m_cLogger->WriteLog("InputVisionseq: Start Input Vision sequence thread\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->GGUI_RSEQ_CHECK_SEQUENCE.Set == true)
		{
			m_cLogger->WriteLog("InputVisionseq: %u\n", nSequenceNo);
		}
		if (smProductEvent->GPCS_RSEQ_ABORT.Set == true && smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == false)
		{
			nSequenceNo = 0;
			smProductEvent->RSEQ_RINPV_START_VISION.Set = false;
			smProductEvent->RSEQ_RINPV_START_VISION_RETEST.Set = false;
		}
		if ((smProductEvent->Alarm.Set == true) && bAlarm == true)
		{
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			continue;
		}
		else if (smProductEvent->Alarm.Set == false && smProductEvent->JobPause.Set == false)
		{
			bAlarm = false;
		}

		//if(smProductEvent->JobStart.Set == false)
		//{
		//	RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		//	continue;
		//}

		//if(smProductEvent->JobStep.Set == true)
		//{
		//	if(smProductEvent->JobStart.Set == true)
		//	{
		//		smProductEvent->JobStart.Set = false;				
		//	}
		//	else
		//	{
		//		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		//		continue;
		//	}
		//}
		switch (nSequenceNo)
		{
		case 0:
			if ((smProductEvent->Alarm.Set == true || smProductEvent->JobPause.Set == true || smProductEvent->JobStart.Set == false) && smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == false)
			{
				break;
			}
			if (smProductEvent->RSEQ_RINPV_START_VISION.Set == true)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				nSequenceNo++;
				m_cLogger->WriteLog("InputVisionseq: Start Input Vision.\n");
			}
			else if (smProductEvent->RSEQ_RINPV_START_VISION_RETEST.Set == true)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				nSequenceNo++;
				m_cLogger->WriteLog("InputVisionseq: Start Input Vision retest.\n");
			}
			bLearnUnit = true;
			break;
		case 1:
			//if (smProductEvent->GMAIN_RTHD_INP_VISION_NEED_LEARN_UNIT.Set == true)
			//{
			//	if (bLearnUnit == true)
			//	{
			//		smProductEvent->GMAIN_RTHD_INP_VISION_LEARN_UNIT_DONE.Set = false;
			//		smProductEvent->RTHD_GMAIN_INP_VISION_LEARN_UNIT_START.Set = true;
			//		bLearnUnit = false;
			//	}
			//	if (smProductSetting->EnableInputVision == false || smProductCustomize->EnableInputVisionModule == false || smProductSetting->EnableVision == false)
			//	{
			//		smProductEvent->GMAIN_RTHD_INP_VISION_LEARN_UNIT_DONE.Set = true;
			//	}
			//	if (smProductEvent->GMAIN_RTHD_INP_VISION_LEARN_UNIT_DONE.Set == false)
			//	{
			//		break;
			//	}
			//}
			//smProductEvent->GMAIN_RTHD_INP_VISION_NEED_LEARN_UNIT.Set = false;
			if ((m_cProductIOControl->IsInputVisionReadyOn() == true && smProductSetting->EnableInputVision == true && smProductCustomize->EnableInputVisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableInputVisionModule == false || smProductSetting->EnableInputVision == false))
			{
				//m_cLogger->WriteLog("InputVisionseq: Input Vision ready.\n");
				nSequenceNo++;
			}
			else
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RINPV_START_VISION.Set = false;
				bAlarm = true;
				m_cProductShareVariables->SetAlarm(6101);
				m_cLogger->WriteLog("InputVisionseq: Input Vision not ready.\n");
				nSequenceNo = 0;
			}
			break;
		case 2:
			if ((m_cProductIOControl->IsInputVisionEndOfVision() == true && smProductSetting->EnableInputVision == true && smProductCustomize->EnableInputVisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableInputVisionModule == false || smProductSetting->EnableInputVision == false))
			{
				//m_cLogger->WriteLog("InputVisionseq: Input Vision not busy.\n");

				if (smProductEvent->RSEQ_RINPV_START_VISION.Set == true && bRetry == false)
				{
					nSequenceNo++;
					nSequenceNo++;
					nSequenceNo++;
				}
				else if (smProductEvent->RSEQ_RINPV_START_VISION_RETEST.Set == true || bRetry == true)
				{
					nSequenceNo++;
				}
			}
			else
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RINPV_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6102);
				m_cLogger->WriteLog("InputVisionseq: Input Vision busy.\n");
				nSequenceNo = 0;
			}
			break;
		case 3:
			smProductEvent->GMAIN_RTHD_INP_VISION_GET_RC_DONE.Set = false;
			smProductEvent->RTHD_GMAIN_SEND_INP_VISION_RC_START.Set = true;
			//m_cLogger->WriteLog("InputVisionseq: Input Vision send RC.\n");
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			nSequenceNo++;
			break;
		case 4:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			if (true
				&& smProductEvent->GMAIN_RTHD_INP_VISION_GET_RC_DONE.Set == true
				)
			{
				m_cLogger->WriteLog("InputVisionseq: Input Vision receive RC acknowledge done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RINPV_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6107);
				nSequenceNo = 0;
				m_cLogger->WriteLog("InputVisionseq: Input Vision receive coordinate timeout.\n");
			}
			break;
		case 5:
			smProductEvent->RMAIN_RINPV_GET_VISION_RESULT_DONE.Set = false;
			if (smProductEvent->RSEQ_RINPV_START_VISION.Set == true)
			{
				lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayBeforeInputVisionSnap_ms;
				RtSleepFt(&lnDelayIn100ns);
				m_cProductIOControl->SetInputVisionSOV(true);
			}
			else if (smProductEvent->RSEQ_RINPV_START_VISION_RETEST.Set == true)
			{
				lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayBeforeInputVisionSnap_ms;
				RtSleepFt(&lnDelayIn100ns);
				m_cProductIOControl->SetInputVisionROV(true);
				m_cProductIOControl->SetInputVisionSOV(true);
			}
			//m_cLogger->WriteLog("InputVisionseq: Input Vision SOV.\n");
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			nSequenceNo++;
			break;
		case 6:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//if ((IsS3VisionEndOfVision() == false && smProductSetting->EnableS3Vision == true && smProductCustomize->EnableS3Vision == true && smProductSetting->EnableVision == true)
			//	|| (smProductSetting->EnableVision == false || smProductCustomize->EnableS3Vision == false || smProductSetting->EnableS3Vision == false))
			//{
			//	m_cLogger->WriteLog("S3Visionseq: S3 Vision start of vision done.\n");
			//	SetS3VisionSOV(false);
			//	SetS3VisionROV(false);
			//	nSequenceNo++;
			//	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			//}
			//else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
			//{
			//	bAlarm = true;
			//	m_cProductShareVariables->SetAlarm(6304);
			//	SetS3VisionSOV(false);
			//	SetS3VisionROV(false);
			//	nSequenceNo = 0;
			//	m_cLogger->WriteLog("S3Visionseq: S3 Vision start of vision timeout.\n");
			//}
			//if ((lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 30)
			if ((lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 50)
				|| (m_cProductIOControl->IsInputVisionEndOfVision() == false && smProductSetting->EnableInputVision == true && smProductCustomize->EnableInputVisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableInputVisionModule == false || smProductSetting->EnableInputVision == false))
			{
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			}
			break;
		case 7:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			if ((m_cProductIOControl->IsInputVisionEndOfVision() == true && smProductEvent->RMAIN_RINPV_GET_VISION_RESULT_DONE.Set == true && smProductSetting->EnableInputVision == true && smProductCustomize->EnableInputVisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableInputVisionModule == false || smProductSetting->EnableInputVision == false))
			{
				bRetry = false;
				smProductProduction->CurrentInputVisionRetryCount++;
				m_cProductIOControl->SetInputVisionSOV(false);
				m_cProductIOControl->SetInputVisionROV(false);
				smProductEvent->RSEQ_RINPV_START_VISION.Set = false;
				smProductEvent->RSEQ_RINPV_START_VISION_RETEST.Set = false;
				smProductEvent->RINPV_RSEQ_VISION_DONE.Set = true;
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("InputVisionseq: Input Vision sequence Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			//else if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true && smProductProduction->ManualVisionTrigger[3] == 0)
			//{
			//	m_cProductIOControl->SetS3VisionSOV(false);
			//	m_cProductIOControl->SetS3VisionROV(false);
			//	smProductEvent->RSEQ_RS3V_START_VISION.Set = false;
			//	smProductEvent->RSEQ_RS3V_START_VISION_RETEST.Set = false;
			//	smProductEvent->RBTMV_RSEQ_VISION_DONE.Set = true;
			//	nSequenceNo = 0;
			//	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//	m_cLogger->WriteLog("ManualS3Visionseq: Manual S3 Vision sequence Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RINPV_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6105);
				m_cProductIOControl->SetInputVisionSOV(false);
				m_cProductIOControl->SetInputVisionROV(false);
				nSequenceNo = 0;
				m_cLogger->WriteLog("InputVisionseq: Input Vision result timeout.\n");
				if (m_cProductIOControl->IsInputVisionEndOfVision() == false)
				{
					m_cLogger->WriteLog("InputVisionseq: Input Vision end of vision not on.\n");
				}
				if (smProductEvent->RMAIN_RINPV_GET_VISION_RESULT_DONE.Set == false)
				{
					m_cLogger->WriteLog("InputVisionseq: Input Vision no receive result.\n");
				}
				smProductEvent->RINPV_GMAIN_INP_VISION_RESET_EOV.Set = true;
			}
			break;
		default:
			return -1;
			break;
		}
		//End of sequence
		if (nSequenceNo == 8)
		{
			nSequenceNo = 0;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cLogger->WriteLog("InputVisionseq: Input Vision sequence thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_INPUT_VISION_END.Set = true;
	return 0;
}
ULONG CProductThread::S2VisionThread(void * nContext)
{
	int nError = 0;
	int nSequenceNo = 0;
	bool bAlarm = false;
	bool bRetry = false;
	bool bLearnUnit = false;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockSpan1, lnClockStart2, lnClockStart3, lnDelayIn100ns;
	LONGLONG  lConvert1msTo100ns = 10000;
	m_cLogger->WriteLog("S2Visionseq: Start S2 Vision sequence thread\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->GGUI_RSEQ_CHECK_SEQUENCE.Set == true)
		{
			m_cLogger->WriteLog("S2Visionseq: %u\n", nSequenceNo);
		}
		if (smProductEvent->GPCS_RSEQ_ABORT.Set == true && smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == false)
		{
			nSequenceNo = 0;
			smProductEvent->RSEQ_RS2V_START_VISION.Set = false;
			smProductEvent->RSEQ_RS2V_START_VISION_RETEST.Set = false;
		}
		if ((smProductEvent->Alarm.Set == true) && bAlarm == true)
		{
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			continue;
		}
		else if (smProductEvent->Alarm.Set == false && smProductEvent->JobPause.Set == false)
		{
			bAlarm = false;
		}
		
		switch (nSequenceNo)
		{
		case 0:
			if ((smProductEvent->Alarm.Set == true || smProductEvent->JobPause.Set == true || smProductEvent->JobStart.Set == false) && smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == false)
			{
				break;
			}
			if (smProductEvent->RSEQ_RS2V_START_VISION.Set == true)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				nSequenceNo++;
				m_cLogger->WriteLog("S2Visionseq: Start S2 Vision.\n");
			}
			else if (smProductEvent->RSEQ_RS2V_START_VISION_RETEST.Set == true)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				nSequenceNo++;
				m_cLogger->WriteLog("S2Visionseq: Start S2 Vision retest.\n");
			}
			bLearnUnit = true;
			break;
		case 1:
			if ((m_cProductIOControl->IsS2VisionReadyOn() == true && smProductSetting->EnableS2Vision == true && smProductCustomize->EnableS2VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableS2VisionModule == false || smProductSetting->EnableS2Vision == false))
			{
				//m_cLogger->WriteLog("S2Visionseq: S2 Vision ready.\n");
				nSequenceNo++;
			}
			else
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RS3V_START_VISION.Set = false;
				bAlarm = true;
				m_cProductShareVariables->SetAlarm(6201);
				m_cLogger->WriteLog("S2Visionseq: S2 Vision not ready.\n");
				nSequenceNo = 0;
			}
			break;
		case 2:
			if ((smProductProduction->IsS2VisionFistSnap == true && m_cProductIOControl->IsS2VisionEndOfVision() == true && smProductSetting->EnableS2Vision == true && smProductCustomize->EnableS2VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductProduction->IsS2VisionFistSnap == false && m_cProductIOControl->IsS2VisionGrabDone() == true && smProductSetting->EnableS2Vision == true && smProductCustomize->EnableS2VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableS2VisionModule == false || smProductSetting->EnableS2Vision == false))
			{
				//m_cLogger->WriteLog("S2Visionseq: S2 Vision not busy.\n");

				if (smProductEvent->RSEQ_RS2V_START_VISION.Set == true && bRetry == false)
				{
					nSequenceNo++;
					nSequenceNo++;
					nSequenceNo++;
				}
				else if (smProductEvent->RSEQ_RS2V_START_VISION_RETEST.Set == true || bRetry == true)
				{
					nSequenceNo++;
				}
			}
			else
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RS2V_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6202);
				m_cLogger->WriteLog("S2Visionseq: S2 Vision busy.\n");
				nSequenceNo = 0;
			}
			break;
		case 3:
			if (smProductProduction->nCurrentInspectionStationS2S3 == 1)
			{
				smProductEvent->GMAIN_RTHD_S2_PARTING_VISION_GET_RC_DONE.Set = false;
				smProductEvent->RTHD_GMAIN_SEND_S2_PARTING_VISION_RC_START.Set = true;
			}
			else if (smProductProduction->nCurrentInspectionStationS2S3 == 2)
			{
				smProductEvent->GMAIN_RTHD_S2_FACET_VISION_GET_RC_DONE.Set = false;
				smProductEvent->RTHD_GMAIN_SEND_S2_FACET_VISION_RC_START.Set = true;
			}
			//m_cLogger->WriteLog("S2Visionseq: S2 Vision send RC.\n");
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			nSequenceNo++;
			break;
		case 4:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			if (true
				&& ((smProductEvent->GMAIN_RTHD_S2_PARTING_VISION_GET_RC_DONE.Set == true && smProductProduction->nCurrentInspectionStationS2S3 == 1) 
					|| (smProductEvent->GMAIN_RTHD_S2_FACET_VISION_GET_RC_DONE.Set == true && smProductProduction->nCurrentInspectionStationS2S3 == 2)
					)
				)
			{
				m_cLogger->WriteLog("S2Visionseq: S2 Vision receive RC acknowledge done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RS2V_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6207);
				nSequenceNo = 0;
				m_cLogger->WriteLog("S2Visionseq: S2 Vision receive coordinate timeout.\n");
			}
			break;
		case 5:
			smProductEvent->RMAIN_RS2V_GET_VISION_RESULT_DONE.Set = false;
			if (smProductEvent->RSEQ_RS2V_START_VISION.Set == true)
			{
				lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayBeforeS2VisionSnap_ms;
				RtSleepFt(&lnDelayIn100ns);
				m_cProductIOControl->SetS2VisionSOV(true);
			}
			else if (smProductEvent->RSEQ_RS2V_START_VISION_RETEST.Set == true)
			{
				lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayBeforeS2VisionSnap_ms;
				RtSleepFt(&lnDelayIn100ns);
				m_cProductIOControl->SetS2VisionROV(true);
				m_cProductIOControl->SetS2VisionSOV(true);
			}
			//m_cLogger->WriteLog("S2Visionseq: S2 Vision SOV.\n");
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
			nSequenceNo++;
			break;
		case 6:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			if ((lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 50)
				|| (smProductProduction->IsS2VisionFistSnap == false && m_cProductIOControl->IsS2VisionGrabDone() == false && smProductSetting->EnableS2Vision == true && smProductCustomize->EnableS2VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductProduction->IsS2VisionFistSnap == true  && m_cProductIOControl->IsS2VisionEndOfVision() == false && smProductSetting->EnableS2Vision == true && smProductCustomize->EnableS2VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableS2VisionModule == false || smProductSetting->EnableS2Vision == false))
			{
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			}
			break;
		case 7:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			lnClockSpan1.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			if ((smProductProduction->IsS2VisionFistSnap == true &&
				m_cProductIOControl->IsS2VisionEndOfVision() == true && smProductEvent->RMAIN_RS2V_GET_VISION_RESULT_DONE.Set == true && smProductSetting->EnableS2Vision == true && smProductCustomize->EnableS2VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductProduction->IsS2VisionFistSnap == false && (m_cProductIOControl->IsS2VisionGrabDone() == true || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 5) && smProductSetting->EnableS2Vision == true && smProductCustomize->EnableS2VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableS2VisionModule == false || smProductSetting->EnableS2Vision == false))
			{
				bRetry = false;
				smProductProduction->CurrentS2VisionRetryCount++;
				m_cProductIOControl->SetS2VisionSOV(false);
				m_cProductIOControl->SetS2VisionROV(false);
				smProductEvent->RSEQ_RS2V_START_VISION.Set = false;
				smProductEvent->RSEQ_RS2V_START_VISION_RETEST.Set = false;
				smProductEvent->RS2V_RSEQ_VISION_DONE.Set = true;
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("S2Visionseq: S2 Vision sequence Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				m_cLogger->WriteLog("S2Visionseq: S2 Snap Clock Done %ums.\n", lnClockSpan1.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RS2V_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6205);
				m_cProductIOControl->SetS2VisionSOV(false);
				m_cProductIOControl->SetS2VisionROV(false);
				nSequenceNo = 0;
				m_cLogger->WriteLog("S2Visionseq: S2 Vision result timeout.\n");
				if (m_cProductIOControl->IsS2VisionEndOfVision() == false)
				{
					m_cLogger->WriteLog("S2Visionseq: S2 Vision end of vision not on.\n");
				}
				if (smProductEvent->RMAIN_RS2V_GET_VISION_RESULT_DONE.Set == false)
				{
					m_cLogger->WriteLog("S2Visionseq: S2 Vision no receive result.\n");
				}
				smProductEvent->RS2V_GMAIN_S2_VISION_RESET_EOV.Set = true;
			}
			break;
		default:
			return -1;
			break;
		}
		//End of sequence
		if (nSequenceNo == 8)
		{
			nSequenceNo = 0;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cLogger->WriteLog("S2Visionseq: S2 Vision sequence thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_S2_VISION_END.Set = true;
	return 0;
}
ULONG CProductThread::OutputVisionThread(void * nContext) // Only for output vision get xy theta
{
	int nError = 0;
	int nSequenceNo = 0;
	bool bAlarm = false;
	bool bRetry = false;
	bool bLearnUnit = false;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnDelayIn100ns;
	LONGLONG  lConvert1msTo100ns = 10000;
	m_cLogger->WriteLog("OutputVisionseq: Start Output Vision sequence thread\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->GGUI_RSEQ_CHECK_SEQUENCE.Set == true)
		{
			m_cLogger->WriteLog("OutputVisionseq: %u\n", nSequenceNo);
		}
		if (smProductEvent->GPCS_RSEQ_ABORT.Set == true && smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == false)
		{
			nSequenceNo = 0;
			smProductEvent->RSEQ_ROUTV_START_VISION.Set = false;
			smProductEvent->RSEQ_ROUTV_START_VISION_RETEST.Set = false;
		}
		if ((smProductEvent->Alarm.Set == true) && bAlarm == true)
		{
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			continue;
		}
		else if (smProductEvent->Alarm.Set == false && smProductEvent->JobPause.Set == false)
		{
			bAlarm = false;
		}

		//if(smProductEvent->JobStart.Set == false)
		//{
		//	RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		//	continue;
		//}

		//if(smProductEvent->JobStep.Set == true)
		//{
		//	if(smProductEvent->JobStart.Set == true)
		//	{
		//		smProductEvent->JobStart.Set = false;				
		//	}
		//	else
		//	{
		//		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		//		continue;
		//	}
		//}
		switch (nSequenceNo)
		{
		case 0:
			if ((smProductEvent->Alarm.Set == true || smProductEvent->JobPause.Set == true || smProductEvent->JobStart.Set == false) && smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == false)
			{
				break;
			}
			if (smProductEvent->RSEQ_ROUTV_START_VISION.Set == true)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				nSequenceNo++;
				m_cLogger->WriteLog("OutputVisionseq: Start Output Vision.\n");
			}
			else if (smProductEvent->RSEQ_ROUTV_START_VISION_RETEST.Set == true)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				nSequenceNo++;
				m_cLogger->WriteLog("OutputVisionseq: Start Output Vision retest.\n");
			}
			bLearnUnit = true;
			break;
		case 1:
			//if (smProductEvent->GMAIN_RTHD_OUT_VISION_NEED_LEARN_UNIT.Set == true)
			//{
			//	if (bLearnUnit == true)
			//	{
			//		smProductEvent->GMAIN_RTHD_OUT_VISION_LEARN_UNIT_DONE.Set = false;
			//		smProductEvent->RTHD_GMAIN_OUT_VISION_LEARN_UNIT_START.Set = true;
			//		bLearnUnit = false;
			//	}
			//	if (smProductSetting->EnableOutputVision == false || smProductCustomize->EnableOutputVisionModule == false || smProductSetting->EnableVision == false)
			//	{
			//		smProductEvent->GMAIN_RTHD_OUT_VISION_LEARN_UNIT_DONE.Set = true;
			//	}
			//	if (smProductEvent->GMAIN_RTHD_OUT_VISION_LEARN_UNIT_DONE.Set == false)
			//	{
			//		break;
			//	}
			//}
			//smProductEvent->GMAIN_RTHD_OUT_VISION_NEED_LEARN_UNIT.Set = false;
			if ((m_cProductIOControl->IsOutputVisionReadyOn() == true && smProductSetting->EnableOutputVision == true && smProductCustomize->EnableOutputVisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableOutputVisionModule == false || smProductSetting->EnableOutputVision == false))
			{
				//m_cLogger->WriteLog("OutputVisionseq: Output Vision ready.\n");
				nSequenceNo++;
			}
			else
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_ROUTV_START_VISION.Set = false;
				bAlarm = true;
				m_cProductShareVariables->SetAlarm(6801);
				m_cLogger->WriteLog("OutputVisionseq: Output Vision not ready.\n");
				nSequenceNo = 0;
			}
			break;
		case 2:
			if ((m_cProductIOControl->IsOutputVisionEndOfVision() == true && smProductSetting->EnableOutputVision == true && smProductCustomize->EnableOutputVisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableOutputVisionModule == false || smProductSetting->EnableOutputVision == false))
			{
				//m_cLogger->WriteLog("OutputVisionseq: Output Vision not busy.\n");

				if (smProductEvent->RSEQ_ROUTV_START_VISION.Set == true && bRetry == false)
				{
					nSequenceNo++;
					nSequenceNo++;
					nSequenceNo++;
				}
				else if (smProductEvent->RSEQ_ROUTV_START_VISION_RETEST.Set == true || bRetry == true)
				{
					nSequenceNo++;
				}
			}
			else
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_ROUTV_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6802);
				m_cLogger->WriteLog("OutputVisionseq: Output Vision busy.\n");
				nSequenceNo = 0;
			}
			break;
		case 3:
			smProductEvent->GMAIN_RTHD_OUT_VISION_GET_RC_DONE.Set = false;
			smProductEvent->RTHD_GMAIN_SEND_OUT_VISION_RC_START.Set = true;
			//m_cLogger->WriteLog("OutputVisionseq: Output Vision send RC.\n");
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			nSequenceNo++;
			break;
		case 4:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			if (true
				&& smProductEvent->GMAIN_RTHD_OUT_VISION_GET_RC_DONE.Set == true
				)
			{
				m_cLogger->WriteLog("OutputVisionseq: Output Vision receive RC acknowledge done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_ROUTV_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6807);
				nSequenceNo = 0;
				m_cLogger->WriteLog("OutputVisionseq: Output Vision receive coordinate timeout.\n");
			}
			break;
		case 5:
			smProductEvent->GMAIN_ROUTV_GET_VISION_RESULT_DONE.Set = false;
			if (smProductEvent->RSEQ_ROUTV_START_VISION.Set == true)
			{
				lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayBeforeOutputVisionSnap_ms;
				RtSleepFt(&lnDelayIn100ns);
				m_cProductIOControl->SetOutputVisionSOV(true);
			}
			else if (smProductEvent->RSEQ_ROUTV_START_VISION_RETEST.Set == true)
			{
				lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayBeforeOutputVisionSnap_ms;
				RtSleepFt(&lnDelayIn100ns);
				m_cProductIOControl->SetOutputVisionROV(true);
				m_cProductIOControl->SetOutputVisionSOV(true);
			}
			//m_cLogger->WriteLog("OutputVisionseq: Output Vision SOV.\n");
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			nSequenceNo++;
			break;
		case 6:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//if ((IsS3VisionEndOfVision() == false && smProductSetting->EnableS3Vision == true && smProductCustomize->EnableS3Vision == true && smProductSetting->EnableVision == true)
			//	|| (smProductSetting->EnableVision == false || smProductCustomize->EnableS3Vision == false || smProductSetting->EnableS3Vision == false))
			//{
			//	m_cLogger->WriteLog("S3Visionseq: S3 Vision start of vision done.\n");
			//	SetS3VisionSOV(false);
			//	SetS3VisionROV(false);
			//	nSequenceNo++;
			//	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			//}
			//else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
			//{
			//	bAlarm = true;
			//	m_cProductShareVariables->SetAlarm(6304);
			//	SetS3VisionSOV(false);
			//	SetS3VisionROV(false);
			//	nSequenceNo = 0;
			//	m_cLogger->WriteLog("S3Visionseq: S3 Vision start of vision timeout.\n");
			//}
			//if ((lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 30)
			if ((lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 50)
				|| (m_cProductIOControl->IsOutputVisionEndOfVision() == false && smProductSetting->EnableOutputVision == true && smProductCustomize->EnableOutputVisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableOutputVisionModule == false || smProductSetting->EnableOutputVision == false))
			{
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			}
			break;
		case 7:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			if ((m_cProductIOControl->IsOutputVisionEndOfVision() == true && smProductEvent->GMAIN_ROUTV_GET_VISION_RESULT_DONE.Set == true && smProductSetting->EnableOutputVision == true && smProductCustomize->EnableOutputVisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableOutputVisionModule == false || smProductSetting->EnableOutputVision == false))
			{
				bRetry = false;
				smProductProduction->CurrentOutputVisionRetryCount++;
				m_cProductIOControl->SetOutputVisionSOV(false);
				m_cProductIOControl->SetOutputVisionROV(false);
				smProductEvent->RSEQ_ROUTV_START_VISION.Set = false;
				smProductEvent->RSEQ_ROUTV_START_VISION_RETEST.Set = false;
				smProductEvent->ROUTV_RSEQ_VISION_DONE.Set = true;

				if (smProductProduction->OutputTableResult[0].OutputResult == 1)
				{
					smProductProduction->CurrentOutputVisionContinuousFailCount = 0;
				}
				else if (smProductProduction->OutputTableResult[0].OutputResult != 1)
				{
					smProductProduction->CurrentOutputVisionContinuousFailCount++;
				}


				if (smProductSetting->OutputVisionContinuousFailCountToTriggerAlarm != 0)
				{
					if (smProductProduction->CurrentOutputVisionContinuousFailCount >= (int)smProductSetting->OutputVisionContinuousFailCountToTriggerAlarm)
					{
						m_cProductShareVariables->SetAlarm(6824);
					}
				}
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("OutputVisionseq: Output Vision sequence Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			//else if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true && smProductProduction->ManualVisionTrigger[3] == 0)
			//{
			//	m_cProductIOControl->SetS3VisionSOV(false);
			//	m_cProductIOControl->SetS3VisionROV(false);
			//	smProductEvent->RSEQ_RS3V_START_VISION.Set = false;
			//	smProductEvent->RSEQ_RS3V_START_VISION_RETEST.Set = false;
			//	smProductEvent->RBTMV_RSEQ_VISION_DONE.Set = true;
			//	nSequenceNo = 0;
			//	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//	m_cLogger->WriteLog("ManualS3Visionseq: Manual S3 Vision sequence Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RS3V_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6805);
				m_cProductIOControl->SetOutputVisionSOV(false);
				m_cProductIOControl->SetOutputVisionROV(false);
				nSequenceNo = 0;
				m_cLogger->WriteLog("OutputVisionseq: Output Vision result timeout.\n");
				if (m_cProductIOControl->IsOutputVisionEndOfVision() == false)
				{
					m_cLogger->WriteLog("OutputVisionseq: Output Vision end of vision not on.\n");
				}
				if (smProductEvent->GMAIN_RS3V_GET_VISION_RESULT_DONE.Set == false)
				{
					m_cLogger->WriteLog("OutputVisionseq: Output Vision no receive result.\n");
				}
				smProductEvent->RS3V_GMAIN_S3_VISION_RESET_EOV.Set = true;
			}
			break;
		default:
			return -1;
			break;
		}
		//End of sequence
		if (nSequenceNo == 8)
		{
			nSequenceNo = 0;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cLogger->WriteLog("OutputVisionseq: Output Vision sequence thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_OUTPUT_VISION_END.Set = true;
	return 0;
}
ULONG CProductThread::BottomVisionThread(void * nContext)
{
	int nError = 0;
	int nSequenceNo = 0;
	bool bAlarm = false;
	bool bRetry = false;
	bool bLearnUnit = false;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnDelayIn100ns;
	LONGLONG  lConvert1msTo100ns = 10000;
	m_cLogger->WriteLog("BottomVisionseq: Start Bottom Vision sequence thread\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->GGUI_RSEQ_CHECK_SEQUENCE.Set == true)
		{
			m_cLogger->WriteLog("BottomVisionseq: %u\n", nSequenceNo);
		}
		if (smProductEvent->GPCS_RSEQ_ABORT.Set == true && smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == false)
		{
			nSequenceNo = 0;
			smProductEvent->RSEQ_RBTMV_START_VISION.Set = false;
			smProductEvent->RSEQ_RBTMV_START_VISION_RETEST.Set = false;
		}
		if ((smProductEvent->Alarm.Set == true) && bAlarm == true)
		{
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			continue;
		}
		else if (smProductEvent->Alarm.Set == false && smProductEvent->JobPause.Set == false)
		{
			bAlarm = false;
		}

		switch (nSequenceNo)
		{
		case 0:
			if ((smProductEvent->Alarm.Set == true || smProductEvent->JobPause.Set == true || smProductEvent->JobStart.Set == false) && smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == false)
			{
				break;
			}
			if (smProductEvent->RSEQ_RBTMV_START_VISION.Set == true)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				nSequenceNo++;
				m_cLogger->WriteLog("BottomVisionseq: Start Bottom Vision.\n");
			}
			else if (smProductEvent->RSEQ_RBTMV_START_VISION_RETEST.Set == true)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				nSequenceNo++;
				m_cLogger->WriteLog("BottomVisionseq: Start Bottom Vision retest.\n");
			}
			bLearnUnit = true;
			break;
		case 1:
			if ((m_cProductIOControl->IsBottomVisionReadyOn() == true && smProductSetting->EnableBottomVision == true && smProductCustomize->EnableBottomVisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableBottomVisionModule == false || smProductSetting->EnableBottomVision == false))
			{
				//m_cLogger->WriteLog("BottomVisionseq: Bottom Vision ready.\n");
				nSequenceNo++;
			}
			else
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RBTMV_START_VISION.Set = false;
				bAlarm = true;
				m_cProductShareVariables->SetAlarm(6901);
				m_cLogger->WriteLog("BottomVisionseq: Bottom Vision not ready.\n");
				nSequenceNo = 0;
			}
			break;
		case 2:
			if ((smProductSetting->EnableVisionWaitResult == true && m_cProductIOControl->IsBottomVisionEndOfVision() == true && smProductSetting->EnableBottomVision == true && smProductCustomize->EnableBottomVisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableBottomVisionModule == false || smProductSetting->EnableBottomVision == false))
			{
				//m_cLogger->WriteLog("BottomVisionseq: Bottom Vision not busy.\n");

				if (smProductEvent->RSEQ_RBTMV_START_VISION.Set == true && bRetry == false)
				{
					nSequenceNo++;
					nSequenceNo++;
					nSequenceNo++;
				}
				else if (smProductEvent->RSEQ_RBTMV_START_VISION_RETEST.Set == true || bRetry == true)
				{
					nSequenceNo++;
				}
			}
			else
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RBTMV_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6902);
				m_cLogger->WriteLog("BottomVisionseq: Bottom Vision busy.\n");
				nSequenceNo = 0;
			}
			break;
		case 3:
			if (smProductProduction->nCurrentInspectionStationBottom == 1)
			{
				smProductEvent->GMAIN_RTHD_BOTTOM_VISION_GET_RC_DONE.Set = false;
				smProductEvent->RTHD_GMAIN_SEND_BOTTOM_VISION_RC_START.Set = true;
			}
			else if (smProductProduction->nCurrentInspectionStationBottom == 2)
			{
				smProductEvent->GMAIN_RTHD_SETUP_VISION_GET_RC_DONE.Set = false;
				smProductEvent->RTHD_GMAIN_SEND_SETUP_VISION_RC_START.Set = true;
			}
			else if (smProductProduction->nCurrentInspectionStationBottom == 3)
			{
				smProductEvent->GMAIN_RTHD_S1_VISION_GET_RC_DONE.Set = false;
				smProductEvent->RTHD_GMAIN_SEND_S1_VISION_RC_START.Set = true;
			}

			//m_cLogger->WriteLog("BottomVisionseq: Bottom Vision send RC.\n");
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			nSequenceNo++;
			break;
		case 4:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			if (true
				&& ((smProductEvent->GMAIN_RTHD_BOTTOM_VISION_GET_RC_DONE.Set == true && smProductProduction->nCurrentInspectionStationBottom == 1) 
					|| (smProductEvent->GMAIN_RTHD_SETUP_VISION_GET_RC_DONE.Set == true && smProductProduction->nCurrentInspectionStationBottom == 2)
					|| (smProductEvent->GMAIN_RTHD_S1_VISION_GET_RC_DONE.Set == true && smProductProduction->nCurrentInspectionStationBottom == 3)
					)
				)
			{
				m_cLogger->WriteLog("BottomVisionseq: Bottom Vision receive RC acknowledge done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RBTMV_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6907);
				nSequenceNo = 0;
				m_cLogger->WriteLog("BottomVisionseq: Bottom Vision receive coordinate timeout.\n");
			}
			break;
		case 5:
			smProductEvent->GMAIN_RBTMV_GET_VISION_RESULT_DONE.Set = false;
			if (smProductEvent->RSEQ_RBTMV_START_VISION.Set == true)
			{
				lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayBeforeBottomVisionSnap_ms;
				RtSleepFt(&lnDelayIn100ns);
				m_cProductIOControl->SetBottomVisionSOV(true);
				m_cLogger->WriteLog("BottomVisionseq: SetBottomVisionSOV(true).\n");
			}
			else if (smProductEvent->RSEQ_RBTMV_START_VISION_RETEST.Set == true)
			{
				lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayBeforeBottomVisionSnap_ms;
				RtSleepFt(&lnDelayIn100ns);
				m_cProductIOControl->SetBottomVisionROV(true);
				m_cProductIOControl->SetBottomVisionSOV(true);
				m_cLogger->WriteLog("BottomVisionseq: SetBottomVisionSOV(true).\n");
			}
			//m_cLogger->WriteLog("BottomVisionseq: Bottom Vision SOV.\n");
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			nSequenceNo++;
			break;
		case 6:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			if ((lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 50)
				|| (smProductSetting->EnableVisionWaitResult == true 
					&& m_cProductIOControl->IsS1VisionEndOfVision() == false && smProductSetting->EnableBottomVision == true 
					&& smProductCustomize->EnableBottomVisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableBottomVisionModule == false || smProductSetting->EnableBottomVision == false))
			{
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			}
			break;
		case 7:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			if ((smProductSetting->EnableVisionWaitResult == true &&
				m_cProductIOControl->IsS1VisionEndOfVision() == true && smProductEvent->GMAIN_RBTMV_GET_VISION_RESULT_DONE.Set == true && smProductSetting->EnableBottomVision == true && smProductCustomize->EnableBottomVisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableBottomVisionModule == false || smProductSetting->EnableBottomVision == false))
			{
				bRetry = false;
				smProductProduction->CurrentBottomVisionRetryCount++;
				m_cProductIOControl->SetBottomVisionSOV(false);
				m_cProductIOControl->SetBottomVisionROV(false);
				m_cLogger->WriteLog("BottomVisionseq: SetBottomVisionSOV(false).\n");
				smProductEvent->RSEQ_RBTMV_START_VISION.Set = false;
				smProductEvent->RSEQ_RBTMV_START_VISION_RETEST.Set = false;
				smProductEvent->RBTMV_RSEQ_VISION_DONE.Set = true;
				if (smProductSetting->EnableVisionWaitResult == true)
				{
					if (smProductEvent->ReviewMode.Set == true)
					{
						if (smProductProduction->IsS1VisionFistSnap == true)
						{
							if (smProductProduction->PickAndPlacePickUpHeadStationResult[smProductProduction->nCurrentPickupHeadAtS1].BottomResult == 1)
							{
								smProductProduction->CurrentBottomVisionContinuousFailCount = 0;
							}
							else if (smProductProduction->PickAndPlacePickUpHeadStationResult[smProductProduction->nCurrentPickupHeadAtS1].BottomResult != 1)
							{
								smProductProduction->CurrentBottomVisionContinuousFailCount++;
							}
						}
						else
						{
							if (smProductSetting->BottomVision[smProductProduction->CurrentBottomVisionLoopNo].Result == 1)
							{
								smProductProduction->CurrentBottomVisionContinuousFailCount = 0;
							}
							else if (smProductSetting->BottomVision[smProductProduction->CurrentBottomVisionLoopNo].Result != 1)
							{
								smProductProduction->CurrentBottomVisionContinuousFailCount++;
							}
						}
						/*if (smProductSetting->BottomVisionContinuousFailCountToTriggerAlarm != 0)*/
						{
							if (smProductProduction->CurrentBottomVisionContinuousFailCount >= 1/*(int)smProductSetting->BottomVisionContinuousFailCountToTriggerAlarm*/)
							{
								m_cProductShareVariables->SetAlarm(6924);
							}
						}
					}
				}
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("BottomVisionseq: Bottom Vision sequence Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				m_cLogger->WriteLog("[TIMER],BottomVisionseq: Bottom Vision sequence Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			//else if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true && smProductProduction->ManualVisionTrigger[3] == 0)
			//{
			//	m_cProductIOControl->SetS1VisionSOV(false);
			//	m_cProductIOControl->SetS1VisionROV(false);
			//	smProductEvent->RSEQ_RBTMV_START_VISION.Set = false;
			//	smProductEvent->RSEQ_RBTMV_START_VISION_RETEST.Set = false;
			//	smProductEvent->RBTMV_RSEQ_VISION_DONE.Set = true;
			//	nSequenceNo = 0;
			//	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//	m_cLogger->WriteLog("ManualBottomVisionseq: Manual Bottom Vision sequence Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RBTMV_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6905);
				m_cProductIOControl->SetS1VisionSOV(false);
				m_cProductIOControl->SetS1VisionROV(false);
				m_cLogger->WriteLog("BottomVisionseq: SetS1VisionSOV(false).\n");
				nSequenceNo = 0;
				m_cLogger->WriteLog("BottomVisionseq: Bottom Vision result timeout.\n");
				if (m_cProductIOControl->IsS1VisionEndOfVision() == false)
				{
					m_cLogger->WriteLog("BottomVisionseq: Bottom Vision end of vision not on.\n");
				}
				if (smProductEvent->GMAIN_RBTMV_GET_VISION_RESULT_DONE.Set == false)
				{
					m_cLogger->WriteLog("BottomVisionseq: Bottom Vision no receive result.\n");
				}
				smProductEvent->RBTMV_GMAIN_BOTTOM_VISION_RESET_EOV.Set = true;
			}
			break;
		default:
			return -1;
			break;
		}
		//End of sequence
		if (nSequenceNo == 8)
		{
			nSequenceNo = 0;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cLogger->WriteLog("BottomVisionseq: Bottom Vision sequence thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_BOTTOM_VISION_END.Set = true;
	return 0;
}
ULONG CProductThread::S1VisionThread(void * nContext)
{
	int nError = 0;
	int nSequenceNo = 0;
	bool bAlarm = false;
	bool bRetry = false;
	bool bLearnUnit = false;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnDelayIn100ns;
	LONGLONG  lConvert1msTo100ns = 10000;
	m_cLogger->WriteLog("S1Visionseq: Start S1 Vision sequence thread\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->GGUI_RSEQ_CHECK_SEQUENCE.Set == true)
		{
			m_cLogger->WriteLog("S1Visionseq: %u\n", nSequenceNo);
		}
		if (smProductEvent->GPCS_RSEQ_ABORT.Set == true && smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == false)
		{
			nSequenceNo = 0;
			smProductEvent->RSEQ_RS1V_START_VISION.Set = false;
			smProductEvent->RSEQ_RS1V_START_VISION_RETEST.Set = false;
		}
		if ((smProductEvent->Alarm.Set == true) && bAlarm == true)
		{
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			continue;
		}
		else if (smProductEvent->Alarm.Set == false && smProductEvent->JobPause.Set == false)
		{
			bAlarm = false;
		}

		
		switch (nSequenceNo)
		{
		case 0:
			if ((smProductEvent->Alarm.Set == true || smProductEvent->JobPause.Set == true || smProductEvent->JobStart.Set == false) && smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == false)
			{
				break;
			}
			if (smProductEvent->RSEQ_RS1V_START_VISION.Set == true)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				nSequenceNo++;
				m_cLogger->WriteLog("S1Visionseq: Start S1 Vision.\n");
			}
			else if (smProductEvent->RSEQ_RS1V_START_VISION_RETEST.Set == true)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				nSequenceNo++;
				m_cLogger->WriteLog("S1Visionseq: Start S1 Vision retest.\n");
			}
			bLearnUnit = true;
			break;
		case 1:
			if ((m_cProductIOControl->IsS1VisionReadyOn() == true && smProductSetting->EnableS1Vision == true && smProductCustomize->EnableS1VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableS1VisionModule == false || smProductSetting->EnableS1Vision == false))
			{
				//m_cLogger->WriteLog("S1Visionseq: S1 Vision ready.\n");
				nSequenceNo++;
			}
			else
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RS1V_START_VISION.Set = false;
				bAlarm = true;
				m_cProductShareVariables->SetAlarm(6301);
				m_cLogger->WriteLog("S1Visionseq: S1 Vision not ready.\n");
				nSequenceNo = 0;
			}
			break;
		case 2:
			if ((smProductProduction->IsS1VisionFistSnap == true && m_cProductIOControl->IsS1VisionEndOfVision() == true && smProductSetting->EnableS1Vision == true && smProductCustomize->EnableS1VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductProduction->IsS1VisionFistSnap == false && m_cProductIOControl->IsS1VisionGrabDone() == true && smProductSetting->EnableS1Vision == true && smProductCustomize->EnableS1VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableS1VisionModule == false || smProductSetting->EnableS1Vision == false))
			{
				//m_cLogger->WriteLog("S1Visionseq: S1 Vision not busy.\n");

				if (smProductEvent->RSEQ_RS1V_START_VISION.Set == true && bRetry == false)
				{
					nSequenceNo++;
					nSequenceNo++;
					nSequenceNo++;
				}
				else if (smProductEvent->RSEQ_RS1V_START_VISION_RETEST.Set == true || bRetry == true)
				{
					nSequenceNo++;
				}
			}
			else
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RS1V_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6302);
				m_cLogger->WriteLog("S1Visionseq: S1 Vision busy.\n");
				nSequenceNo = 0;
			}
			break;
		case 3:
			
			if (smProductProduction->nCurrentInspectionStationBottom == 1)
			{
				smProductEvent->GMAIN_RTHD_BOTTOM_VISION_GET_RC_DONE.Set = false;
				smProductEvent->RTHD_GMAIN_SEND_BOTTOM_VISION_RC_START.Set = true;
			}
			else if (smProductProduction->nCurrentInspectionStationBottom == 2)
			{
				smProductEvent->GMAIN_RTHD_SETUP_VISION_GET_RC_DONE.Set = false;
				smProductEvent->RTHD_GMAIN_SEND_SETUP_VISION_RC_START.Set = true;
			}
			else if (smProductProduction->nCurrentInspectionStationBottom == 3)
			{
				smProductEvent->GMAIN_RTHD_S1_VISION_GET_RC_DONE.Set = false;
				smProductEvent->RTHD_GMAIN_SEND_S1_VISION_RC_START.Set = true;
			}
			//m_cLogger->WriteLog("S1Visionseq: S1 Vision send RC.\n");
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			nSequenceNo++;
			break;
		case 4:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			if (true
				&& smProductEvent->GMAIN_RTHD_SETUP_VISION_GET_RC_DONE.Set == true
				)
			{
				m_cLogger->WriteLog("S1Visionseq: S1 Vision receive RC acknowledge done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RS1V_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6307);
				nSequenceNo = 0;
				m_cLogger->WriteLog("S1Visionseq: S1 Vision receive coordinate timeout.\n");
			}
			break;
		case 5:
			smProductEvent->GMAIN_RS1V_GET_VISION_RESULT_DONE.Set = false;
			smProductEvent->RMAIN_RSTPV_GET_VISION_RESULT_DONE.Set = false;
			if (smProductEvent->RSEQ_RS1V_START_VISION.Set == true)
			{
				lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayBeforeS1VisionSnap_ms;
				RtSleepFt(&lnDelayIn100ns);
				m_cProductIOControl->SetS1VisionSOV(true);
			}
			else if (smProductEvent->RSEQ_RS1V_START_VISION_RETEST.Set == true)
			{
				lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayBeforeS1VisionSnap_ms;
				RtSleepFt(&lnDelayIn100ns);
				m_cProductIOControl->SetS1VisionROV(true);
				m_cProductIOControl->SetS1VisionSOV(true);
			}
			//m_cLogger->WriteLog("S1Visionseq: S1 Vision SOV.\n");
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			nSequenceNo++;
			break;
		case 6:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			if ((lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 50)
				|| (smProductProduction->IsS1VisionFistSnap == false  && m_cProductIOControl->IsS1VisionGrabDone() == false && smProductSetting->EnableS1Vision == true && smProductCustomize->EnableS1VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductProduction->IsS1VisionFistSnap == true && m_cProductIOControl->IsS1VisionEndOfVision() == false && smProductSetting->EnableS1Vision == true && smProductCustomize->EnableS1VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableS1VisionModule == false || smProductSetting->EnableS1Vision == false))
			{
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			}
			break;
		case 7:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			if ((smProductProduction->IsS1VisionFistSnap == true &&
				m_cProductIOControl->IsS1VisionEndOfVision() == true && smProductEvent->RMAIN_RSTPV_GET_VISION_RESULT_DONE.Set == true && smProductSetting->EnableS1Vision == true && smProductCustomize->EnableS1VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductProduction->IsS1VisionFistSnap == false && m_cProductIOControl->IsS1VisionGrabDone() == true && smProductSetting->EnableS1Vision == true && smProductCustomize->EnableS1VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableS1VisionModule == false || smProductSetting->EnableS1Vision == false))
			{
				bRetry = false;
				smProductProduction->CurrentS1VisionRetryCount++;
				m_cProductIOControl->SetS1VisionSOV(false);
				m_cProductIOControl->SetS1VisionROV(false);
				smProductEvent->RSEQ_RS1V_START_VISION.Set = false;
				smProductEvent->RSEQ_RS1V_START_VISION_RETEST.Set = false;
				smProductEvent->RS1V_RSEQ_VISION_DONE.Set = true;

				//if (smProductSetting->EnableVisionWaitResult == true)
				{
					if (smProductEvent->GGUI_RSEQ_DRY_RUN_MODE.Set == true)
					{
						smProductSetting->S1Vision[smProductProduction->CurrentS1VisionLoopNo].Result = 1;
					}
					if (smProductEvent->ReviewMode.Set == true)
					{
						//if (smProductProduction->PickAndPlacePickUpHeadStationResult[smProductProduction->nCurrentPickupHeadAtS1].S1Result == 1)
						if (smProductSetting->S1Vision[smProductProduction->CurrentS1VisionLoopNo].Result == 1)
						{
							smProductProduction->CurrentS1VisionContinuousFailCount = 0;
						}
						//else if (smProductProduction->PickAndPlacePickUpHeadStationResult[smProductProduction->nCurrentPickupHeadAtS1].S1Result != 1)
						else if (smProductSetting->S1Vision[smProductProduction->CurrentS1VisionLoopNo].Result != 1)
						{
							smProductProduction->CurrentS1VisionContinuousFailCount++;
						}
						//if (smProductSetting->S1VisionContinuousFailCountToTriggerAlarm != 0)
						{
							if (smProductProduction->CurrentS1VisionContinuousFailCount >= 1/*(int)smProductSetting->S1VisionContinuousFailCountToTriggerAlarm*/)
							{
								m_cProductShareVariables->SetAlarm(6324);
							}
						}
					}
				}
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("S1Visionseq: S1 Vision sequence Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RS1V_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6305);
				m_cProductIOControl->SetS1VisionSOV(false);
				m_cProductIOControl->SetS1VisionROV(false);
				nSequenceNo = 0;
				m_cLogger->WriteLog("S1Visionseq: S1 Vision result timeout.\n");
				if (m_cProductIOControl->IsS1VisionEndOfVision() == false)
				{
					m_cLogger->WriteLog("S1Visionseq: S1 Vision end of vision not on.\n");
				}
				if (smProductEvent->GMAIN_RS1V_GET_VISION_RESULT_DONE.Set == false)
				{
					m_cLogger->WriteLog("S1Visionseq: S1 Vision no receive result.\n");
				}
				smProductEvent->RS1V_GMAIN_S1_VISION_RESET_EOV.Set = true;
			}
			break;
		default:
			return -1;
			break;
		}
		//End of sequence
		if (nSequenceNo == 8)
		{
			nSequenceNo = 0;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cLogger->WriteLog("S1Visionseq: S1 Vision sequence thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_S1_VISION_END.Set = true;
	return 0;
}

ULONG CProductThread::S3VisionThread(void * nContext)
{
	int nError = 0;
	int nSequenceNo = 0;
	bool bAlarm = false;
	bool bRetry = false;
	bool bLearnUnit = false;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockSpan1, lnClockStart2, lnClockStart3, lnDelayIn100ns;
	LONGLONG  lConvert1msTo100ns = 10000;
	m_cLogger->WriteLog("S3Visionseq: Start S3 Vision sequence thread\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->GGUI_RSEQ_CHECK_SEQUENCE.Set == true)
		{
			m_cLogger->WriteLog("S3Visionseq: %u\n", nSequenceNo);
		}
		if (smProductEvent->GPCS_RSEQ_ABORT.Set == true && smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == false)
		{
			nSequenceNo = 0;
			smProductEvent->RSEQ_RS3V_START_VISION.Set = false;
			smProductEvent->RSEQ_RS3V_START_VISION_RETEST.Set = false;
		}
		if ((smProductEvent->Alarm.Set == true) && bAlarm == true)
		{
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			continue;
		}
		else if (smProductEvent->Alarm.Set == false && smProductEvent->JobPause.Set == false)
		{
			bAlarm = false;
		}
		switch (nSequenceNo)
		{
		case 0:
			if ((smProductEvent->Alarm.Set == true || smProductEvent->JobPause.Set == true || smProductEvent->JobStart.Set == false) && smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == false)
			{
				break;
			}
			if (smProductEvent->RSEQ_RS3V_START_VISION.Set == true)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				nSequenceNo++;
				m_cLogger->WriteLog("S3Visionseq: Start S3 Vision.\n");
			}
			else if (smProductEvent->RSEQ_RS3V_START_VISION_RETEST.Set == true)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				nSequenceNo++;
				m_cLogger->WriteLog("S3Visionseq: Start S3 Vision retest.\n");
			}
			bLearnUnit = true;
			break;
		case 1:
			if ((m_cProductIOControl->IsS3VisionReadyOn() == true && smProductSetting->EnableS3Vision == true && smProductCustomize->EnableS3VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableS3VisionModule == false || smProductSetting->EnableS3Vision == false))
			{
				//m_cLogger->WriteLog("S3Visionseq: S3 Vision ready.\n");
				nSequenceNo++;
			}
			else
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RS3V_START_VISION.Set = false;
				bAlarm = true;
				m_cProductShareVariables->SetAlarm(6701);
				m_cLogger->WriteLog("S3Visionseq: S3 Vision not ready.\n");
				nSequenceNo = 0;
			}
			break;
		case 2:
			if (((smProductProduction->IsS3VisionFistSnap == true || smProductSetting->EnableVisionWaitResult == true) && m_cProductIOControl->IsS3VisionEndOfVision() == true && smProductSetting->EnableS3Vision == true && smProductCustomize->EnableS3VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductProduction->IsS3VisionFistSnap == false && smProductSetting->EnableVisionWaitResult == false && m_cProductIOControl->IsS3VisionGrabDone() == true && smProductSetting->EnableS3Vision == true && smProductCustomize->EnableS3VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableS3VisionModule == false || smProductSetting->EnableS3Vision == false))
			{
				//m_cLogger->WriteLog("S3Visionseq: S3 Vision not busy.\n");

				if (smProductEvent->RSEQ_RS3V_START_VISION.Set == true && bRetry == false)
				{
					nSequenceNo++;
					nSequenceNo++;
					nSequenceNo++;
				}
				else if (smProductEvent->RSEQ_RS3V_START_VISION_RETEST.Set == true || bRetry == true)
				{
					nSequenceNo++;
				}
			}
			else
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RS3V_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6702);
				m_cLogger->WriteLog("S3Visionseq: S3 Vision busy.\n");
				nSequenceNo = 0;
			}
			break;
		case 3:
			if (smProductProduction->nCurrentInspectionStationS2S3 == 1)
			{
				smProductEvent->GMAIN_RTHD_S3_PARTING_VISION_GET_RC_DONE.Set = false;
				smProductEvent->RTHD_GMAIN_SEND_S3_PARTING_VISION_RC_START.Set = true;
			}
			else if (smProductProduction->nCurrentInspectionStationS2S3 == 2)
			{
				smProductEvent->GMAIN_RTHD_S3_FACET_VISION_GET_RC_DONE.Set = false;
				smProductEvent->RTHD_GMAIN_SEND_S3_FACET_VISION_RC_START.Set = true;
			}
			//m_cLogger->WriteLog("S3Visionseq: S3 Vision send RC.\n");
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			nSequenceNo++;
			break;
		case 4:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			if (true
				&& ((smProductEvent->GMAIN_RTHD_S2_PARTING_VISION_GET_RC_DONE.Set == true && smProductProduction->nCurrentInspectionStationS2S3 == 1)
					|| (smProductEvent->GMAIN_RTHD_S2_FACET_VISION_GET_RC_DONE.Set == true && smProductProduction->nCurrentInspectionStationS2S3 == 2)
					)
				)
			{
				m_cLogger->WriteLog("S3Visionseq: S3 Vision receive RC acknowledge done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RS3V_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6707);
				nSequenceNo = 0;
				m_cLogger->WriteLog("S3Visionseq: S3 Vision receive coordinate timeout.\n");
			}
			break;
		case 5:
			smProductEvent->GMAIN_RS3V_GET_VISION_RESULT_DONE.Set = false;
			if (smProductEvent->RSEQ_RS3V_START_VISION.Set == true)
			{
				lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayBeforeS3VisionSnap_ms;
				RtSleepFt(&lnDelayIn100ns);
				m_cProductIOControl->SetS3VisionSOV(true);
			}
			else if (smProductEvent->RSEQ_RS3V_START_VISION_RETEST.Set == true)
			{
				lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayBeforeS3VisionSnap_ms;
				RtSleepFt(&lnDelayIn100ns);
				m_cProductIOControl->SetS3VisionROV(true);
				m_cProductIOControl->SetS3VisionSOV(true);
			}
			//m_cLogger->WriteLog("S3Visionseq: S3 Vision SOV.\n");
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
			nSequenceNo++;
			break;
		case 6:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			if ((lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 50)
				|| (smProductProduction->IsS3VisionFistSnap == false && m_cProductIOControl->IsS3VisionGrabDone() == false && smProductSetting->EnableS3Vision == true && smProductCustomize->EnableS3VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductProduction->IsS3VisionFistSnap == true && m_cProductIOControl->IsS3VisionEndOfVision() == false && smProductSetting->EnableS3Vision == true && smProductCustomize->EnableS3VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableS3VisionModule == false || smProductSetting->EnableS3Vision == false))
			{
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			}
			break;
		case 7:
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			lnClockSpan1.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			if ((smProductProduction->IsS3VisionFistSnap == true && m_cProductIOControl->IsS3VisionEndOfVision() == true 
				&& smProductEvent->GMAIN_RS3V_GET_VISION_RESULT_DONE.Set == true && smProductSetting->EnableS3Vision == true && smProductCustomize->EnableS3VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductProduction->IsS3VisionFistSnap == false && (m_cProductIOControl->IsS3VisionGrabDone() == true || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 5) && smProductSetting->EnableS3Vision == true && smProductCustomize->EnableS3VisionModule == true && smProductSetting->EnableVision == true)
				|| (smProductSetting->EnableVision == false || smProductCustomize->EnableS3VisionModule == false || smProductSetting->EnableS3Vision == false))
			{
				bRetry = false;
				smProductProduction->CurrentS3VisionRetryCount++;
				m_cProductIOControl->SetS3VisionSOV(false);
				m_cProductIOControl->SetS3VisionROV(false);
				smProductEvent->RSEQ_RS3V_START_VISION.Set = false;
				smProductEvent->RSEQ_RS3V_START_VISION_RETEST.Set = false;
				smProductEvent->RS3V_RSEQ_VISION_DONE.Set = true;

				//if (smProductSetting->EnableVisionWaitResult == true)
				{
					if (smProductEvent->GGUI_RSEQ_DRY_RUN_MODE.Set == true)
					{
						smProductSetting->S3Vision[smProductProduction->CurrentS3VisionLoopNo].Result = 1;
					}
					if (smProductEvent->ReviewMode.Set == true)
					{
						//if (smProductProduction->PickAndPlacePickUpHeadStationResult[smProductProduction->nCurrentPickupHeadAtS3].S3Result == 1)
						if (smProductSetting->S3Vision[smProductProduction->CurrentS3VisionLoopNo].Result == 1)
						{
							smProductProduction->CurrentS3VisionContinuousFailCount = 0;
						}
						//else if (smProductProduction->PickAndPlacePickUpHeadStationResult[smProductProduction->nCurrentPickupHeadAtS3].S3Result != 1)
						else if (smProductSetting->S3Vision[smProductProduction->CurrentS3VisionLoopNo].Result != 1)
						{
							smProductProduction->CurrentS3VisionContinuousFailCount++;
						}
						//if (smProductSetting->S3VisionContinuousFailCountToTriggerAlarm != 0)
						{
							if (smProductProduction->CurrentS3VisionContinuousFailCount >= 1/*(int)smProductSetting->S3VisionContinuousFailCountToTriggerAlarm*/)
							{
								m_cProductShareVariables->SetAlarm(6724);
							}
						}
					}
				}
				nSequenceNo++;
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("S3Visionseq: S3 Vision sequence Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				m_cLogger->WriteLog("S3Visionseq: S3 Snap Clock Done %ums.\n", lnClockSpan1.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
			{
				if (smProductEvent->GMNL_RMNL_MANUAL_MODE.Set == true)
					smProductEvent->RSEQ_RS3V_START_VISION.Set = false;
				bAlarm = true;
				bRetry = true;
				m_cProductShareVariables->SetAlarm(6705);
				m_cProductIOControl->SetS3VisionSOV(false);
				m_cProductIOControl->SetS3VisionROV(false);
				nSequenceNo = 0;
				m_cLogger->WriteLog("S3Visionseq: S3 Vision result timeout.\n");
				if (m_cProductIOControl->IsS3VisionEndOfVision() == false)
				{
					m_cLogger->WriteLog("S3Visionseq: S3 Vision end of vision not on.\n");
				}
				if (smProductEvent->GMAIN_RS3V_GET_VISION_RESULT_DONE.Set == false)
				{
					m_cLogger->WriteLog("S3Visionseq: S3 Vision no receive result.\n");
				}
				smProductEvent->RS3V_GMAIN_S3_VISION_RESET_EOV.Set = true;
			}
			break;
		default:
			return -1;
			break;
		}
		//End of sequence
		if (nSequenceNo == 8)
		{
			nSequenceNo = 0;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cLogger->WriteLog("S3Visionseq: S3 Vision sequence thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_S3_VISION_END.Set = true;
	return 0;
}
#pragma endregion

#pragma region Sequence Thread
ULONG CProductThread::InputTrayTableSequenceThread(void * nContext)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Input Tray Table sequence thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->GPCS_RSEQ_ABORT.Set == true)
		{
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			continue;
		}
		nError = m_cProductSequence->InputTrayTableSequence();
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error during run Input Tray Table sequence %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//m_cProductShareVariables->SetAlarm(4401);
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Input Tray Table sequence thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_INPUT_TRAY_TABLE_END.Set = true;
	return 0;
}
ULONG CProductThread::OutputAndRejectTrayTableSequenceThread(void * nContext)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Output Tray Table sequence thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->GPCS_RSEQ_ABORT.Set == true)
		{
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			continue;
		}
		nError = m_cProductSequence->OutputAndRejectTrayTableSequence();
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error during run Output Tray Table sequence %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//m_cProductShareVariables->SetAlarm(4401);
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Output Tray Table sequence thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_OUTPUT_TRAY_TABLE_END.Set = true;
	return 0;
}
ULONG CProductThread::PickAndPlaceSequenceThread(void * nContext)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Pick And Place 1 sequence thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->GPCS_RSEQ_ABORT.Set == true)
		{
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			continue;
		}
		nError = m_cProductSequence->PickAndPlace1Sequence();
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error during run Pick And Place 1 sequence %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//m_cProductShareVariables->SetAlarm(4401);
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Pick And Place sequence thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_PICK_AND_PLACE_SEQUENCE_END.Set = true;
	return 0;
}
ULONG CProductThread::PickAndPlace2SequenceThread(void * nContext)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Pick And Place 2 sequence thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->GPCS_RSEQ_ABORT.Set == true)
		{
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			continue;
		}
		nError = m_cProductSequence->PickAndPlace2Sequence();
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error during run Pick And Place 2 sequence %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//m_cProductShareVariables->SetAlarm(4401);
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Pick And Place sequence thread %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_PICK_AND_PLACE2_SEQUENCE_END.Set = true;
	return 0;
}
#pragma endregion

ULONG CProductThread::CheckRejectReplaceThread(void * nContext)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Check Reject Replace sequence thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->ROUT_RTHD_REPLACE_REJECT_TRAY_START.Set==true)
		{
			smProductEvent->ROUT_RTHD_REPLACE_REJECT_TRAY_START.Set = false;
			while (smProductEvent->ExitRTX.Set == false)
			{
				if (m_cProductIOControl->IsRejectTrayPresentSensorOn() == true)
				{
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
					continue;
				}
				else
				{
					m_cLogger->WriteLog("CheckRejectReplaceThread: Remove reject tray done when tray full.");
					break;
				}
			}
			while (smProductEvent->ExitRTX.Set == false)
			{
				if (m_cProductIOControl->IsRejectTrayPresentSensorOn() == false)
				{
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
					continue;
				}
				else
				{
					smProductEvent->ROUT_RTHD_REPLACE_REJECT_TRAY_DONE.Set = true;
					m_cLogger->WriteLog("CheckRejectReplaceThread: replace reject tray 1 done when tray full.");
					break;
				}
			}
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Check Reject Replace sequence %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_CHECK_REJECT_REPLACE_END.Set = true;
	return 0;
}

ULONG CProductThread::CheckRejectRemoveThread(void * nContext)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	m_cLogger->WriteLog("Check Reject Remove sequence thread start.\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	while (smProductEvent->ExitRTX.Set == false)
	{
		if (smProductEvent->ROUT_RTHD_REMOVE_REJECT_TRAY_START.Set == true)
		{
			smProductEvent->ROUT_RTHD_REMOVE_REJECT_TRAY_START.Set = false;
			while (smProductEvent->ExitRTX.Set == false)
			{
				if (m_cProductIOControl->IsRejectTrayPresentSensorOn() == true)
				{
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
					continue;
				}
				else
				{
					smProductEvent->ROUT_RTHD_REMOVE_REJECT_TRAY_DONE.Set = true;
					m_cLogger->WriteLog("CheckRejectRemoveThread: Remove reject tray done.");
					break;
				}
			}
		}
		if (smProductEvent->RPNP1_ROUT_THREAD_AWAY_OUTPUT.Set == true)
		{
			double MotorEncoderPNP1X = m_cProductMotorControl->ReadAgitoMotorPosition(0, 0, 0);
			if (MotorEncoderPNP1X >= smProductTeachPoint->PickAndPlace1XAxisAwayOutputPosition)
			{
				smProductEvent->RPNP1_ROUT_THREAD_AWAY_OUTPUT.Set = false;
				smProductProduction->bPNP1AllowS2S3Snap = true;
				//smProductEvent->RSEQ_ROUT_PNP_AWAY_FROM_OUTPUT_STATION_DONE.Set = true;
			}
		}
		if (smProductEvent->RPNP2_ROUT_THREAD_AWAY_OUTPUT.Set == true)
		{
			double MotorEncoderPNP2X = m_cProductMotorControl->ReadAgitoMotorPosition(1, 0, 0);
			if (MotorEncoderPNP2X >= smProductTeachPoint->PickAndPlace2XAxisAwayOutputPosition)
			{
				smProductEvent->RPNP2_ROUT_THREAD_AWAY_OUTPUT.Set = false;
				smProductProduction->bPNP2AllowS2S3Snap = true;
				//smProductEvent->RSEQ_ROUT_PNP_AWAY_FROM_OUTPUT_STATION_DONE.Set = true;
			}
		}
		if (smProductEvent->RPNP1_ROUT_THREAD_AWAY_INPUT.Set == true)
		{
			double MotorEncoderPNP1X = m_cProductMotorControl->ReadAgitoMotorPosition(0, 0, 0);
			if (MotorEncoderPNP1X <= smProductTeachPoint->PickAndPlace1XAxisAwayInputPosition)
			{
				smProductEvent->RPNP1_ROUT_THREAD_AWAY_INPUT.Set = false;
				smProductProduction->bAllowInputSnap = true;
				//smProductEvent->RSEQ_ROUT_PNP_AWAY_FROM_OUTPUT_STATION_DONE.Set = true;
			}
		}
		if (smProductEvent->RPNP2_ROUT_THREAD_AWAY_INPUT.Set == true)
		{
			double MotorEncoderPNP2X = m_cProductMotorControl->ReadAgitoMotorPosition(1, 0, 0);
			if (MotorEncoderPNP2X <= smProductTeachPoint->PickAndPlace2XAxisAwayInputPosition)
			{
				smProductEvent->RPNP2_ROUT_THREAD_AWAY_INPUT.Set = false;
				smProductProduction->bAllowInputSnap = true;
				//smProductEvent->RSEQ_ROUT_PNP_AWAY_FROM_OUTPUT_STATION_DONE.Set = true;
			}
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	m_cLogger->WriteLog("Check Reject Remove sequence %d Shutting Down\n", GetCurrentThreadId());
	smProductEvent->RTHD_RMAIN_CHECK_REJECT_REMOVE_END.Set = true;
	return 0;
}

int CProductThread::SequenceThreadInitializeSequence()
{
	int nError = 0;

	nError = m_cProductSequence->InitializeSequence();
	return nError;
}

int CProductThread::SequenceThreadHomeSequence()
{
	int nError = 0;

	nError = m_cProductSequence->HomeSequence();
	return nError;
}

int CProductThread::SequenceThreadSetupSequence()
{
	int nError = 0;

	nError = m_cProductSequence->SetupSequence();
	return nError;
}

int CProductThread::SequenceThreadJobSequence()
{
	int nError = 0;

	nError = m_cProductSequence->JobSequence();
	return nError;
}

int CProductThread::SequenceThreadEndingSequence()
{
	int nError = 0;

	nError = m_cProductSequence->EndingSequence();
	return nError;
}

int CProductThread::SequenceThreadMaintenanceSequence()
{
	int nError = 0;

	nError = m_cProductSequence->MaintenanceSequence();
	return nError;
}

int CProductThread::IOScanThreadSetOutputBeforeExitSoftwareAndDisconnect()
{
	int nError = 0;

	m_cProductIOControl->SetOutputBeforeExitSoftware();
	return nError;
}

int CProductThread::IOOperationThreadOnStart()
{
	int nError = 0;
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStartTriggerStartButton);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStartTriggerStopButton);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStartTriggerResetButton);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStartTakeTHKValue);
	return nError;
}

int CProductThread::IOOperationThreadWhileInJobMode()
{
	int nError = 0;

	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	RtGetClockTime(CLOCK_FASTEST, &lnClockResetButtonEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStartTriggerStartButton.QuadPart;
	if (m_cProductIOControl->IsStartButtonPressed() == true && (lnClockEnd.QuadPart - lnClockPeriodTriggerStartButton.QuadPart) / m_cProductShareVariables->m_TimeCount > 100 && lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 1500)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockStartTriggerStartButton);
		m_cLogger->WriteLog("User press start button.\n");
		//if (m_cProductStateControl->IsCurrentStateCanTriggerResume() == true)
		if (m_cProductStateControl->IsCurrentStateCanTriggerResume() == true )
		{
			smProductEvent->StartJob.Set = true;
		}
	}
	else if (m_cProductIOControl->IsStartButtonPressed() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockPeriodTriggerStartButton);
	}

	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStartTriggerStopButton.QuadPart;
	if (m_cProductIOControl->IsStopButtonPressed() == true && smProductGeneral->nLoginAuthority > 1 && (lnClockEnd.QuadPart - lnClockPeriodTriggerStopButton.QuadPart) / m_cProductShareVariables->m_TimeCount > 100 && lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 1500)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockStartTriggerStopButton);
		m_cLogger->WriteLog("User press stop button.\n");

		if (m_cProductStateControl->IsCurrentStateCanTriggerPause() == true)
			smProductEvent->StartPause.Set = true;
	}
	else if (m_cProductIOControl->IsStopButtonPressed() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockPeriodTriggerStopButton);
	}

	//lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStartTriggerResetButton.QuadPart;
	lnClockResetButtonSpan.QuadPart = lnClockResetButtonEnd.QuadPart - lnClockStartTriggerResetButton.QuadPart;
	//if (m_cProductIOControl->IsResetButtonPressed() == true)
	//{
	//	m_cLogger->WriteLog("Trigger reset button.\n");
	//}
	if (m_cProductIOControl->IsResetButtonPressed() == true && (lnClockResetButtonEnd.QuadPart - lnClockPeriodTriggerResetButton.QuadPart) / m_cProductShareVariables->m_TimeCount > 100 && lnClockResetButtonSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 1500)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockStartTriggerResetButton);
		m_cLogger->WriteLog("User press reset button.\n");
		smProductEvent->StartReset.Set = true;
	}
	else if (m_cProductIOControl->IsResetButtonPressed() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockPeriodTriggerResetButton);
	}

	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStartTakeTHKValue.QuadPart;
	if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 1000)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockStartTakeTHKValue);
		//m_cLogger->WriteLog("Start Take THK value.\n");
		if (smProductSetting->EnablePH[0] == true)
		{
			m_cProductMotorControl->THKReadPressureValue(0, &smProductProduction->THK1CurrentPressureValue);
			m_cProductMotorControl->THKReadForceValue(0, &smProductProduction->THK1CurrentForceValue);
			m_cProductMotorControl->THKReadFlowRateValue(0, &smProductProduction->THK1CurrentFlowRate);
		}
		if (smProductSetting->EnablePH[1] == true)
		{
			m_cProductMotorControl->THKReadPressureValue(1, &smProductProduction->THK2CurrentPressureValue);
			m_cProductMotorControl->THKReadForceValue(1, &smProductProduction->THK2CurrentForceValue);
			m_cProductMotorControl->THKReadFlowRateValue(1, &smProductProduction->THK2CurrentFlowRate);
		}
	}

	if (smProductGeneral->State == m_cProductStateControl->HomingState || smProductGeneral->State == m_cProductStateControl->PreProductioningState || smProductGeneral->State == m_cProductStateControl->ProductioningState || smProductGeneral->State == m_cProductStateControl->PostProductioningState)
	{
		if (!(smProductGeneral->State == m_cProductStateControl->HomingState || smProductGeneral->State == m_cProductStateControl->PreProductionStartState || smProductGeneral->State == m_cProductStateControl->PreProductioningState)
			&& smProductEvent->JobStart.Set == true && m_cProductIOControl->IsPNP1VacuumSwitchReady() == false)
		
		{
			m_cProductShareVariables->SetAlarm(5015);
			m_cLogger->WriteLog("Pick And Place 1 Vacuum switch not ready.\n");
		}
		if (!(smProductGeneral->State == m_cProductStateControl->HomingState || smProductGeneral->State == m_cProductStateControl->PreProductionStartState || smProductGeneral->State == m_cProductStateControl->PreProductioningState)
			&& smProductEvent->JobStart.Set == true && m_cProductIOControl->IsPNP2VacuumSwitchReady() == false)

		{
			m_cProductShareVariables->SetAlarm(5016);
			m_cLogger->WriteLog("Pick And Place 2 Vacuum switch not ready.\n");
		}
		
	}
	return nError;
}

int CProductThread::IOOperationThreadOnTriggerOutput()
{
	int nError = 0;
	m_cIO->UpdateAllOutput(smProductIO->nArrayOutput);
	return nError;
}

int CProductThread::IOOperationThreadInAllMode()
{
	int nError = 0;

	return nError;
}

int CProductThread::OnUpdateSetting()
{
	int nError = 0;

	return nError;
}

int CProductThread::OnTeachPointThreadMotorOff(int axis)
{
	int nError = 0;

	if (smProductGeneral->nTeachPointMotorType == 0)
	{
#pragma region Fuji Control
		if (smProductGeneral->nTeachPointAxis == 101) //Input Tray Table X Axis Motor
		{
			nError = m_cProductMotorControl->InputTrayTableXAxisMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table X Axis Motor off");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 102)//Input Tray Table Y Axis Motor
		{
			nError = m_cProductMotorControl->InputTrayTableYAxisMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Y Axis Motor off");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 103)//Input Tray Table Z Axis Motor
		{
			nError = m_cProductMotorControl->InputTrayTableZAxisMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Z Axis Motor off");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 104)//Output Tray Table X Axis Motor
		{
			nError = m_cProductMotorControl->OutputTrayTableXAxisMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table X Axis Motor off");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 105)//Output Tray Table Y Axis Motor
		{
			nError = m_cProductMotorControl->OutputTrayTableYAxisMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Y Axis Motor off");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 106)//Output Tray Table Z Axis Motor
		{
			nError = m_cProductMotorControl->OutputTrayTableZAxisMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Z Axis Motor off");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 107)//Pick And Place 1 X Axis Motor
		{
			nError = m_cProductMotorControl->PickAndPlace1XAxisMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 X Axis Motor off");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 108)//Pick And Place 1 Y Axis Motor
		{
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Y Axis Motor off");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 109)//Pick And Place 1 Z Axis Motor
		{
			nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis Motor off");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 110)//Pick And Place 1 T Axis Motor
		{
			nError = m_cProductMotorControl->PickAndPlace1ThetaAxisMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Theta Axis Motor off");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 111)//Pick And Place 2 X Axis Motor
		{
			nError = m_cProductMotorControl->PickAndPlace2XAxisMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 X Axis motor off");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 112)//Pick And Place 2 Y Axis Motor
		{
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Y Axis Motor off");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 113)//Pick And Place 2 Z Axis
		{
			nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis motor off");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 114)//Pick And Place 2 T Axis Motor
		{
			nError = m_cProductMotorControl->PickAndPlace2ThetaAxisMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Theta Axis Motor off");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 115)//Input Vision Z Axis
		{
			nError = m_cProductMotorControl->InputVisionModuleMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Vision module motor off");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 116)//S2 Vision
		{
			nError = m_cProductMotorControl->S2VisionModuleMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S2 Vision module motor off");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 117)//S1 Vision
		{
			nError = m_cProductMotorControl->S1VisionModuleMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S1 Vision Module motor off");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 121)//S3 Vision Axis
		{
			nError = m_cProductMotorControl->S3VisionModuleMotorOff(m_cMotion);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S3 Vision Module motor off");
			}
		}
#pragma endregion
	}
	return nError;
}

int CProductThread::OnTeachPointThreadMotorOn(int axis)
{
	int nError = 0;
	if (smProductEvent->GTCH_RTCH_MOTOR_ON.Set == true)
	{
		if (smProductGeneral->nTeachPointMotorType == 0)
		{

#pragma region Fuji Control
			if (smProductGeneral->nTeachPointAxis == 101) //Input Tray Table X Axis Motor
			{
				nError = m_cProductMotorControl->InputTrayTableXAxisMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table X Axis Motor on");
				}
			}
			else if (smProductGeneral->nTeachPointAxis == 102)//Input Tray Table Y Axis Motor
			{
				nError = m_cProductMotorControl->InputTrayTableYAxisMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Y Axis Motor on");
				}
			}
			else if (smProductGeneral->nTeachPointAxis == 103)//Input Tray Table Z Axis Motor
			{
				nError = m_cProductMotorControl->InputTrayTableZAxisMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Z Axis Motor on");
				}
			}
			else if (smProductGeneral->nTeachPointAxis == 104)//Output Tray Table X Axis Motor
			{
				nError = m_cProductMotorControl->OutputTrayTableXAxisMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table X Axis Motor on");
				}
			}
			else if (smProductGeneral->nTeachPointAxis == 105)//Output Tray Table Y Axis Motor
			{
				nError = m_cProductMotorControl->OutputTrayTableYAxisMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Y Axis Motor on");
				}
			}
			else if (smProductGeneral->nTeachPointAxis == 106)//Output Tray Table Z Axis Motor
			{
				nError = m_cProductMotorControl->OutputTrayTableZAxisMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Z Axis Motor on");
				}
			}
			else if (smProductGeneral->nTeachPointAxis == 107)//Pick And Place 1 X Axis Motor
			{
				nError = m_cProductMotorControl->PickAndPlace1XAxisMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 X Axis Motor on");
				}
			}
			else if (smProductGeneral->nTeachPointAxis == 108)//Pick And Place 1 Y Axis Motor
			{
				nError = m_cProductMotorControl->PickAndPlace1YAxisMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Y Axis Motor on");
				}
			}
			else if (smProductGeneral->nTeachPointAxis == 109)//Pick And Place 1 Z Axis Motor
			{
				nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis Motor on");
				}
			}
			else if (smProductGeneral->nTeachPointAxis == 110)//Pick And Place 1 T Axis Motor
			{
				nError = m_cProductMotorControl->PickAndPlace1ThetaAxisMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Theta Axis Motor on");
				}
			}
			else if (smProductGeneral->nTeachPointAxis == 111)//Pick And Place 2 X Axis Motor
			{
				nError = m_cProductMotorControl->PickAndPlace2XAxisMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 X Axis motor on");
				}
			}
			else if (smProductGeneral->nTeachPointAxis == 112)//Pick And Place 2 Y Axis Motor
			{
				nError = m_cProductMotorControl->PickAndPlace2YAxisMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Y Axis Motor on");
				}
			}
			else if (smProductGeneral->nTeachPointAxis == 113)//Pick And Place 2 Z Axis
			{
				nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis motor on");
				}
			}
			else if (smProductGeneral->nTeachPointAxis == 114)//Pick And Place 2 T Axis Motor
			{
				nError = m_cProductMotorControl->PickAndPlace2ThetaAxisMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Theta Axis Motor on");
				}
			}
			else if (smProductGeneral->nTeachPointAxis == 115)//Input Vision Z Axis
			{
				nError = m_cProductMotorControl->InputVisionModuleMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Vision module motor on");
				}
			}
			else if (smProductGeneral->nTeachPointAxis == 116)//S2 Vision
			{
				nError = m_cProductMotorControl->S2VisionModuleMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S2 Vision module motor on");
				}
			}
			else if (smProductGeneral->nTeachPointAxis == 117)//S1
			{
				nError = m_cProductMotorControl->S1VisionModuleMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S1 Vision Module motor on");
				}
			}
			else if (smProductGeneral->nTeachPointAxis == 121)//S3 Vision Axis
			{
				nError = m_cProductMotorControl->S3VisionModuleMotorOn(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S3 Vision Module motor on");
				}
			}
#pragma endregion
		}
		smProductEvent->GTCH_RTCH_MOTOR_ON.Set = false;
	}
	return nError;
}

int CProductThread::OnTeachPointThreadMotorHome(int axis)
{
	int nError = 0;
	if (smProductGeneral->nTeachPointMotorType == 0)
	{
#pragma region Fuji Control
		if (smProductGeneral->nTeachPointAxis == 101) //Input Tray Table X Axis Motor
		{
			if (m_cProductMotorControl->IsInputTrayTableXAxisMotorSafeToMove() == true)
			{
				nError = m_cProductMotorControl->InputTrayTableXAxisMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table X Axis Motor Home");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 102)//Input Tray Table Y Axis Motor
		{
			if (m_cProductMotorControl->IsInputTrayTableYAxisMotorSafeToMove() == true)
			{
				nError = m_cProductMotorControl->InputTrayTableYAxisMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Y Axis Motor Home");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 103)//Input Tray Table Z Axis Motor
		{
			//if (m_cProductMotorControl->IsInputTrayTableZAxisMotorSafeToMove() == true)
			//{
				nError = m_cProductMotorControl->InputTrayTableZAxisMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Z Axis Motor Home");
				}
			//}
		}
		else if (smProductGeneral->nTeachPointAxis == 104)//Output Tray Table X Axis Motor
		{
			if (m_cProductMotorControl->IsOutputTrayTableXAxisMotorSafeToMove() == true)
			{
				nError = m_cProductMotorControl->OutputTrayTableXAxisMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table X Axis Motor Home");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 105)//Output Tray Table Y Axis Motor
		{
			if (m_cProductMotorControl->IsOutputTrayTableYAxisMotorSafeToMove() == true)
			{
				nError = m_cProductMotorControl->OutputTrayTableYAxisMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Y Axis Motor Home");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 106)//Output Tray Table Z Axis Motor
		{
			//if (m_cProductMotorControl->IsOutputTrayTableZAxisMotorSafeToMove() == true)
			//{
				nError = m_cProductMotorControl->OutputTrayTableZAxisMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Z Axis Motor Home");
				}
			//}
		}
		else if (smProductGeneral->nTeachPointAxis == 107)//Pick And Place 1 X Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace1XAxisMotorSafeToMove() == true)
			{
				nError = m_cProductMotorControl->PickAndPlace1XAxisMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 X Axis Motor Home");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 108)//Pick And Place 1 Y Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace1YAxisMotorSafeToMove() == true)
			{
				nError = m_cProductMotorControl->PickAndPlace1YAxisMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Y Axis Motor Home");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 109)//Pick And Place 1 Z Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace1ZAxisMotorSafeToMove() == true)
			{
				nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis Motor Home");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 110)//Pick And Place 1 T Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace1ThetaAxisMotorSafeToMove() == true)
			{
				nError = m_cProductMotorControl->PickAndPlace1ThetaAxisMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Theta Axis Motor Home");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 111)//Pick And Place 2 X Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace2XAxisMotorSafeToMove() == true)
			{
				nError = m_cProductMotorControl->PickAndPlace2XAxisMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 X Axis motor Home");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 112)//Pick And Place 2 Y Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace2YAxisMotorSafeToMove() == true)
			{
				nError = m_cProductMotorControl->PickAndPlace2YAxisMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Y Axis Motor Home");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 113)//Pick And Place 2 Z Axis
		{
			if (m_cProductMotorControl->IsPickAndPlace2ZAxisMotorSafeToMove() == true)
			{
				nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis motor Home");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 114)//Pick And Place 2 T Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace2ThetaAxisMotorSafeToMove() == true)
			{
				nError = m_cProductMotorControl->PickAndPlace2ThetaAxisMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Theta Axis Motor Home");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 115)//Input Vision Z Axis
		{
			if (m_cProductMotorControl->IsInputVisionModuleMotorSafeToMove() == true)
			{
				nError = m_cProductMotorControl->InputVisionModuleMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Vision module motor Home");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 116)//S2 Vision
		{
			if (m_cProductMotorControl->IsS2VisionModuleMotorSafeToMove() == true)
			{
				nError = m_cProductMotorControl->S2VisionModuleMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S2 Vision module motor Home");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 117)//Sidewall Left
		{
			if (m_cProductMotorControl->IsS1VisionModuleMotorSafeToMove() == true)
			{
				nError = m_cProductMotorControl->S1VisionModuleMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S1 Vision Module motor Home");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 121)//S3 Vision Axis
		{
			if (m_cProductMotorControl->IsS3VisionModuleMotorSafeToMove() == true)
			{
				nError = m_cProductMotorControl->S3VisionModuleMotorHome(m_cMotion);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S3 Vision Module motor Home");
				}
			}
		}
#pragma endregion
	}
	return nError;
}

int CProductThread::OnTeachPointThreadMotorMoveRelative(int axis, signed long position)
{
	int nError = 0;
	if (smProductGeneral->nTeachPointMotorType == 0)
	{
		#pragma region Fuji Control
		if (smProductGeneral->nTeachPointAxis == 101) //Input Tray Table X Axis Motor
		{
			if (m_cProductMotorControl->IsInputTrayTableXAxisMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->InputTrayTableXAxisMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table X Axis Motor Move to relative position");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 102)//Input Tray Table Y Axis Motor
		{
			if (m_cProductMotorControl->IsInputTrayTableYAxisMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->InputTrayTableYAxisMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Y Axis Motor Move to Relative Position");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 103)//Input Tray Table Z Axis Motor
		{
			if (m_cProductMotorControl->IsInputTrayTableZAxisMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->InputTrayTableZAxisMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Z Axis Motor Move To Relative Position");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 104)//Output Tray Table X Axis Motor
		{
			if (m_cProductMotorControl->IsOutputTrayTableXAxisMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->OutputTrayTableXAxisMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table X Axis Motor Move To Relative Position");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 105)//Output Tray Table Y Axis Motor
		{
			if (m_cProductMotorControl->IsOutputTrayTableYAxisMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->OutputTrayTableYAxisMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Y Axis Motor Move To Relative Position");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 106)//Output Tray Table Z Axis Motor
		{
			if (m_cProductMotorControl->IsOutputTrayTableZAxisMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition+ smGeneral->nMotorEncoderPosition) == true)
			{
				nError = m_cProductMotorControl->OutputTrayTableZAxisMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Z Axis Motor Move To Relative Position");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 107)//Pick And Place 1 X Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace1XAxisMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->PickAndPlace1XAxisMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 X Axis Motor Move To Relative Position");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 108)//Pick And Place 1 Y Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace1YAxisMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Y Axis Motor Move To Relative Position");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 109)//Pick And Place 1 Z Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace1ZAxisMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis Motor Move To Relative Position");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 110)//Pick And Place 1 T Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace1ThetaAxisMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->PickAndPlace1ThetaAxisMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 T Axis Motor Move To Relative Position");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 111)//Pick And Place 2 X Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace2XAxisMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->PickAndPlace2XAxisMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 X Axis motor Move To Relative Position");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 112)//Pick And Place 2 Y Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace2YAxisMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Y Axis Motor Move To Relative Position");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 113)//Pick And Place 2 Z Axis
		{
			if (m_cProductMotorControl->IsPickAndPlace2ZAxisMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis motor Move To Relative Position");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 114)//Pick And Place 2 T Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace2ThetaAxisMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->PickAndPlace2ThetaAxisMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 T Axis Motor Move To Relative Position");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 115)//Input Vision Z Axis
		{
			if (m_cProductMotorControl->IsInputVisionModuleMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->InputVisionModuleMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Vision module motor move to relative position");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 116)//S2 Vision
		{
			if (m_cProductMotorControl->IsS2VisionModuleMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->S2VisionModuleMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S2 Vision module motor move to relative position");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 117)//S1 Vision
		{
			if (m_cProductMotorControl->IsS1VisionModuleMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->S1VisionModuleMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S1 Vision Module motor move to relative position");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 121)//S3 Vision Axis
		{
			if (m_cProductMotorControl->IsS3VisionModuleMotorSafeToMoveRelative(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->S3VisionModuleMotorMoveRelative(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S3 Vision Module motor move to relative position");
				}
			}
		}
#pragma endregion
	}
	return nError;
}

int CProductThread::OnTeachPointThreadMotorMoveAbsolute(int axis, signed long position)
{
	int nError = 0;
	if (smProductGeneral->nTeachPointMotorType == 0)
	{
		#pragma region Fuji Control
		if (smProductGeneral->nTeachPointAxis == 101) //Input Tray Table X Axis Motor
		{
			if (m_cProductMotorControl->IsInputTrayTableXAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->InputTrayTableXAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table X Axis Motor Move to absolute position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor Move to absolute position done.");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 102)//Input Tray Table Y Axis Motor
		{
			if (m_cProductMotorControl->IsInputTrayTableYAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->InputTrayTableYAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Y Axis Motor Move to absolute Position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor Move to absolute Position Done.");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 103)//Input Tray Table Z Axis Motor
		{
			if (m_cProductMotorControl->IsInputTrayTableZAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->InputTrayTableZAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Z Axis Motor Move To Absolute Position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor Move To Absolute Position Done");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 104)//Output Tray Table X Axis Motor
		{
			if (m_cProductMotorControl->IsOutputTrayTableXAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->OutputTrayTableXAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table X Axis Motor Move To Absolute Position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor Move To Absolute Position Done");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 105)//Output Tray Table Y Axis Motor
		{
			if (m_cProductMotorControl->IsOutputTrayTableYAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->OutputTrayTableYAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Y Axis Motor Move To Absolute Position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor Move To Absolute Position Done");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 106)//Output Tray Table Z Axis Motor
		{
			if (m_cProductMotorControl->IsOutputTrayTableZAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->OutputTrayTableZAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Z Axis Motor Move To Absolute Position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor Move To Absolute Position Done");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 107)//Pick And Place 1 X Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace1XAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->PickAndPlace1XAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 X Axis Motor Move To Absolute Position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor Move To Absolute Position Done");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 108)//Pick And Place 1 Y Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace1YAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Y Axis Motor Move To Absolute Position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor Move To Absolute Position Done");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 109)//Pick And Place 1 Z Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace1ZAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis Motor Move To Absolute Position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis Motor Move To Absolute Position Done");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 110)//Pick And Place 1 T Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace1ThetaAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->PickAndPlace1ThetaAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 T Axis Motor Move To Absolute Position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 T Axis Motor Move To Absolute Position Done");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 111)//Pick And Place 2 X Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace2XAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->PickAndPlace2XAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 X Axis motor Move To Absolute Position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor Move To Absolute Position Done");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 112)//Pick And Place 2 Y Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace2YAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Y Axis Motor Move To Absolute Position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor Move To Absolute Position Done");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 113)//Pick And Place 2 Z Axis
		{
			if (m_cProductMotorControl->IsPickAndPlace2ZAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis motor Move To Absolute Position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor Move To Absolute Position Done.");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 114)//Pick And Place 2 T Axis Motor
		{
			if (m_cProductMotorControl->IsPickAndPlace2ThetaAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->PickAndPlace2ThetaAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 T Axis Motor Move To Absolute Position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 T Axis Motor Move To Absolute Position Done");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 115)//Input Vision Z Axis
		{
			if (m_cProductMotorControl->IsInputVisionModuleMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->InputVisionModuleMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Vision module motor move to Absolute position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision module motor move to Absolute position Done");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 116)//S2 Vision
		{
			if (m_cProductMotorControl->IsS2VisionModuleMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->S2VisionModuleMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S2 Vision module motor move to Absolute position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision module motor move to Absolute position Done");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 117)//S1
		{
			if (m_cProductMotorControl->IsS1VisionModuleMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->S1VisionModuleMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S1 Vision Module motor move to Absolute position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor move to Absolute position Done");
				}
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 121)//S3 Vision Axis
		{
			if (m_cProductMotorControl->IsS3VisionModuleMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			{
				nError = m_cProductMotorControl->S3VisionModuleMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
				if (nError != 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S3 Vision Module motor move to Absolute position");
				}
				else if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor move to Absolute position done");
				}
			}
		}
#pragma endregion
	}
	return nError;
}

int CProductThread::OnTeachPointThreadMotorSetSpeedAndAcceleration(int axis, int speedPercent, int acceleration, int deceleration)
{
	int nError = 0;
	if (smProductGeneral->nTeachPointMotorType == 0)
	{
#pragma region Fuji Control
		if (smProductGeneral->nTeachPointAxis == 101) //Input Tray Table X Axis Motor
		{
			nError = m_cProductMotorControl->InputTrayTableXAxisMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table X Axis Motor Set Speed And Acceleration");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 102)//Input Tray Table Y Axis Motor
		{
			nError = m_cProductMotorControl->InputTrayTableYAxisMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Y Axis Motor Set Speed And Acceleration");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 103)//Input Tray Table Z Axis Motor
		{
			nError = m_cProductMotorControl->InputTrayTableZAxisMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Z Axis Motor Set Speed And Acceleration");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 104)//Output Tray Table X Axis Motor
		{
			nError = m_cProductMotorControl->OutputTrayTableXAxisMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table X Axis Motor Set Speed And Acceleration");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 105)//Output Tray Table Y Axis Motor
		{
			nError = m_cProductMotorControl->OutputTrayTableYAxisMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Y Axis Motor Set Speed And Acceleration");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 106)//Output Tray Table Z Axis Motor
		{
			nError = m_cProductMotorControl->OutputTrayTableZAxisMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Z Axis Motor Set Speed And Acceleration");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 107)//Pick And Place 1 X Axis Motor
		{
			nError = m_cProductMotorControl->PickAndPlace1XAxisMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 X Axis Motor Set Speed And Acceleration");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 108)//Pick And Place 1 Y Axis Motor
		{
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Y Axis Motor Set Speed And Acceleration");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 109)//Pick And Place 1 Z Axis Motor
		{
			nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis Motor Set Speed And Acceleration");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 110)//Pick And Place 1 T Axis Motor
		{
			nError = m_cProductMotorControl->PickAndPlace1ThetaAxisMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 T Axis Motor Set Speed And Acceleration");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 111)//Pick And Place 2 X Axis Motor
		{
			nError = m_cProductMotorControl->PickAndPlace2XAxisMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 X Axis motor Set Speed And Acceleration");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 112)//Pick And Place 2 Y Axis Motor
		{
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Y Axis Motor Set Speed And Acceleration");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 113)//Pick And Place 2 Z Axis
		{
			nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis motor Set Speed And Acceleration");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 114)//Pick And Place 2 T Axis Motor
		{
			nError = m_cProductMotorControl->PickAndPlace2ThetaAxisMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 T Axis Motor Set Speed And Acceleration");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 115)//Input Vision Z Axis
		{
			nError = m_cProductMotorControl->InputVisionModuleMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Vision module motor Set Speed And Acceleration");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 116)//S2 Vision
		{
			nError = m_cProductMotorControl->S2VisionModuleMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S2 Vision module motor Set Speed And Acceleration");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 117)//S1
		{
			nError = m_cProductMotorControl->S1VisionModuleMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S1 Vision Module motor Set Speed And Acceleration");
			}
		}
		else if (smProductGeneral->nTeachPointAxis == 121)//S3 Vision Axis
		{
			nError = m_cProductMotorControl->S3VisionModuleMotorSetSpeedAndAcceleration(m_cMotion, smProductGeneral->nMotorSpeedPercent, smProductGeneral->nMotorAccelerationPercent);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S3 Vision Module motor Set Speed And Acceleration");
			}
		}
#pragma endregion
	}
	return nError;
}

int CProductThread::OnTeachPointThreadMotorSemiAutoTeach(int axis, int number)
{
	LARGE_INTEGER lnClockStartSemi, lnClockEndSemi, lnClockSpanSemi, lnClockStartSemi2;
	int nError = 0;
	int nSequenceNo = 1;
	if (smProductGeneral->nTeachPointMotorType == 0)
	{
#pragma region Fuji Motor
		if (smProductGeneral->nTeachPointAxis == 101 || smProductGeneral->nTeachPointAxis == 102) //Input Table X Axis Center Position
		{
			//if (IsInputTableXAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			//{
			//	nError = InputTableXAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
			//	if (nError != 0)
			//	{
			//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Table X Axis motor move Absolute");
			//	}
			//}
		}
		//else if (smProductGeneral->nTeachPointAxis == 102) //Input Table Y Axis Center Position
		//{
		//	//if (IsInputTableYAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
		//	//{
		//	//	nError = InputTableYAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
		//	//	if (nError != 0)
		//	//	{
		//	//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Table Y Axis motor Move Absolute");
		//	//	}
		//	//}
		//}
		else if (smProductGeneral->nTeachPointAxis == 103)
		{
			//if (IsInputTableThetaAxisMotorSafeToMove() == true)
			//{
			//	nError = InputTableThetaAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
			//	if (nError != 0)
			//	{
			//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Table Theta Axis motor Move Absolute");
			//	}
			//}
		}
		else if (smProductGeneral->nTeachPointAxis == 104)
		{
			//if (IsInputTableZAxisMotorSafeToMove() == true)
			//{
			//	nError = InputTableZAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
			//	if (nError != 0)
			//	{
			//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Table Z Axis motor Move Absolute");
			//	}
			//}
		}
		else if (smProductGeneral->nTeachPointAxis == 105)
		{
			//if (IsInputTransferArmMotorSafeToMove() == true)
			//{
			//	nError = InputTransferArmMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
			//	if (nError != 0)
			//	{
			//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Transfer Arm motor Move Absolute");
			//	}
			//}
		}
		else if (smProductGeneral->nTeachPointAxis == 106)
		{
			//if (IsInputElevatorMotorSafeToMove() == true)
			//{
			//	nError = InputElevatorMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
			//	if (nError != 0)
			//	{
			//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error InputElevator motor Move Absolute");
			//	}
			//}
		}
		else if (smProductGeneral->nTeachPointAxis == 107)
		{
			//if (IsPepperPotZAxisMotorSafeToMove() == true)
			//{
			//	nError = PepperPotZAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
			//	if (nError != 0)
			//	{
			//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pepper Pot Z Axis motor Move Absolute");
			//	}
			//}
		}
		else if (smProductGeneral->nTeachPointAxis == 108)
		{
			//if (IsAlignerThetaAxisMotorSafeToMove() == true)
			//{
			//	nError = AlignerThetaAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
			//	if (nError != 0)
			//	{
			//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Aligner Theta Axis motor Move Absolute");
			//	}
			//}
		}
		else if (smProductGeneral->nTeachPointAxis == 109)
		{
			//if (IsOutputTableXAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			//{
			//	nError = OutputTableXAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
			//	if (nError != 0)
			//	{
			//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Table X Axis motor move Absolute");
			//	}
			//}
		}
		else if (smProductGeneral->nTeachPointAxis == 110)
		{
			//if (IsOutputTableYAxisMotorSafeToMoveAbsolute(smProductGeneral->nMotorMovePosition) == true)
			//{
			//	nError = OutputTableYAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
			//	if (nError != 0)
			//	{
			//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Table Y Axis motor Move Absolute");
			//	}
			//}
		}
		else if (smProductGeneral->nTeachPointAxis == 111)
		{
			//if (IsOutputTransferArmMotorSafeToMove() == true)
			//{
			//	nError = OutputTransferArmMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
			//	if (nError != 0)
			//	{
			//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Transfer Arm motor Move Absolute");
			//	}
			//}
		}
		else if (smProductGeneral->nTeachPointAxis == 112)
		{
			//if (IsOutputElevatorMotorSafeToMove() == true)
			//{
			//	nError = OutputElevatorMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
			//	if (nError != 0)
			//	{
			//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Elevator motor Move Absolute");
			//	}
			//}
		}
		else if (smProductGeneral->nTeachPointAxis == 113)
		{
			//if (IsFlipperThetaAxisMotorSafeToMove() == true)
			//{
			//	nError = FlipperThetaAxisMotorMoveAbsolute(m_cMotion, smProductGeneral->nMotorMovePosition);
			//	if (nError != 0)
			//	{
			//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Flipper Theta Axis motor Move Absolute");
			//	}
			//}
		}
#pragma endregion
	}
	return nError;
}

int CProductThread::ManualThreadSwitch(int number)
{
	int nError = 0;
	InputTrayTableSequenceNo nCase;
	int nSequenceNo = nCase.WaitingToReceiveEventStartInputTrayTableSequence;
	OutputTrayTableSequenceNo nCase2;
	int nSequenceNoOutput = nCase2.WaitingToReceiveEventStartOutputAndRejectTrayTableSequence;
	PickAndPlaceSequenceNo nCasePNP;
	int nSequenceNoPNP = nCasePNP.WaitingToReceiveEventStartPickAndPlaceSequence;

	int nSequenceNoPnP1 = 0;
	int nSequenceNoPnP2 = 0;
	int nHeadNo = 1;
	LARGE_INTEGER lnPnPSequenceClockStart, lnPnPSequenceClockEnd, lnPnPSequenceClockSpan, lnPnPSequenceClockStart2, lnPnPSequenceClockStart3, lnDelayIn100ns;
	LONGLONG  lConvert1msTo100ns = 10000;
	bool bTopVisionInspect = false;
	bool bAlignerVisionInspect = false;
	bool bBottomVisionInspect = false;
	bool bSidewallTopBottomVisionInspect = false;
	bool bOutputVisionInspect = false;

	bool bAlignerVisionSendRowColumnInProgress = false;
	bool bBottomVisionSendRowColumnInProgress = false;
	bool bSidewallLeftRightVisionSendRowColumnInProgress = false;
	bool bSidewallTopBottomVisionSendRowColumnInProgress = false;
	bool bOutputVisionSendRowColumnInProgress = false;

	bool bCycleStopDone = false;
	int nPreviousSequence = 0;
	int nRetry = 0;
	bool Retry = false;
	signed long nSidewallLeftVisionYAxisMove;
	signed long nSidewallRightVisionYAxisMove;
	signed long nSidewallTopVisionYAxisMove;
	signed long nSidewallBottomVisionYAxisMove;
	bool IsSidewallLeftVisonWantToMove;
	bool IsSidewallRightVisionWantToMove;
	bool IsSidewallTopVisionWantToMove;
	bool IsSidewallBottomVisionWantToMove;
	int Row = 1;
	int Col = 1;
	signed long test = 0;
	signed long a = 0;
	signed long currentEncoder = 0;
	bool TemporaryDisable = true;
	int InputVisionSequence;
	int nCurrentInputVisionDoneCount;
	int nCurrentS2VisionDoneCount;
	if (smProductGeneral->ManualID == 3101)
	{
		nManuaThreadSequenceNo = true;
		bManualThreadStart = 0;
	}
	int nCurrentDegree = 0;
	bool bIsNeedConitinue = false;
	int nCase1 = 0;
	switch (number)
	{
#pragma region 0 To 8: Input Tray Table X Axis Motor
	case 0://Home
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartInputTrayTableXAxisMotorHome.Set = false;
		if (m_cProductMotorControl->IsInputTrayTableXAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->InputTrayTableXAxisMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->InputTrayTableXAxisMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table X Axis Home %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->InputTrayTableXAxisMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table X Axis motor on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 2://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->InputTrayTableXAxisMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table X Axis motor off %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 3: //Move to input tray stacker load position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartInputTrayTableXAxisMotorMoveLoad.Set = false;
		if (m_cProductMotorControl->IsInputTrayTableXAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->InputTrayTableXAxisMotorMoveLoad(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->InputTrayTableXAxisMotorMoveLoadDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table X Axis Move load %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 4: //Move to input tray stacker unload position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartInputTrayTableXAxisMotorMoveUnload.Set = false;
		if (m_cProductMotorControl->IsInputTrayTableXAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->InputTrayTableXAxisMotorMoveUnload(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->InputTrayTableXAxisMotorMoveUnloadDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table X Axis Move unload %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 5: //Move to input tray table center position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartInputTrayTableXAxisMotorMoveCenter.Set = false;
		if (m_cProductMotorControl->IsInputTrayTableXAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->InputTrayTableXAxisMotorMoveCenter(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->InputTrayTableXAxisMotorMoveCenterDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table X Axis Move Center %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 6:
		if (m_cProductMotorControl->IsInputTrayTableXAxisMotorSafeToMove() == false)
		{
			break;
		}
		bManualThreadStart = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->InputTrayTableXAxisMovePosition = smProductTeachPoint->InputTrayTableXAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->InputTrayTableXAxisMovePosition -= 100;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableXAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->InputTrayTableXAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->InputTrayTableXAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Input Tray Table X Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Input Tray Table X Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 7:
		if (m_cProductMotorControl->IsInputTrayTableXAxisMotorSafeToMove() == false)
		{
			break;
		}
		bManualThreadStart = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->InputTrayTableXAxisMovePosition = smProductTeachPoint->InputTrayTableXAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->InputTrayTableXAxisMovePosition -= 500;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableXAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->InputTrayTableXAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->InputTrayTableXAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Input Tray Table X Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Input Tray Table X Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 8:
		if (m_cProductMotorControl->IsInputTrayTableXAxisMotorSafeToMove() == false)
		{
			break;
		}
		bManualThreadStart = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->InputTrayTableXAxisMovePosition = smProductTeachPoint->InputTrayTableXAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->InputTrayTableXAxisMovePosition -= 1000;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableXAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->InputTrayTableXAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->InputTrayTableXAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Input Tray Table X Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Input Tray Table X Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 10:
		m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Press Input Tray Table X Axis Motor.");

		if (m_cProductMotorControl->IsInputTrayTableXAxisMotorSafeToMove() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Input Tray Table X Axis Motor Not Safe To Move.");
			break;
		}
		smProductProduction->InputTrayTableXAxisMovePosition = smProductTeachPoint->InputTrayTableXAxisAtInputTrayTableCenterPosition + signed long(smProductSetting->DeviceXPitchInput*4.5);

		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->InputTrayTableXAxisMovePosition = smProductTeachPoint->InputTrayTableXAxisAtInputTrayTableCenterPosition + signed long(smProductSetting->DeviceXPitchInput*4.5);
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->InputTrayTableXAxisMovePosition += 10000;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableXAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->InputTrayTableXAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->InputTrayTableXAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Input Tray Table X Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Input Tray Table X Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
#pragma endregion

#pragma region 101-109 : Input Tray Table Y Axis Motor

	case 101://Home
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartInputTrayTableYAxisMotorHome.Set = false;
		if (m_cProductMotorControl->IsInputTrayTableYAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->InputTrayTableYAxisMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->InputTrayTableYAxisMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Y Axis Home %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 102://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->InputTrayTableYAxisMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Y Axis motor on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 103://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->InputTrayTableYAxisMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Y Axis motor off %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 104: //Move to input tray stacker load position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartInputTrayTableYAxisMotorMoveLoad.Set = false;
		if (m_cProductMotorControl->IsInputTrayTableYAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->InputTrayTableYAxisMotorMoveLoad(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->InputTrayTableYAxisMotorMoveLoadDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Y Axis Move load %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 105: //Move to input tray stacker unload position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartInputTrayTableYAxisMotorMoveUnload.Set = false;
		if (m_cProductMotorControl->IsInputTrayTableYAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->InputTrayTableYAxisMotorMoveUnload(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->InputTrayTableYAxisMotorMoveUnloadDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Y Axis Move unload %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 106: //Move to input tray table center position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartInputTrayTableYAxisMotorMoveCenter.Set = false;
		if (m_cProductMotorControl->IsInputTrayTableYAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->InputTrayTableYAxisMotorMoveCenter(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->InputTrayTableYAxisMotorMoveCenterDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Y Axis Move Center %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 107:
		if (m_cProductMotorControl->IsInputTrayTableYAxisMotorSafeToMove() == false)
		{
			break;
		}
		bManualThreadStart = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->InputTrayTableYAxisMovePosition = smProductTeachPoint->InputTrayTableYAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->InputTrayTableYAxisMovePosition -= 100;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableYAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->InputTrayTableYAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->InputTrayTableYAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Input Tray Table Y Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Input Tray Table Y Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 108:
		if (m_cProductMotorControl->IsInputTrayTableYAxisMotorSafeToMove() == false)
		{
			break;
		}
		bManualThreadStart = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->InputTrayTableYAxisMovePosition = smProductTeachPoint->InputTrayTableYAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->InputTrayTableYAxisMovePosition -= 500;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableYAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->InputTrayTableYAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->InputTrayTableYAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Input Tray Table Y Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Input Tray Table Y Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 109:
		if (m_cProductMotorControl->IsInputTrayTableYAxisMotorSafeToMove() == false)
		{
			break;
		}
		bManualThreadStart = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->InputTrayTableYAxisMovePosition = smProductTeachPoint->InputTrayTableYAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->InputTrayTableYAxisMovePosition -= 1000;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableYAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->InputTrayTableYAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->InputTrayTableYAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Input Tray Table Y Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Input Tray Table Y Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 110:
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Press Input Tray Table Y Axis Move.");
		if (m_cProductMotorControl->IsInputTrayTableYAxisMotorSafeToMove() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Not Safe to Move.");
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->InputTrayTableYAxisMovePosition = smProductTeachPoint->InputTrayTableYAxisAtInputTrayTableCenterPosition + signed long(smProductSetting->DeviceYPitchInput*9.5);
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->InputTrayTableYAxisMovePosition += 10000;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputTrayTableYAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->InputTrayTableYAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->InputTrayTableYAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Input Tray Table Y Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Input Tray Table Y Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
#pragma endregion

#pragma region 201-210 : Input Tray Table Z Axis Motor

	case 201://Home
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartInputTrayTableZAxisMotorHome.Set = false;
		if (m_cProductMotorControl->IsInputTrayTableZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->InputTrayTableZAxisMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->InputTrayTableZAxisMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Z Axis Home %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 202://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->InputTrayTableZAxisMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Z Axis motor on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 203://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->InputTrayTableZAxisMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Z Axis motor off %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 204: //Move to Down position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartInputTrayTableZAxisMotorMoveDown.Set = false;
		if (m_cProductMotorControl->IsInputTrayTableZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->InputTrayTableZAxisMotorMoveDown(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Z Axis Move Down %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 205: //Move to input tray stacker loading position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartInputTrayTableZAxisMotorMoveLoad.Set = false;
		if (m_cProductMotorControl->IsInputTrayTableZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->InputTrayTableZAxisMotorMoveLoad(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->InputTrayTableZAxisMotorMoveLoadDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Z Axis Move Load %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 206: //Move to input tray stacker singulation position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartInputTrayTableZAxisMotorMoveSingulation.Set = false;
		if (m_cProductMotorControl->IsInputTrayTableZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->InputTrayTableZAxisMotorMoveSingulation(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Z Axis Move Singulation %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 207: //Move to input tray stacker unloading position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartInputTrayTableZAxisMotorMoveUnload.Set = false;
		if (m_cProductMotorControl->IsInputTrayTableZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->InputTrayTableZAxisMotorMoveUnload(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->InputTrayTableZAxisMotorMoveUnloadDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Z Axis Move Unload %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
#pragma endregion

#pragma region 300 : Output Tray Table X Axis Motor
	case 301://Home
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartOutputTrayTableXAxisMotorHome.Set = false;
		if (m_cProductMotorControl->IsOutputTrayTableXAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->OutputTrayTableXAxisMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->OutputTrayTableXAxisMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table X Axis Home %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 302://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->OutputTrayTableXAxisMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table X Axis motor on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 303://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->OutputTrayTableXAxisMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table X Axis motor off %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 304: //Move to Output tray stacker load position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartOutputTrayTableXAxisMotorMoveLoad.Set = false;
		if (m_cProductMotorControl->IsOutputTrayTableXAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->OutputTrayTableXAxisMotorMoveLoad(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->OutputTrayTableXAxisMotorMoveLoadDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table X Axis Move load %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 305: //Move to Output tray stacker unload position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartOutputTrayTableXAxisMotorMoveUnload.Set = false;
		if (m_cProductMotorControl->IsOutputTrayTableXAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->OutputTrayTableXAxisMotorMoveUnload(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->OutputTrayTableXAxisMotorMoveUnloadDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table X Axis Move unload %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 306: //Move to Output tray table center position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartOutputTrayTableXAxisMotorMoveCenter.Set = false;
		if (m_cProductMotorControl->IsOutputTrayTableXAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->OutputTrayTableXAxisMotorMoveCenter(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->OutputTrayTableXAxisMotorMoveCenterDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table X Axis Move Center %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 307: // Move to Reject Tray 1 Center Position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartOutputTrayTableXAxisMotorMoveRejectTrayCenter.Set = false;
		if (m_cProductMotorControl->IsOutputTrayTableXAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->OutputTrayTableXAxisMotorMoveRejectTrayCenter(m_cMotion, 0);
		if (nError == 0)
		{
			smProductEvent->OutputTrayTableXAxisMotorMoveRejectTrayCenterDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table X Axis Move Reject Tray 1 Center %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 312: //Move to output tray table manual load unload position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartOutputTrayTableXAxisMotorMoveManualLoadUnload.Set = false;
		if (m_cProductMotorControl->IsOutputTrayTableXAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->OutputTrayTableXAxisMotorMoveManualLoadUnload(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->OutputTrayTableXAxisMotorMoveManualLoadUnloadDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table X Axis Move Manual Load Unload %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
	case 313:
		if (m_cProductMotorControl->IsOutputTrayTableXAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->OutputTrayTableXAxisMovePosition = smProductTeachPoint->OutputTrayTableXAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->OutputTrayTableXAxisMovePosition -= 100;
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableXAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableXAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Output Tray Table X Axis Motor Move Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Move Output Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 314:
		if (m_cProductMotorControl->IsOutputTrayTableXAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->OutputTrayTableXAxisMovePosition = smProductTeachPoint->OutputTrayTableXAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->OutputTrayTableXAxisMovePosition -= 500;
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableXAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableXAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Output Tray Table X Axis Motor Move Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Move Output Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 315:
		if (m_cProductMotorControl->IsOutputTrayTableXAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->OutputTrayTableXAxisMovePosition = smProductTeachPoint->OutputTrayTableXAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->OutputTrayTableXAxisMovePosition -= 1000;
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableXAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableXAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Output Tray Table X Axis Motor Move Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Move Output Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 316:
		if (m_cProductMotorControl->IsOutputTrayTableXAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->OutputTrayTableXAxisMovePosition = smProductTeachPoint->OutputTrayTableXAxisAtRejectTrayCenterPosition - (signed long)(smProductSetting->DeviceXPitchOutput*4.5);
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->OutputTrayTableXAxisMovePosition += 10000;
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableXAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableXAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Output Tray Table X Axis Motor Move Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Move Output Tray Table X Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
#pragma endregion

#pragma region 401 to 415 : Output Tray Table Y Axis Motor
	case 401://Home
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartOutputTrayTableYAxisMotorHome.Set = false;
		if (m_cProductMotorControl->IsOutputTrayTableYAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->OutputTrayTableYAxisMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->OutputTrayTableYAxisMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Y Axis Home %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 402://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->OutputTrayTableYAxisMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Y Axis motor on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 403://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->OutputTrayTableYAxisMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Y Axis motor off %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 404: //Move to Output tray stacker load position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartOutputTrayTableYAxisMotorMoveLoad.Set = false;
		if (m_cProductMotorControl->IsOutputTrayTableYAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->OutputTrayTableYAxisMotorMoveLoad(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->OutputTrayTableYAxisMotorMoveLoadDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Y Axis Move load %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 405: //Move to Output tray stacker unload position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartOutputTrayTableYAxisMotorMoveUnload.Set = false;
		if (m_cProductMotorControl->IsOutputTrayTableYAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->OutputTrayTableYAxisMotorMoveUnload(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->OutputTrayTableYAxisMotorMoveUnloadDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Y Axis Move unload %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 406: //Move to Output tray table center position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartOutputTrayTableYAxisMotorMoveCenter.Set = false;
		if (m_cProductMotorControl->IsOutputTrayTableYAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->OutputTrayTableYAxisMotorMoveCenter(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->OutputTrayTableYAxisMotorMoveCenterDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Y Axis Move Center %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 407: // Move to Reject Tray 1 Center Position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartOutputTrayTableYAxisMotorMoveRejectTrayCenter.Set = false;
		if (m_cProductMotorControl->IsOutputTrayTableYAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->OutputTrayTableYAxisMotorMoveRejectTrayCenter(m_cMotion, 0);
		if (nError == 0)
		{
			smProductEvent->OutputTrayTableYAxisMotorMoveRejectTrayCenterDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Y Axis Move Reject Tray 1 Center %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 412: //Move to output tray table manual load unload position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartOutputTrayTableYAxisMotorMoveManualLoadUnload.Set = false;
		if (m_cProductMotorControl->IsOutputTrayTableYAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->OutputTrayTableYAxisMotorMoveManualLoadUnload(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->OutputTrayTableYAxisMotorMoveManualLoadUnloadDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Y Axis Move Manual Load Unload %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
	case 413:
		if (m_cProductMotorControl->IsOutputTrayTableYAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->OutputTrayTableYAxisMovePosition = smProductTeachPoint->OutputTrayTableYAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->OutputTrayTableYAxisMovePosition -= 100;
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableYAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableYAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Output Tray Table Y Axis Motor Move Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Move Output Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 414:
		if (m_cProductMotorControl->IsOutputTrayTableYAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->OutputTrayTableYAxisMovePosition = smProductTeachPoint->OutputTrayTableYAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->OutputTrayTableYAxisMovePosition -= 500;
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableYAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableYAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Output Tray Table Y Axis Motor Move Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Move Output Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 415:
		if (m_cProductMotorControl->IsOutputTrayTableYAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->OutputTrayTableYAxisMovePosition = smProductTeachPoint->OutputTrayTableYAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->OutputTrayTableYAxisMovePosition -= 1000;
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableYAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableYAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Output Tray Table Y Axis Motor Move Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Move Output Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 416:
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Output Tray Table Y Axis Motor Move.\n");
		if (m_cProductMotorControl->IsOutputTrayTableYAxisMotorSafeToMove() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Output Tray Table Y Axis Motor Not Safe to Move.\n");
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->OutputTrayTableYAxisMovePosition = smProductTeachPoint->OutputTrayTableYAxisAtRejectTrayCenterPosition - (signed long)(smProductSetting->DeviceYPitchOutput*4.5);
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->OutputTrayTableYAxisMovePosition += 10000;
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartOutputTrayTableYAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->OutputTrayTableYAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Output Tray Table Y Axis Motor Move Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Move Output Tray Table Y Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
#pragma endregion

#pragma region 501-510 : Output Tray Table Z Axis Motor

	case 501://Home
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartOutputTrayTableZAxisMotorHome.Set = false;
		if (m_cProductMotorControl->IsOutputTrayTableZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->OutputTrayTableZAxisMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->OutputTrayTableZAxisMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Z Axis Home %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 502://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->OutputTrayTableZAxisMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Z Axis motor on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 503://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->OutputTrayTableZAxisMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Z Axis motor off %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 504: //Move to Down position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartOutputTrayTableZAxisMotorMoveDown.Set = false;
		if (m_cProductMotorControl->IsOutputTrayTableZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->OutputTrayTableZAxisMotorMoveDown(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Z Axis Move Down %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 505: //Move to Output tray stacker loading position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartOutputTrayTableZAxisMotorMoveLoad.Set = false;
		if (m_cProductMotorControl->IsOutputTrayTableZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->OutputTrayTableZAxisMotorMoveLoad(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->OutputTrayTableZAxisMotorMoveLoadDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Z Axis Move Load %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 506: //Move to Output tray stacker singulation position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartOutputTrayTableZAxisMotorMoveSingulation.Set = false;
		if (m_cProductMotorControl->IsOutputTrayTableZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->OutputTrayTableZAxisMotorMoveSingulation(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Z Axis Move Singulation %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 507: //Move to Output tray stacker unloading position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartOutputTrayTableZAxisMotorMoveUnload.Set = false;
		if (m_cProductMotorControl->IsOutputTrayTableZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->OutputTrayTableZAxisMotorMoveUnload(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->OutputTrayTableZAxisMotorMoveUnloadDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Z Axis Move Unload %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
#pragma endregion

#pragma region 601-610 : Pick And Place 1 X Axis Motor

	case 601://Home
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1XAxisMotorHome.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1XAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1XAxisMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1XAxisMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 X Axis Home %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 602://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->PickAndPlace1XAxisMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 X Axis motor on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 603://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->PickAndPlace1XAxisMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 X Axis motor off %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 604: //Move to input position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1XAxisMotorMoveToInputPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1XAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1XAxisMotorMoveToInputPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1XAxisMotorMoveToInputPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 X Axis Move To Input Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 605: //Move to S1 position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1XAxisMotorMoveToS1Position.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1XAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1XAxisMotorMoveToS1Position(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1XAxisMotorMoveToS1PositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 X Axis Move To S1 Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 606: //Move to S3 position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1XAxisMotorMoveToS3Position.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1XAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1XAxisMotorMoveToS3Position(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1XAxisMotorMoveToS3PositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 X Axis Move To S3 Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 607: //Move to Output Position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1XAxisMotorMoveToOutputPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1XAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1XAxisMotorMoveToOutputPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1XAxisMotorMoveToOutputPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 X Axis Move To Output Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 608: //Move to Parking Position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1XAxisMotorMoveToParkingPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1XAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1XAxisMotorMoveToParkingPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1XAxisMotorMoveToParkingPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 X Axis Move To Parking Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 616:
		m_cProductMotorControl->AgitoMotorSpeed(0, 0,10000, 500, 25000, 25000);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		if (m_cProductMotorControl->IsPickAndPlace1XAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->PickAndPlace1XAxisMovePosition = smProductTeachPoint->PickAndPlace1XAxisForwardLimitPosition - 5000;
				//nError = m_cProductMotorControl->PickAndPlaceXAxisMotorMove(m_cMotion);
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->PickAndPlace1XAxisMovePosition -= 100;
				//nError = m_cProductMotorControl->PickAndPlaceXAxisMotorMove(m_cMotion);
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1XAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1XAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1XAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move PnP 1 X Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move PnP 1 X Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 617:
		m_cProductMotorControl->AgitoMotorSpeed(0,0, 10000, 500, 25000, 25000);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		if (m_cProductMotorControl->IsPickAndPlace1XAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->PickAndPlace1XAxisMovePosition = smProductTeachPoint->PickAndPlace1XAxisForwardLimitPosition - 5000;
				//nError = m_cProductMotorControl->PickAndPlaceXAxisMotorMove(m_cMotion);
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->PickAndPlace1XAxisMovePosition -= 500;
				//nError = m_cProductMotorControl->PickAndPlaceXAxisMotorMove(m_cMotion);
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1XAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1XAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1XAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move PnP 1 X Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move PnP 1 X Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	
	case 618:
			nSequenceNoPnP1 = 1;
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			while (smProductEvent->ExitRTX.Set == false)
			{
				switch (nSequenceNoPnP1)
				{
				case 1:
					nError = m_cProductMotorControl->AgitoMotorSpeed(0, 0, 1200000, 500, 10000000, 10000000);
					smProductEvent->PickAndPlace1XAxisMotorMoveToInputPositionDone.Set = false;
					smProductEvent->StartPickAndPlace1XAxisMotorMoveToInputPosition.Set = true;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoPnP1 = 2;
					break;

				case 2:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (smProductEvent->PickAndPlace1XAxisMotorMoveToInputPositionDone.Set == true) /*&&
						smProductEvent->GMAIN_RTHD_SETUP_SEND_TRAYNO_DONE.Set == true*/
					{
						m_cLogger->WriteLog("Manualseq: Pick and place 1 move to input position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						smProductProduction->PickAndPlace1CurrentStation = PickAndPlaceCurrentStation.InputStation;
						smProductProduction->PickAndPlace1StationToMove = PickAndPlaceCurrentStation.UnknownStation;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						nSequenceNoPnP1 = 5;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("Manualseq: Pick And Place 1 move to input position timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoPnP1 = 3;
					}
					break;

				case 3:
					smProductEvent->PickAndPlace1XAxisMotorStopDone.Set = false;
					smProductEvent->StartPickAndPlace1XAxisMotorStop.Set = true;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoPnP1 = 4;
					break;

				case 4:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (smProductEvent->PickAndPlace1XAxisMotorStopDone.Set == true)

					{
						m_cLogger->WriteLog("Manualseq: PnP Stop Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						nSequenceNoPnP1 = 1;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("Manualseq: PnP stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoPnP1 = 3;
					}

					break;

				case 5:
					RtSleepFt(& m_cProductShareVariables->m_lnPeriod_1s);
					RtSleepFt(& m_cProductShareVariables->m_lnPeriod_100ms);
					RtSleepFt(& m_cProductShareVariables->m_lnPeriod_100ms);
					nError = m_cProductMotorControl->AgitoMotorSpeed(0, 0, 700000, 500, 10000000, 10000000);
					smProductProduction->PickAndPlace1StationToMove = PickAndPlaceCurrentStation.BottomStation;
					smProductProduction->PickAndPlace1XAxisMovePosition = smProductTeachPoint->PickAndPlace1XAxisAtS1AndBottomVisionPosition;
					m_cLogger->WriteLog("PickAndPlace1XAxisMovePosition %lf.\n", (double)(smProductProduction->PickAndPlace1XAxisMovePosition));
					smProductEvent->PickAndPlace1XAxisMotorMoveDone.Set = false;
					smProductEvent->StartPickAndPlace1XAxisMotorMove.Set = true;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoPnP1 = 6;
					break;

				case 6:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (smProductEvent->PickAndPlace1XAxisMotorMoveDone.Set == true
						/*					&& smProductEvent->GMAIN_RTHD_SETUP_VISION_GET_RC_DONE.Set == true*/)
					{
						m_cLogger->WriteLog("ManualSeq: PnP 1 Move S1 done &ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						m_cLogger->WriteLog("PickAndPlace1XAxisCurrentEncoderPosition %lf.\n", (double)(m_cProductMotorControl->ReadAgitoMotorPosition(0, 0, 0)));
						smProductProduction->PickAndPlace1CurrentStation = PickAndPlaceCurrentStation.BottomStation;
						smProductProduction->PickAndPlace1StationToMove = PickAndPlaceCurrentStation.UnknownStation;
						nSequenceNoPnP1 = 9;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("Manualseq: PnP 1 move S1 timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoPnP1 = 7;
					}
					break;

				case 7:
					smProductEvent->PickAndPlace1XAxisMotorStopDone.Set = false;
					smProductEvent->StartPickAndPlace1XAxisMotorStop.Set = true;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoPnP1 = 8;
					break;

				case 8:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (smProductEvent->PickAndPlace1XAxisMotorStopDone.Set == true)

					{
						m_cLogger->WriteLog("Manualseq: PnP Stop Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						nSequenceNoPnP1 = 5;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("Manualseq: PnP stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoPnP1 = 7;
					}

					break;

				case 9:
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1s);
					nError = m_cProductMotorControl->AgitoMotorSpeed(0, 0, 2000000, 500, 10000000, 10000000);
					smProductProduction->PickAndPlace1StationToMove = PickAndPlaceCurrentStation.S3Station;
					smProductProduction->PickAndPlace1XAxisMovePosition = smProductTeachPoint->PickAndPlace1XAxisAtS2AndS3VisionPosition;
					m_cLogger->WriteLog("PickAndPlace1XAxisMovePosition %lf.\n", (double)(smProductProduction->PickAndPlace1XAxisMovePosition)); 
					smProductEvent->PickAndPlace1XAxisMotorMoveDone.Set = false;
					smProductEvent->StartPickAndPlace1XAxisMotorMove.Set = true;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoPnP1 = 10;
					break;

				case 10:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (smProductEvent->PickAndPlace1XAxisMotorMoveDone.Set == true
						/*					&& smProductEvent->GMAIN_RTHD_SETUP_VISION_GET_RC_DONE.Set == true*/)
					{
						m_cLogger->WriteLog("ManualSeq: PnP 1 Move S3 done &ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						m_cLogger->WriteLog("PickAndPlace1XAxisCurrentEncoderPosition %lf.\n", (double)(m_cProductMotorControl->ReadAgitoMotorPosition(0, 0, 0)));
						smProductProduction->PickAndPlace1CurrentStation = PickAndPlaceCurrentStation.S3Station;
						smProductProduction->PickAndPlace1StationToMove = PickAndPlaceCurrentStation.UnknownStation;
						nSequenceNoPnP1 = 13;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("Manualseq: PnP 1 move s3 timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoPnP1 = 11;
					}
					break;

				case 11:
					smProductEvent->PickAndPlace1XAxisMotorStopDone.Set = false;
					smProductEvent->StartPickAndPlace1XAxisMotorStop.Set = true;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoPnP1 = 12;
					break;

				case 12:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (smProductEvent->PickAndPlace1XAxisMotorStopDone.Set == true)

					{
						m_cLogger->WriteLog("Manualseq: PnP Stop Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						nSequenceNoPnP1 = 9;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("Manualseq: PnP stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoPnP1 = 11;
					}

					break;
				case 13:
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_100ms);
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_100ms);
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_100ms);
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_10ms);
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_10ms);
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_10ms);
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_10ms);
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_10ms);
					nError = m_cProductMotorControl->AgitoMotorSpeed(0, 0, 1200000, 500, 10000000, 10000000);
					smProductProduction->PickAndPlace1StationToMove = PickAndPlaceCurrentStation.OutputStation;
					smProductProduction->PickAndPlace1XAxisMovePosition = smProductTeachPoint->PickAndPlace1XAxisOutputPosition;
					m_cLogger->WriteLog("PickAndPlace1XAxisMovePosition %lf.\n", (double)(smProductProduction->PickAndPlace1XAxisMovePosition));
					smProductEvent->PickAndPlace1XAxisMotorMoveDone.Set = false;
					smProductEvent->StartPickAndPlace1XAxisMotorMove.Set = true;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoPnP1 = 14;
					break;

				case 14:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (smProductEvent->PickAndPlace1XAxisMotorMoveDone.Set == true
						/*					&& smProductEvent->GMAIN_RTHD_SETUP_VISION_GET_RC_DONE.Set == true*/)
					{
						m_cLogger->WriteLog("ManualSeq: PnP 1 Move output done &ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						m_cLogger->WriteLog("PickAndPlace1XAxisCurrentEncoderPosition %lf.\n", (double)(m_cProductMotorControl->ReadAgitoMotorPosition(0, 0, 0)));
						smProductProduction->PickAndPlace1CurrentStation = PickAndPlaceCurrentStation.OutputStation;
						smProductProduction->PickAndPlace1StationToMove = PickAndPlaceCurrentStation.UnknownStation;
						nSequenceNoPnP1 = 17;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("Manualseq: PnP 1 move output timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoPnP1 = 15;
					}
					break;

				case 15:
					smProductEvent->PickAndPlace1XAxisMotorStopDone.Set = false;
					smProductEvent->StartPickAndPlace1XAxisMotorStop.Set = true;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoPnP1 = 16;
					break;

				case 16:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (smProductEvent->PickAndPlace1XAxisMotorStopDone.Set == true)

					{
						m_cLogger->WriteLog("Manualseq: PnP Stop Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						nSequenceNoPnP1 = 13;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("Manualseq: PnP stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoPnP1 = 15;
					}
					break;
				case 17:
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_100ms);
					nError = m_cProductMotorControl->AgitoMotorSpeed(0, 0, 2000000, 500, 10000000, 10000000);
					smProductProduction->PickAndPlace1StationToMove = PickAndPlaceCurrentStation.InputStation;
					smProductProduction->PickAndPlace1XAxisMovePosition = smProductTeachPoint->PickAndPlace1XAxisInputPosition;
					m_cLogger->WriteLog("PickAndPlace1XAxisMovePosition %lf.\n", (double)(smProductProduction->PickAndPlace1XAxisMovePosition));
					smProductEvent->PickAndPlace1XAxisMotorMoveDone.Set = false;
					smProductEvent->StartPickAndPlace1XAxisMotorMove.Set = true;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoPnP1 = 18;
					break;

				case 18:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (smProductEvent->PickAndPlace1XAxisMotorMoveDone.Set == true
						/*					&& smProductEvent->GMAIN_RTHD_SETUP_VISION_GET_RC_DONE.Set == true*/)
					{
						m_cLogger->WriteLog("ManualSeq: PnP 1 Move input done &ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						m_cLogger->WriteLog("PickAndPlace1XAxisCurrentEncoderPosition %lf.\n", (double)(m_cProductMotorControl->ReadAgitoMotorPosition(0, 0, 0)));
						smProductProduction->PickAndPlace1CurrentStation = PickAndPlaceCurrentStation.InputStation;
						smProductProduction->PickAndPlace1StationToMove = PickAndPlaceCurrentStation.UnknownStation;
						nSequenceNoPnP1 = 999;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("Manualseq: PnP 1 move input timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoPnP1 = 19;
					}
					break;

				case 19:
					smProductEvent->PickAndPlace1XAxisMotorStopDone.Set = false;
					smProductEvent->StartPickAndPlace1XAxisMotorStop.Set = true;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoPnP1 = 20;

				case 20:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (smProductEvent->PickAndPlace1XAxisMotorStopDone.Set == true)

					{
						m_cLogger->WriteLog("Manualseq: PnP Stop Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						nSequenceNoPnP1 = 17;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("Manualseq: PnP stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoPnP1 = 19;
					}

					break;
				default:
					return -1;
					break;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				if (smProductEvent->StopManualMode.Set == true)
				{

					m_cProductShareVariables->UpdateMessageToGUIAndLog("PnP Sequence Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				if (nSequenceNoPnP1 == 999)
				{
					nSequenceNoPnP1 = 5;
					m_cProductShareVariables->UpdateMessageToGUIAndLog("PnP Sequence Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);

				}
				RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			}
			break;
#pragma endregion

#pragma region 700 : Pick And Place 1 Y Axis Motor

	case 701://Home
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1YAxisMotorHome.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1YAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1YAxisMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1YAxisMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Y Axis Home %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 702://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->PickAndPlace1YAxisMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Y Axis motor on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 703://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->PickAndPlace1YAxisMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Y Axis motor off %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 704: //Move to input position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1YAxisMotorMoveToInputPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1YAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMoveToInputPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1YAxisMotorMoveToInputPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Y Axis Move To Input Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 705: //Move to S1 position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1YAxisMotorMoveToS1Position.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1YAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMoveToS1Position(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1YAxisMotorMoveToS1PositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Y Axis Move To S1 Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 706: //Move to S3 position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1YAxisMotorMoveToS3Position.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1YAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMoveToS3Position(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1YAxisMotorMoveToS3PositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Y Axis Move To S3 Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 707: //Move to Output Position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1YAxisMotorMoveToOutputPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1YAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMoveToOutputPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1YAxisMotorMoveToOutputPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Y Axis Move To Output Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 708: //Move to Standby Position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1YAxisMotorMoveToStandbyPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1YAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMoveToStandbyPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1YAxisMotorMoveToStandbyPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Y Axis Move To Standby Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 709:
		if (m_cProductMotorControl->IsPickAndPlace1YAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->PickAndPlace1YAxisMovePosition = smProductTeachPoint->PickAndPlace1YAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->PickAndPlace1YAxisMovePosition -= 100;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1YAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1YAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Pick And Place 1 Y Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Pick And Place 1 Y Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 710:
		if (m_cProductMotorControl->IsPickAndPlace1YAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->PickAndPlace1YAxisMovePosition = smProductTeachPoint->PickAndPlace1YAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->PickAndPlace1YAxisMovePosition -= 500;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1YAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1YAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Pick And Place 1 Y Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Pick And Place 1 Y Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 711:
		if (m_cProductMotorControl->IsPickAndPlace1YAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->PickAndPlace1YAxisMovePosition = smProductTeachPoint->PickAndPlace1YAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->PickAndPlace1YAxisMovePosition -= 1000;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1YAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1YAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Pick And Place 1 Y Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Pick And Place 1 Y Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 713:
		m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Press Move Pick And Place 1 Y Axis Motor.\n");
		if (m_cProductMotorControl->IsPickAndPlace1YAxisMotorSafeToMove() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Pick And Place 1 Y Axis Motor Not Safe to Move.\n");
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->PickAndPlace1YAxisMovePosition = smProductTeachPoint->PickAndPlace1YAxisInputPosition;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->PickAndPlace1YAxisMovePosition -= 10000;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace1YAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->PickAndPlace1YAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace1YAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Pick And Place 1 Y Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Pick And Place 1 Y Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
#pragma endregion

#pragma region 800 : Kingstar and Pick And Place 1 Z Axis Motor
	case 800: //connect kingstar
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press THK connect.\n");
		if (smProductEvent->InitializeMotionController7Done.Set == false)
		{
			nError = m_cProductMotorControl->THKConnect(0);
		}
		else
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: THK had been connected.\n");
		}
		if (nError == 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: THK connect done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error connect THK 1 index Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 801://disconnect
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press THK Disconnect.\n");
		nError = m_cProductMotorControl->THKDisconnect(0);
		if (nError == 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("THK 1 Disconnect %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Disconnet THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 802: //Initialize
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press THK Initialize.\n");
		nError = m_cProductMotorControl->THKInitialize(0);
		if (nError == 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("THK 1 Initialize %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Initialize THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;


	case 803://Home
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1ZAxisMotorHome.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1ZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1ZAxisMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis Home %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 804://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis motor on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 805://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis motor off %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 806: //Move to Up position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1ZAxisMotorMoveUpPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1ZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveUpPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1ZAxisMotorMoveUpPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis Move Up Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 807: //Move to input tray touching position
		if (m_cProductMotorControl->IsPickAndPlace1ZAxisMotorSafeToMove() == false)
		{
			break;
		}
		smProductProduction->PickAndPlace1ZAxisMovePosition = smProductTeachPoint->PickAndPlace1ZAxisAtInputTrayTouchingPosition;
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1ZAxisMotorMove.Set = false;
		nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMove(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1ZAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis Move to Input Tray Touching Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 808: //Move to input tray down position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1ZAxisMotorMoveToInputTrayDownPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1ZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveInputDownPosition(m_cMotion, true);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1ZAxisMotorMoveToInputTrayDownPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis Move To Input Tray Down Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 809: //Move to input tray softlanding position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1ZAxisMotorMoveToInputTraySoftlandingPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1ZAxisMotorSafeToMove() == false)
		{
			break;
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

		nError = m_cProductMotorControl->THKSetTargetValue1(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtInputTrayTouchingPosition
			- (signed long)smProductSetting->InputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um
			+ (signed long)smProductSetting->PickingGap_um + (signed long)smProductSetting->Picking1SoftlandingDistance_um);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Softlanding Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 1 Force to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Force, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue2(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtInputTrayTouchingPosition
			- (signed long)smProductSetting->InputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PickingGap_um);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Picking Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue4(0, (double)smProductSetting->PickUpHead1Force);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Force Target %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 1 Down Position to %lf in %ums.\n", (double)((signed long)smProductTeachPoint->PickAndPlacePickupHead1ZAxisAtInputJedecTrayTouchingPosition
			//	- (signed long)smProductSetting->PocketDepthJedec_um + (signed long)smProductSetting->UnitThickness_um
			//	+ (signed long)smProductSetting->PickingGapAtInputJedecTray_um + (signed long)smProductSetting->PickingSoftlandingDistanceAtInputJedecTray_um), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue6(0, (signed long)smProductSetting->PickUpHead1Pressure);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Pressure Value %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Down Position Before Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue8(0, (signed long)((double)((double)smProductSetting->PickingSoftlandingSpeed_percent / 100.0) * (double)500));
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Softlanding Speed %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Down Position With Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue10(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOn_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position Before Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Picking to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPickingAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue11(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOn_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position With Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 1 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue12(0, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPicking_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Picking %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 1 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}


		nError = m_cProductMotorControl->THKSoftlandingPick(0);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1ZAxisMotorMoveToInputTraySoftlandingPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis Move To Input Tray Softlanding Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 810: //Move to output tray touching position
		if (m_cProductMotorControl->IsPickAndPlace1ZAxisMotorSafeToMove() == false)
		{
			break;
		}
		smProductProduction->PickAndPlace1ZAxisMovePosition = smProductTeachPoint->PickAndPlace1ZAxisAtOutputTrayTouchingPosition;
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1ZAxisMotorMove.Set = false;
		nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMove(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1ZAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis Move to Output Tray Touching Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 811: //Move to output tray down position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1ZAxisMotorMoveToOutputTrayDownPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1ZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveOutputDownPosition(m_cMotion, true);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1ZAxisMotorMoveToOutputTrayDownPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis Move To Output Tray Down Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 812: //Move to output tray softlanding position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1ZAxisMotorMoveToOutputTraySoftlandingPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1ZAxisMotorSafeToMove() == false)
		{
			break;
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue1(0, (double)smProductSetting->PickUpHead1PlaceForce);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Place Force %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 1 Place Force %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue2(0, (signed long)smProductSetting->PickUpHead1PlacePressure);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Place Pressure %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 1 Place Pressure %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue3(0, (signed long)smProductSetting->PickUpHead1PlaceFlowRate);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Place Flow Rate %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 1 Place Flow Rate %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue4(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtOutputTrayTouchingPosition
			- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PlacementGap_um);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Placement 1 Down Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Placement 1 Down Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}

		nError = m_cProductMotorControl->THKSetTargetValue7(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforePurging_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Placement 1 Delay For Pickup Head At Down Position Before Purging %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue8(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithPurging_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Placement 1 Delay For Pickup Head At Down Position With Purging %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue9(0, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPlacement_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Placement 1 Delay For Pickup Head At Softlanding Position For Placement %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue10(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtOutputTrayTouchingPosition
			- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PlacementGap_um + (signed long)smProductSetting->PlacementSoftlandingDistance_um);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Placement 1 Picking Softlanding Distance %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue11(0, (signed long)((double)((double)smProductSetting->PlacementSoftlandingSpeed_percent / 100.0) * (double)500));
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Placement 1 Picking Softlanding Speed_percent %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		if (smProductSetting->EnablePlaceSoftlanding == true)
		{
			nError = m_cProductMotorControl->THKSoftlandingPlace(0);
		}
		else
		{
			nError = m_cProductMotorControl->THKPlace(0);
		}
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1ZAxisMotorMoveToOutputTraySoftlandingPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis Move To Output Tray Softlanding Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 813:
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Pick And Place 1 Z Axis Motor THK Read Encoder.\n");
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKReadEncoderValue(0, 0, &a);
		if (nError == 0)
		{
			if (smProductEvent->JobMode.Set == true)
			{

			}
			//smProductEvent->InputVisionXAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error read Pick And Place 1 Z Axis Motor THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 814: // vacuum on
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 1 THK Vacumm On.\n");
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

		nError = m_cProductMotorControl->THKVacuumValveOn(0);
		if (nError == 0)
		{
			if (smProductEvent->JobMode.Set == true)
			{

			}
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error On vaccum Pick And Place 1 THK Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 815: //vacuum off
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 1 THK Vacuum Off.\n");
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKVacuumValveOff(0);
		if (nError == 0)
		{
			if (smProductEvent->JobMode.Set == true)
			{

			}
			//smProductEvent->InputVisionXAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Off Vaccum THK Pick And Place 1 Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 816: // valve on
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 1 THK Valve On.\n");
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKReleaseValveOn(0);
		if (nError == 0)
		{
			if (smProductEvent->JobMode.Set == true)
			{

			}
			//smProductEvent->InputVisionXAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Release Valve Pick And Place 1 THK Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 817: //valve off
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And PLace 1 THK Valve Off.\n");
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKReleaseValveOff(0);
		if (nError == 0)
		{
			if (smProductEvent->JobMode.Set == true)
			{

			}
			//smProductEvent->InputVisionXAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Off Valve THK Pick And Place 1 %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 818: //Servo status
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 1 Z Axis THK Read Servo Status.\n");
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKReadMotorServoStatus(0, 0);
		if (nError == 0)
		{
			if (smProductEvent->JobMode.Set == true)
			{

			}
			//smProductEvent->InputVisionXAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Read Servo Status THK Pick And Place 1 Z Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 819: //reset alarm
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 1 THK Reset Alarm.\n");
		nError = m_cProductMotorControl->THKResetAlarm(0);
		if (nError == 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 THK Reset Alarm Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Reset Alarm THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 820: //change target value
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 1 THK Change Target Value.\n");
		nError = m_cProductMotorControl->THKSetTargetValue(0, 1, -9);
		if (nError == 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 THK Change Target Value Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Change Target Value THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 821: //Pick
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 1 THK trigger Pick Sequence.\n");
		nError = m_cProductMotorControl->THKPick(0);
		if (nError == 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 THK Trigger Pick Sequence Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 THK Trigger Pick Sequence THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 822://Place
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 1 THK trigger Place Sequence.\n");
		nError += m_cProductMotorControl->THKSetTargetValue1(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtOutputTrayTouchingPosition
			- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um
			+ (signed long)smProductSetting->PlacementGap_um + (signed long)smProductSetting->PlacementSoftlandingDistance_um);

		nError += m_cProductMotorControl->THKSetTargetValue3(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtOutputTrayTouchingPosition
			- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PlacementGap_um);

		nError += m_cProductMotorControl->THKSetTargetValue5(0, (double)smProductSetting->PickUpHead1PlaceForce);

		nError += m_cProductMotorControl->THKSetTargetValue6(0, (signed long)smProductSetting->PickUpHead1Pressure);

		nError += m_cProductMotorControl->THKSetTargetValue9(0, (signed long)((double)((double)smProductSetting->PlacementSoftlandingSpeed_percent / 100.0) * (double)500));

		nError += m_cProductMotorControl->THKSetTargetValue10(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforePurging_ms);

		nError += m_cProductMotorControl->THKSetTargetValue11(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithPurging_ms);

		nError += m_cProductMotorControl->THKSetTargetValue12(0, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPlacement_ms);

		if (smProductSetting->EnablePlaceSoftlanding == true)
		{
			nError += m_cProductMotorControl->THKSoftlandingPlace(0);
		}
		else
		{
			nError += m_cProductMotorControl->THKPlace(0);
		}
		if (nError == 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 THK Trigger Place Sequence Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 THK Trigger Place Sequence THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;

	case 823: //Pick And Place 1 Softlanding Pick
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 1 THK trigger Softlanding Pick Sequence.\n");
		smProductEvent->StartPickAndPlace1ZAxisMotorMoveToInputTraySoftlandingPosition.Set = false;

		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

		nError = m_cProductMotorControl->THKSetTargetValue1(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtInputTrayTouchingPosition
			- (signed long)smProductSetting->InputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um
			+ (signed long)smProductSetting->PickingGap_um + (signed long)smProductSetting->Picking1SoftlandingDistance_um);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Softlanding Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue2(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtInputTrayTouchingPosition
			- (signed long)smProductSetting->InputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PickingGap_um);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Picking Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue4(0, (double)smProductSetting->PickUpHead1Force);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Force Target %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue6(0, (signed long)smProductSetting->PickUpHead1Pressure);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Pressure Value %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue8(0, (signed long)((double)((double)smProductSetting->PickingSoftlandingSpeed_percent / 100.0) * (double)500));
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Softlanding Speed %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue10(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOn_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position Before Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue11(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOn_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position With Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue12(0, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPicking_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Picking %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}

		nError = m_cProductMotorControl->THKSoftlandingPick(0);
		//nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveInputDownPosition(cMotion, false);
		if (nError == 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue1(0, (signed long)(smProductTeachPoint->PickAndPlace1ZAxisUpPosition + signed long(smProductSetting->UnitThickness_um)));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Rotation Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}

			nError = m_cProductMotorControl->THKMoveUpSequence(0);
			if (nError == 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 THK Trigger Softlanding Pick Sequence Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 THK Trigger Softlanding Pick Sequence THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error move to Input tray Softlanding position Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		
		break;
	case 824: //Pick And Place 1 Softlanding Place
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 1 THK trigger Softlanding Place Sequence.\n");
		smProductEvent->StartPickAndPlace1ZAxisMotorMoveToOutputTraySoftlandingPosition.Set = false;
		//nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveOutputDownPosition(cMotion, false);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue1(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtOutputTrayTouchingPosition
			- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um
			+ (signed long)smProductSetting->PlacementGap_um + (signed long)smProductSetting->PlacementSoftlandingDistance_um);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Place Softlanding Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue3(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtOutputTrayTouchingPosition
			- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PlacementGap_um);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Placement Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue5(0, (double)smProductSetting->PickUpHead1PlaceForce);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Place Force Target %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue6(0, (signed long)smProductSetting->PickUpHead1PlacePressure);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Place Pressure Value %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue9(0, (signed long)((double)((double)smProductSetting->PlacementSoftlandingSpeed_percent / 100.0) * (double)500));
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Place Softlanding Speed %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue10(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforePurging_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position Before Purging %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue11(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithPurging_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position With Purging %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue12(0, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPlacement_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Placement %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		if (smProductSetting->EnablePlaceSoftlanding == true)
		{
			nError = m_cProductMotorControl->THKSoftlandingPlace(0);
		}
		else
		{
			nError = m_cProductMotorControl->THKPlace(0);
		}
		if (nError == 0)
		{
			lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayForPickupHeadAtDownPositionAfterPurging_ms;
			RtSleepFt(&lnDelayIn100ns);
			if (smProductEvent->JobMode.Set == true)
			{

			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue1(0, (signed long)(smProductTeachPoint->PickAndPlace1ZAxisUpPosition + signed long(smProductSetting->UnitThickness_um)));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Rotation Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}

			nError = m_cProductMotorControl->THKMoveUpSequence(0);
			if (nError == 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 THK Trigger Softlanding Place Sequence Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 THK Trigger Softlanding Place Sequence THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error move to Output Tray Softlanding Position Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		
		
		break;
		case 825: //Pick And Place 1 Softlanding Pick At Output
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 1 THK trigger Softlanding Pick Sequence.\n");
			smProductEvent->StartPickAndPlace1ZAxisMotorMoveToOutputTraySoftlandingPositionForPicking.Set = false;

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

			nError = m_cProductMotorControl->THKSetTargetValue1(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtOutputTrayTouchingPosition
				- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um
				+ (signed long)smProductSetting->PickingGap_um_Output + (signed long)smProductSetting->PickingSoftlandingDistance_um_Output);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Softlanding Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue2(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisAtOutputTrayTouchingPosition
				- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PickingGap_um_Output);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Picking Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue4(0, (double)smProductSetting->PickUpHead1Force);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Force Target %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue6(0, (signed long)smProductSetting->PickUpHead1Pressure);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Pressure Value %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue8(0, (signed long)((double)((double)smProductSetting->PickingSoftlandingSpeed_percent_Output / 100.0) * (double)500));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Softlanding Speed %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue10(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOn_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position Before Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue11(0, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOn_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Down Position With Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue12(0, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPicking_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 1 Delay For Pickup Head At Softlanding Position For Picking %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}

			nError = m_cProductMotorControl->THKSoftlandingPick(0);
			//nError = m_cProductMotorControl->PickAndPlace1ZAxisMotorMoveInputDownPosition(cMotion, false);
			if (nError == 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				nError = m_cProductMotorControl->THKSetTargetValue1(0, (signed long)(smProductTeachPoint->PickAndPlace1ZAxisUpPosition + signed long(smProductSetting->UnitThickness_um)));
				if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error setting up Pick Up 1 Rotation Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				}

				nError = m_cProductMotorControl->THKMoveUpSequence(0);
				if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 THK Trigger Softlanding Pick Sequence Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 THK Trigger Softlanding Pick Sequence THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					//return nError;
				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move to Input tray Softlanding position Pick And Place 1 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}

			break;
		case 826:
			nSequenceNoPnP1 = 1;
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			while (smProductEvent->ExitRTX.Set == false)
			{
				switch (nSequenceNoPnP1)
				{
				case 1:
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nError = m_cProductMotorControl->THKReleaseValveOn(0);
					if (nError != 0)
					{
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
						m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Release Valve Pick And Place 1 THK Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoPnP1 = 999;
						break;
						//return nError;
					}
					else
					{
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						nSequenceNoPnP1 = 2;
					}
					break;
				case 2:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount >= (LONGLONG)smProductSetting->DelayForPickupHeadAtDownPositionWithPurgingAtInput_ms)
					{
						nSequenceNoPnP1 = 3;
					}
					break;
				case 3:
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nError = m_cProductMotorControl->THKReleaseValveOff(0);
					if (nError == 0)
					{
						m_cProductShareVariables->UpdateMessageToGUIAndLog("Off Valve THK Pick And Place 1 Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					else if (nError != 0)
					{
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
						m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Off Valve THK Pick And Place 1 %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//return nError;
					}
					nSequenceNoPnP1 = 999;
					break;
				default:
					return -1;
					break;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				if (smProductEvent->StopManualMode.Set == true)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("PnP Sequence Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				if (nSequenceNoPnP1 == 999)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("PnP Sequence Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			}
			break;


				
#pragma endregion

#pragma region 900 : Pick And Place 1 T Axis Motor

	case 901://Home
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1ThetaAxisMotorHome.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1ThetaAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1ThetaAxisMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1ThetaAxisMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Theta Axis Home %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 902://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->PickAndPlace1ThetaAxisMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Theta Axis motor on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 903://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->PickAndPlace1ThetaAxisMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Theta Axis motor off %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 904: //Move to Standby position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace1ThetaAxisMotorMoveStandbyPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace1ThetaAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace1ThetaAxisMotorMoveStandbyPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace1ThetaAxisMotorMoveStandbyPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Theta Axis Move Standby Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 905://read encoder
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Pick And Place 1 Theta Axis Motor THK Read Encoder.\n");
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKReadEncoderValue(0, 1, &a);
		if (nError == 0)
		{
			if (smProductEvent->JobMode.Set == true)
			{

			}
			//smProductEvent->InputVisionXAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error read Pick And Place 1 Theta Axis Motor THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;

	case 906: //Servo status
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 1 Theta Axis THK Read Servo Status.\n");
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKReadMotorServoStatus(0, 1);
		if (nError == 0)
		{
			if (smProductEvent->JobMode.Set == true)
			{

			}
			//smProductEvent->InputVisionXAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Read Servo Status THK Pick And Place 1 Rotation Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;

#pragma endregion

#pragma region 1001-1016 : Pick And Place 2 X Axis Motor

	case 1001://Home
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2XAxisMotorHome.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2XAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2XAxisMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2XAxisMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 X Axis Home %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1002://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->PickAndPlace2XAxisMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 X Axis motor on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 1003://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->PickAndPlace2XAxisMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 X Axis motor off %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1004: //Move to input position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2XAxisMotorMoveToInputPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2XAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2XAxisMotorMoveToInputPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2XAxisMotorMoveToInputPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 X Axis Move To Input Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1005: //Move to S1 position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2XAxisMotorMoveToS1Position.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2XAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2XAxisMotorMoveToS1Position(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2XAxisMotorMoveToS1PositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 X Axis Move To S1 Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 1006: //Move to S3 position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2XAxisMotorMoveToS3Position.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2XAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2XAxisMotorMoveToS3Position(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2XAxisMotorMoveToS3PositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 X Axis Move To S3 Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 1007: //Move to Output Position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2XAxisMotorMoveToOutputPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2XAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2XAxisMotorMoveToOutputPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2XAxisMotorMoveToOutputPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 X Axis Move To Output Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 1008: //Move to Parking Position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2XAxisMotorMoveToParkingPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2XAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2XAxisMotorMoveToParkingPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2XAxisMotorMoveToParkingPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 X Axis Move To Parking Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1016:
		m_cProductMotorControl->AgitoMotorSpeed1(1,0, 10000, 500, 25000, 25000);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		if (m_cProductMotorControl->IsPickAndPlace2XAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->PickAndPlace2XAxisMovePosition = smProductTeachPoint->PickAndPlace2XAxisForwardLimitPosition - 5000;
				//nError = m_cProductMotorControl->PickAndPlaceXAxisMotorMove(m_cMotion);
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->PickAndPlace2XAxisMovePosition -= 100;
				//nError = m_cProductMotorControl->PickAndPlaceXAxisMotorMove(m_cMotion);
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2XAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2XAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2XAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move PnP 2 X Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move PnP 2 X Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 1017:
		m_cProductMotorControl->AgitoMotorSpeed1(1,0, 10000, 500, 25000, 25000);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		if (m_cProductMotorControl->IsPickAndPlace2XAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->PickAndPlace2XAxisMovePosition = smProductTeachPoint->PickAndPlace2XAxisForwardLimitPosition - 5000;
				//nError = m_cProductMotorControl->PickAndPlaceXAxisMotorMove(m_cMotion);
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->PickAndPlace2XAxisMovePosition -= 500;
				//nError = m_cProductMotorControl->PickAndPlaceXAxisMotorMove(m_cMotion);
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2XAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2XAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2XAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move PnP 2 X Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move PnP 2 X Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 1018:
		m_cProductMotorControl->AgitoMotorSpeed1(1,0, 10000, 500, 25000, 25000);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		if (m_cProductMotorControl->IsPickAndPlace2XAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->PickAndPlace2XAxisMovePosition = smProductTeachPoint->PickAndPlace2XAxisForwardLimitPosition - 5000;
				//nError = m_cProductMotorControl->PickAndPlaceXAxisMotorMove(m_cMotion);
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->PickAndPlace2XAxisMovePosition -= 1000;
				//nError = m_cProductMotorControl->PickAndPlaceXAxisMotorMove(m_cMotion);
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2XAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2XAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2XAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move PnP 2 X Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move PnP 2 X Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
#pragma endregion

#pragma region 1100 : Pick And Place 2 Y Axis Motor

	case 1101://Home
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2YAxisMotorHome.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2YAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2YAxisMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2YAxisMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Y Axis Home %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1102://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->PickAndPlace2YAxisMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Y Axis motor on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 1103://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->PickAndPlace2YAxisMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Y Axis motor off %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1104: //Move to input position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2YAxisMotorMoveToInputPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2YAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMoveToInputPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2YAxisMotorMoveToInputPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Y Axis Move To Input Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1105: //Move to S1 position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2YAxisMotorMoveToS1Position.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2YAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMoveToS1Position(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2YAxisMotorMoveToS1PositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Y Axis Move To S1 Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 1106: //Move to S3 position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2YAxisMotorMoveToS3Position.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2YAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMoveToS3Position(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2YAxisMotorMoveToS3PositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Y Axis Move To S3 Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 1107: //Move to Output Position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2YAxisMotorMoveToOutputPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2YAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMoveToOutputPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2YAxisMotorMoveToOutputPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Y Axis Move To Output Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 1108: //Move to Standby Position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2YAxisMotorMoveToStandbyPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2YAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMoveToStandbyPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2YAxisMotorMoveToStandbyPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Y Axis Move To Standby Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 1109:
		if (m_cProductMotorControl->IsPickAndPlace2YAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->PickAndPlace2YAxisMovePosition = smProductTeachPoint->PickAndPlace2YAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->PickAndPlace2YAxisMovePosition -= 100;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2YAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2YAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Pick And Place 2 Y Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Pick And Place 2 Y Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 1110:
		if (m_cProductMotorControl->IsPickAndPlace2YAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->PickAndPlace2YAxisMovePosition = smProductTeachPoint->PickAndPlace2YAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->PickAndPlace2YAxisMovePosition -= 500;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2YAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2YAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Pick And Place 2 Y Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Pick And Place 2 Y Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 1111:
		if (m_cProductMotorControl->IsPickAndPlace2YAxisMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->PickAndPlace2YAxisMovePosition = smProductTeachPoint->PickAndPlace2YAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->PickAndPlace2YAxisMovePosition -= 1000;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2YAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2YAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Pick And Place 2 Y Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Pick And Place 2 Y Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 1113:
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Press Pick And Place 2 Y Axis Motor Move");
		if (m_cProductMotorControl->IsPickAndPlace2YAxisMotorSafeToMove() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor Not Safe To Move");
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->PickAndPlace2YAxisMovePosition = smProductTeachPoint->PickAndPlace2YAxisInputPosition;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->PickAndPlace2YAxisMovePosition += 10000;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartPickAndPlace2YAxisMotorMove.Set = false;
			nError = m_cProductMotorControl->PickAndPlace2YAxisMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->PickAndPlace2YAxisMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Pick And Place 2 Y Axis Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Pick And Place 2 Y Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
#pragma endregion

#pragma region 1200 : Kingstar and Pick And Place 2 Z Axis Motor
	case 1200: //connect kingstar
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press THK connect.\n");
		if (smProductEvent->InitializeMotionController7Done.Set == false)
		{
			nError = m_cProductMotorControl->THKConnect(1);
		}
		else
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: THK had been connected.\n");
		}
		if (nError == 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: THK connect done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error connect THK 2 index Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 1201://disconnect
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press THK Disconnect.\n");
		nError = m_cProductMotorControl->THKDisconnect(1);
		if (nError == 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("THK 2 Disconnect %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Disconnet THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 1202: //Initialize
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press THK Initialize.\n");
		nError = m_cProductMotorControl->THKInitialize(1);
		if (nError == 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("THK 2 Initialize %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Initialize THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;


	case 1203://Home
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2ZAxisMotorHome.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2ZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2ZAxisMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis Home %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1204://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis motor on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 1205://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis motor off %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1206: //Move to Up position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2ZAxisMotorMoveUpPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2ZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorMoveUpPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2ZAxisMotorMoveUpPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis Move Up Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1207: //Move to input tray touching position
		if (m_cProductMotorControl->IsPickAndPlace2ZAxisMotorSafeToMove() == false)
		{
			break;
		}
		smProductProduction->PickAndPlace2ZAxisMovePosition = smProductTeachPoint->PickAndPlace2ZAxisAtInputTrayTouchingPosition;
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2ZAxisMotorMove.Set = false;
		nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorMove(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2ZAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis Move to Input Tray Touching Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 1208: //Move to input tray down position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2ZAxisMotorMoveToInputTrayDownPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2ZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorMoveInputDownPosition(m_cMotion, true);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2ZAxisMotorMoveToInputTrayDownPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis Move To Input Tray Down Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 1209: //Move to input tray softlanding position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2ZAxisMotorMoveToInputTraySoftlandingPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2ZAxisMotorSafeToMove() == false)
		{
			break;
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

		nError = m_cProductMotorControl->THKSetTargetValue1(1, (double)smProductSetting->PickUpHead2Force);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Force %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 2 Force to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Force, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue2(1, (signed long)smProductSetting->PickUpHead2Pressure);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Pressure %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 2 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue4(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtInputTrayTouchingPosition
			- (signed long)smProductSetting->InputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um
			+ (signed long)smProductSetting->PickingGap_um + (signed long)smProductSetting->Picking2SoftlandingDistance_um);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Down Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 2 Down Position to %lf in %ums.\n", (double)((signed long)smProductTeachPoint->PickAndPlacePickupHead1ZAxisAtInputJedecTrayTouchingPosition
			//	- (signed long)smProductSetting->PocketDepthJedec_um + (signed long)smProductSetting->UnitThickness_um
			//	+ (signed long)smProductSetting->PickingGapAtInputJedecTray_um + (signed long)smProductSetting->PickingSoftlandingDistanceAtInputJedecTray_um), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue7(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOn_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Down Position Before Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 2 Delay For Pickup Head At Down Position Before Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue8(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOn_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Down Position With Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 2 Delay For Pickup Head At Down Position With Vacuum On to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOnAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue9(1, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPicking_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Softlanding Position For Picking %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 2 Delay For Pickup Head At Softlanding Position For Picking to %lf in %ums.\n", (double)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPickingAtInputJedecTray_ms, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue10(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtInputTrayTouchingPosition
			- (signed long)smProductSetting->InputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PickingGap_um);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Picking Softlanding Distance %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 2 Picking Softlanding Distance to %lf in %ums.\n", (double)((signed long)smProductTeachPoint->PickAndPlacePickupHead1ZAxisAtInputJedecTrayTouchingPosition
			//	- (signed long)smProductSetting->PocketDepthJedec_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PickingGapAtInputJedecTray_um), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue11(1, (signed long)((double)((double)smProductSetting->PickingSoftlandingSpeed_percent / 100.0) * (double)500));
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Picking Softlanding Speed_percent %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 2 Picking Softlanding Speed_percent to %lf in %ums.\n", (double)(((double)smProductSetting->PickingSoftlandingSpeedAtInputJedecTray_percent / 100.0) * (double)smProductSetting->PickingSoftlandingSpeed), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}


		nError = m_cProductMotorControl->THKSoftlandingPick(1);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2ZAxisMotorMoveToInputTraySoftlandingPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis Move To Input Tray Softlanding Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 1210: //Move to output tray touching position
		if (m_cProductMotorControl->IsPickAndPlace2ZAxisMotorSafeToMove() == false)
		{
			break;
		}
		smProductProduction->PickAndPlace2ZAxisMovePosition = smProductTeachPoint->PickAndPlace2ZAxisAtOutputTrayTouchingPosition;
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2ZAxisMotorMove.Set = false;
		nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorMove(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2ZAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis Move to Output Tray Touching Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 1211: //Move to output tray down position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2ZAxisMotorMoveToOutputTrayDownPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2ZAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorMoveOutputDownPosition(m_cMotion, true);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2ZAxisMotorMoveToOutputTrayDownPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis Move To Output Tray Down Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 1212: //Move to output tray softlanding position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2ZAxisMotorMoveToOutputTraySoftlandingPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2ZAxisMotorSafeToMove() == false)
		{
			break;
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue1(1, (double)smProductSetting->PickUpHead2PlaceForce);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Place Force %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 2 Place Force %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue2(1, (signed long)smProductSetting->PickUpHead2PlacePressure);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Place Pressure %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 2 Place Pressure %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue3(1, (signed long)smProductSetting->PickUpHead2PlaceFlowRate);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Place Flow Rate %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Pick Up 2 Place Flow Rate %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue4(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtOutputTrayTouchingPosition
			- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PlacementGap_um);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Placement 2 Down Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cLogger->WriteLog("Done setting up Placement 1 Down Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}

		nError = m_cProductMotorControl->THKSetTargetValue7(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforePurging_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Placement 2 Delay For Pickup Head At Down Position Before Purging %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue8(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithPurging_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Placement 2 Delay For Pickup Head At Down Position With Purging %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue9(1, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPlacement_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Placement 2 Delay For Pickup Head At Softlanding Position For Placement %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue10(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtOutputTrayTouchingPosition
			- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PlacementGap_um + (signed long)smProductSetting->PlacementSoftlandingDistance_um);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Placement 2 Picking Softlanding Distance %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue11(1, (signed long)((double)((double)smProductSetting->PlacementSoftlandingSpeed_percent / 100.0) * (double)500));
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Placement 2 Picking Softlanding Speed_percent %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		if (smProductSetting->EnablePlaceSoftlanding == true)
		{
			nError = m_cProductMotorControl->THKSoftlandingPlace(1);
		}
		else
		{
			nError = m_cProductMotorControl->THKPlace(1);
		}
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2ZAxisMotorMoveToOutputTraySoftlandingPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis Move To Output Tray Softlanding Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 1213:
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Pick And Place 2 Z Axis Motor THK Read Encoder.\n");
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKReadEncoderValue(1, 0, &a);
		if (nError == 0)
		{
			if (smProductEvent->JobMode.Set == true)
			{

			}
			//smProductEvent->InputVisionXAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error read Pick And Place 2 Z Axis Motor THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 1214: // vacuum on
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 2 THK Vacumm On.\n");
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

		nError = m_cProductMotorControl->THKVacuumValveOn(1);
		if (nError == 0)
		{
			if (smProductEvent->JobMode.Set == true)
			{

			}
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error On vaccum Pick And Place 2 THK Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 1215: //vacuum off
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 2 THK Vacuum Off.\n");
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKVacuumValveOff(1);
		if (nError == 0)
		{
			if (smProductEvent->JobMode.Set == true)
			{

			}
			//smProductEvent->InputVisionXAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Off Vaccum THK Pick And Place 2 Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 1216: // valve on
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 2 THK Valve On.\n");
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKReleaseValveOn(1);
		if (nError == 0)
		{
			if (smProductEvent->JobMode.Set == true)
			{

			}
			//smProductEvent->InputVisionXAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Release Valve Pick And Place 2 THK Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 1217: //valve off
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 2 THK Valve Off.\n");
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKReleaseValveOff(1);
		if (nError == 0)
		{
			if (smProductEvent->JobMode.Set == true)
			{

			}
			//smProductEvent->InputVisionXAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Off Valve THK Pick And Place 2 %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 1218: //Servo status
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 2 Z Axis THK Read Servo Status.\n");
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKReadMotorServoStatus(1, 0);
		if (nError == 0)
		{
			if (smProductEvent->JobMode.Set == true)
			{

			}
			//smProductEvent->InputVisionXAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Read Servo Status THK Pick And Place 2 Z Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 1219: //reset alarm
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 2 THK Reset Alarm.\n");
		nError = m_cProductMotorControl->THKResetAlarm(1);
		if (nError == 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 THK Reset Alarm Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Reset Alarm THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 1220: //change target value
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 2 THK Change Target Value.\n");
		nError = m_cProductMotorControl->THKSetTargetValue(1, 1, -9);
		if (nError == 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 THK Change Target Value Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Change Target Value THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 1221: //Pick
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 2 THK trigger Pick Sequence.\n");
		nError = m_cProductMotorControl->THKPick(1);
		if (nError == 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 THK Trigger Pick Sequence Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 THK Trigger Pick Sequence THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;
	case 1222://Place
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 2 THK trigger Place Sequence.\n");
		nError += m_cProductMotorControl->THKSetTargetValue1(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtOutputTrayTouchingPosition
			- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um
			+ (signed long)smProductSetting->PlacementGap_um + (signed long)smProductSetting->PlacementSoftlandingDistance_um);

		nError += m_cProductMotorControl->THKSetTargetValue3(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtOutputTrayTouchingPosition
			- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PlacementGap_um);

		nError += m_cProductMotorControl->THKSetTargetValue5(1, (double)smProductSetting->PickUpHead2PlaceForce);

		nError += m_cProductMotorControl->THKSetTargetValue6(1, (signed long)smProductSetting->PickUpHead2Pressure);

		nError += m_cProductMotorControl->THKSetTargetValue9(1, (signed long)((double)((double)smProductSetting->PlacementSoftlandingSpeed_percent / 100.0) * (double)500));

		nError += m_cProductMotorControl->THKSetTargetValue10(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforePurging_ms);

		nError += m_cProductMotorControl->THKSetTargetValue11(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithPurging_ms);

		nError += m_cProductMotorControl->THKSetTargetValue12(1, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPlacement_ms);

		if (smProductSetting->EnablePlaceSoftlanding == true)
		{
			nError += m_cProductMotorControl->THKSoftlandingPlace(1);
		}
		else
		{
			nError += m_cProductMotorControl->THKPlace(1);
		}
		if (nError == 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 THK Trigger Place Sequence Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 THK Trigger Place Sequence THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;


	case 1223: //Pick And Place 2 Softlanding Pick
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 2 THK trigger Softlanding Pick Sequence.\n");
		smProductEvent->StartPickAndPlace2ZAxisMotorMoveToInputTraySoftlandingPosition.Set = false;
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

		nError = m_cProductMotorControl->THKSetTargetValue1(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtInputTrayTouchingPosition
			- (signed long)smProductSetting->InputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um
			+ (signed long)smProductSetting->PickingGap_um + (signed long)smProductSetting->Picking2SoftlandingDistance_um);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Softlanding Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue2(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtInputTrayTouchingPosition
			- (signed long)smProductSetting->InputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PickingGap_um);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Picking Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue4(1, (double)smProductSetting->PickUpHead2Force);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Force Target %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue6(1, (signed long)smProductSetting->PickUpHead2Pressure);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Pressure Value %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue8(1, (signed long)((double)((double)smProductSetting->PickingSoftlandingSpeed_percent / 100.0) * (double)500));
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Softlanding Speed %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue10(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOn_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Down Position Before Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue11(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOn_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Down Position With Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSetTargetValue12(1, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPicking_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Softlanding Position For Picking %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		nError = m_cProductMotorControl->THKSoftlandingPick(1);
		//nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorMoveInputDownPosition(cMotion, false);
		if (nError == 0)
		{
			smProductEvent->StartPickAndPlace2ZAxisMotorMoveUpPosition.Set = false;
			nError = m_cProductMotorControl->THKSetTargetValue1(1, (signed long)(smProductTeachPoint->PickAndPlace2ZAxisUpPosition + signed long(smProductSetting->UnitThickness_um)));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Z Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}

			nError = m_cProductMotorControl->THKMoveUpSequence(1);
			if (nError == 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 THK Trigger Softlanding Pick Sequence Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 THK Trigger Softlanding Pick Sequence THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error move to Input tray Softlanding position Pick And Place 2 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
			//return nError;
		}
		
		break;

	case 1224: //Pick And Place 2 Softlanding Place
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 2 THK trigger Softlanding Pick Sequence.\n");
		smProductEvent->StartPickAndPlace2ZAxisMotorMoveToOutputTraySoftlandingPosition.Set = false;

		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue1(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtOutputTrayTouchingPosition
			- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um
			+ (signed long)smProductSetting->PlacementGap_um + (signed long)smProductSetting->PlacementSoftlandingDistance_um);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Place Softlanding Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue3(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtOutputTrayTouchingPosition
			- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um
			+ (signed long)smProductSetting->PlacementGap_um);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Placement Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue5(1, (double)smProductSetting->PickUpHead2PlaceForce);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Place Force Target %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
	
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKSetTargetValue6(1, (signed long)smProductSetting->PickUpHead2PlacePressure);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Place Pressure Value %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		
		nError = m_cProductMotorControl->THKSetTargetValue9(1, (signed long)((double)((double)smProductSetting->PlacementSoftlandingSpeed_percent / 100.0) * (double)500));
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Place Softlanding Speed %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		
		nError = m_cProductMotorControl->THKSetTargetValue10(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforePurging_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Down Position Before Purging %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
	
		nError = m_cProductMotorControl->THKSetTargetValue11(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithPurging_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Down Position With Purging %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		
		nError = m_cProductMotorControl->THKSetTargetValue12(1, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPlacement_ms);
		if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Softlanding Position For Placement %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		
		if (smProductSetting->EnablePlaceSoftlanding == true)
		{
			nError = m_cProductMotorControl->THKSoftlandingPlace(1);
		}
		else
		{
			nError = m_cProductMotorControl->THKPlace(1);
		}
		//nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorMoveOutputDownPosition(cMotion, false);
		if (nError == 0)
		{
			lnDelayIn100ns.QuadPart = lConvert1msTo100ns * (LONGLONG)smProductSetting->DelayForPickupHeadAtDownPositionAfterPurging_ms;
			RtSleepFt(&lnDelayIn100ns);

			smProductEvent->StartPickAndPlace2ZAxisMotorMoveUpPosition.Set = false;
			nError = m_cProductMotorControl->THKSetTargetValue1(1, (signed long)(smProductTeachPoint->PickAndPlace2ZAxisUpPosition + signed long(smProductSetting->UnitThickness_um)));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Z Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				//m_cLogger->WriteLog("Done setting up Pick Up 1 Pressure to %lf in %ums.\n", (double)smProductSetting->PickUpHead1Pressure, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}

			nError = m_cProductMotorControl->THKMoveUpSequence(1);
			if (nError == 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 THK Trigger Softlanding Pick Sequence Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move to Up Position Pick And Place 2 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cLogger->WriteLog("Error move to Output Tray Softlanding Position Pick And Place 2 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		
		
		break;
		case 1225: //Pick And Place 2 Softlanding Pick At Output
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 2 THK trigger Softlanding Pick Sequence.\n");
			smProductEvent->StartPickAndPlace2ZAxisMotorMoveToOutputTraySoftlandingPositionForPicking.Set = false;

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

			nError = m_cProductMotorControl->THKSetTargetValue1(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtOutputTrayTouchingPosition
				- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um
				+ (signed long)smProductSetting->PickingGap_um_Output + (signed long)smProductSetting->PickingSoftlandingDistance_um_Output);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Softlanding Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue2(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisAtOutputTrayTouchingPosition
				- (signed long)smProductSetting->OutputPocketDepth_um + (signed long)smProductSetting->UnitThickness_um + (signed long)smProductSetting->PickingGap_um_Output);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Picking Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue4(1, (double)smProductSetting->PickUpHead2Force);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Force Target %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			nError = m_cProductMotorControl->THKSetTargetValue6(1, (signed long)smProductSetting->PickUpHead2Pressure);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Pressure Value %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue8(1, (signed long)((double)((double)smProductSetting->PickingSoftlandingSpeed_percent_Output / 100.0) * (double)500));
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Softlanding Speed %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue10(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionBeforeVacuumOn_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Down Position Before Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue11(1, (signed long)smProductSetting->DelayForPickupHeadAtDownPositionWithVacuumOn_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Down Position With Vacuum On %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			nError = m_cProductMotorControl->THKSetTargetValue12(1, (signed long)smProductSetting->DelayForPickupHeadAtSoftlandingPositionForPicking_ms);
			if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error setting up Pick Up 2 Delay For Pickup Head At Softlanding Position For Picking %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}

			nError = m_cProductMotorControl->THKSoftlandingPick(1);
			//nError = m_cProductMotorControl->PickAndPlace2ZAxisMotorMoveInputDownPosition(cMotion, false);
			if (nError == 0)
			{
				smProductEvent->StartPickAndPlace2ZAxisMotorMoveUpPosition.Set = false;
				nError = m_cProductMotorControl->THKSetTargetValue1(1, (signed long)(smProductTeachPoint->PickAndPlace2ZAxisUpPosition + signed long(smProductSetting->UnitThickness_um)));
				if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cLogger->WriteLog("Error setting up Pick Up 2 Z Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				}

				nError = m_cProductMotorControl->THKMoveUpSequence(1);
				if (nError == 0)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 THK Trigger Softlanding Pick Sequence Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				}
				else if (nError != 0)
				{
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 THK Trigger Softlanding Pick Sequence THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cLogger->WriteLog("Error move to Input tray Softlanding position Pick And Place 2 Z Axis Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
				//return nError;
			}

			break;
		case 1226:
			nSequenceNoPnP2 = 1;
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			while (smProductEvent->ExitRTX.Set == false)
			{
				switch (nSequenceNoPnP2)
				{
				case 1:
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nError = m_cProductMotorControl->THKReleaseValveOn(1);
					if (nError != 0)
					{
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
						m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Release Valve Pick And Place 2 THK Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoPnP2 = 999;
						break;
						//return nError;
					}
					else
					{
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						nSequenceNoPnP2 = 2;
					}
					break;
				case 2:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount >= (LONGLONG)smProductSetting->DelayForPickupHeadAtDownPositionWithPurgingAtInput_ms)
					{
						nSequenceNoPnP2 = 3;
					}
					break;
				case 3:
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nError = m_cProductMotorControl->THKReleaseValveOff(1);
					if (nError == 0)
					{
						m_cProductShareVariables->UpdateMessageToGUIAndLog("Off Valve THK Pick And Place 2 Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					else if (nError != 0)
					{
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
						m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Off Valve THK Pick And Place 2 %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//return nError;
					}
					nSequenceNoPnP2 = 999;
					break;
				default:
					return -1;
					break;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				if (smProductEvent->StopManualMode.Set == true)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("PnP Sequence Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				if (nSequenceNoPnP2 == 999)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("PnP Sequence Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			}
			break;
#pragma endregion

#pragma region 1300 : Pick And Place 2 Theta Axis Motor

	case 1301://Home
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2ThetaAxisMotorHome.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2ThetaAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2ThetaAxisMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2ThetaAxisMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Theta Axis Home %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1302://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->PickAndPlace2ThetaAxisMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Theta Axis motor on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 1303://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->PickAndPlace2ThetaAxisMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Theta Axis motor off %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1304: //Move to Standby position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartPickAndPlace2ThetaAxisMotorMoveStandbyPosition.Set = false;
		if (m_cProductMotorControl->IsPickAndPlace2ThetaAxisMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->PickAndPlace2ThetaAxisMotorMoveStandbyPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->PickAndPlace2ThetaAxisMotorMoveStandbyPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Theta Axis Move Standby Position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 1305://read encoder
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Pick And Place 2 Theta Axis Motor THK Read Encoder.\n");
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKReadEncoderValue(1, 1, &a);
		if (nError == 0)
		{
			if (smProductEvent->JobMode.Set == true)
			{

			}
			//smProductEvent->InputVisionXAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error read Pick And Place 2 Theta Axis Motor THK %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;

	case 1306: //Servo status
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Manualseq: Press Pick And Place 2 Theta Axis THK Read Servo Status.\n");
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->THKReadMotorServoStatus(1, 1);
		if (nError == 0)
		{
			if (smProductEvent->JobMode.Set == true)
			{

			}
			//smProductEvent->InputVisionXAxisMotorMoveDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Read Servo Status THK Pick And Place 2 Theta Axis Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
		break;

#pragma endregion

#pragma region 1400 : Input Vision Z Axis Motor
	case 1401:
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartInputVisionModuleMotorHome.Set = false;
		if (m_cProductMotorControl->IsInputVisionModuleMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->InputVisionModuleMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->InputVisionModuleMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Vision Module Z Axis Home %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1402://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->InputVisionModuleMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Vision Module motor on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 1403://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->InputVisionModuleMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Vision Module motor off %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1404: //Move to input vision focus position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartInputVisionModuleMotorMoveFocusPosition.Set = false;
		if (m_cProductMotorControl->IsInputVisionModuleMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->InputVisionModuleMotorMoveFocusPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->InputVisionModuleMotorMoveFocusPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Vision Module Move focus position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 1405:
		if (m_cProductMotorControl->IsInputVisionModuleMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->InputVisionModuleMovePosition = smProductTeachPoint->InputVisionZAxisForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->InputVisionModuleMovePosition = 0;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputVisionModuleMotorMove.Set = false;
			nError = m_cProductMotorControl->InputVisionModuleMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->InputVisionModuleMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Input Vision Module Motor Done in %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Input Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.\n");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 1406:
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Press Input Vision Module Move.\n");
		if (m_cProductMotorControl->IsInputVisionModuleMotorSafeToMove() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Not Safe To Move.\n");
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->InputVisionModuleMovePosition = smProductTeachPoint->InputVisionZAxisAtInputVisionFocusPosition;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->InputVisionModuleMovePosition += 1000;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartInputVisionModuleMotorMove.Set = false;
			nError = m_cProductMotorControl->InputVisionModuleMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->InputVisionModuleMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move Input Vision Module Motor Done in %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move Input Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.\n");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
#pragma endregion

#pragma region 1500 : S2 Vision Motor
	case 1501:
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartS2VisionModuleMotorHome.Set = false;
		if (m_cProductMotorControl->IsS2VisionModuleMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->S2VisionModuleMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->S2VisionModuleMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S2 Vision Module Axis Home %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1502://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->S2VisionModuleMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S2 Vision Module motor on %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 1503://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->S2VisionModuleMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S2 Vision Module motor off %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1504: //Move to S2 focus position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartS2VisionModuleMotorMoveFocusPosition.Set = false;
		if (m_cProductMotorControl->IsS2VisionModuleMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->S2VisionModuleMotorMoveFocusPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->S2VisionModuleMotorMoveFocusPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S2 Vision Module Move focus position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 1505:
		if (m_cProductMotorControl->IsS2VisionModuleMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->S2VisionModuleMovePosition = smProductTeachPoint->S2VisionForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->S2VisionModuleMovePosition = 0;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS2VisionModuleMotorMove.Set = false;
			nError = m_cProductMotorControl->S2VisionModuleMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->S2VisionModuleMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move S2 Vision Module Motor Done in %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move S2 Vision Module Motor %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.\n");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 1506:
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Press S2 Vision Motor Move.\n");
		if (m_cProductMotorControl->IsS2VisionModuleMotorSafeToMove() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Motor Not Safe To Move.\n");
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->S2VisionModuleMovePosition = smProductTeachPoint->S2VisionFocusPosition;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->S2VisionModuleMovePosition += 10000;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS2VisionModuleMotorMove.Set = false;
			nError = m_cProductMotorControl->S2VisionModuleMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->S2VisionModuleMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move S2 Vision Module Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move S2 Vision Module Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
#pragma endregion

#pragma region 1600 : S1 Vision Motor
	case 1601:
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartS1VisionModuleMotorHome.Set = false;
		if (m_cProductMotorControl->IsS1VisionModuleMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->S1VisionModuleMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->S1VisionModuleMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S1 Vision Module Home %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1602://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->S1VisionModuleMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S1 Vision Module motor on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 1603://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->S1VisionModuleMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S1 Vision Module motor off %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 1604: //Move to Side Wall Vision Left reference focus position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartS1VisionModuleMotorMoveFocusPosition.Set = false;
		if (m_cProductMotorControl->IsS1VisionModuleMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->S1VisionModuleMotorMoveFocusPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->S1VisionModuleMotorMoveFocusPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S1 Vision Module Move reference focus position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 1605:
		if (m_cProductMotorControl->IsS1VisionModuleMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->S1VisionModuleMovePosition = smProductTeachPoint->S1VisionForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->S1VisionModuleMovePosition = 0;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS1VisionModuleMotorMove.Set = false;
			nError = m_cProductMotorControl->S1VisionModuleMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->S1VisionModuleMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move S1 Vision Module Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move S1 Vision Module Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.\n");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 1606:
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Press S1 Vision Vision Move.\n");
		if (m_cProductMotorControl->IsS1VisionModuleMotorSafeToMove() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Vision Not Safe To Move.\n");
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->S1VisionModuleMovePosition = smProductTeachPoint->S1VisionFocusPosition;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->S1VisionModuleMovePosition += 1000;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS1VisionModuleMotorMove.Set = false;
			nError = m_cProductMotorControl->S1VisionModuleMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->S1VisionModuleMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move S1 Vision Module Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move S1 Vision Module Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
#pragma endregion

#pragma region 2000 : S3 Vision Motor
	case 2001://home
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartS3VisionModuleMotorHome.Set = false;
		if (m_cProductMotorControl->IsS3VisionModuleMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->S3VisionModuleMotorHome(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->S3VisionModuleMotorHomeDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S3 Vision Module Home %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 2002://Motor On
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->S3VisionModuleMotorOn(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S3 Vision Module motor on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;


	case 2003://Motor Off
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = m_cProductMotorControl->S3VisionModuleMotorOff(m_cMotion);
		if (nError == 0)
		{

		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S3 Vision Module motor off %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;

	case 2004: //Move to S3 focus position
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		smProductEvent->StartS3VisionModuleMotorMoveFocusPosition.Set = false;
		if (m_cProductMotorControl->IsS3VisionModuleMotorSafeToMove() == false)
		{
			break;
		}
		nError = m_cProductMotorControl->S3VisionModuleMotorMoveFocusPosition(m_cMotion);
		if (nError == 0)
		{
			smProductEvent->S3VisionModuleMotorMoveFocusPositionDone.Set = true;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S3 Vision Module Move focus position %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
		break;
	case 2005:
		if (m_cProductMotorControl->IsS3VisionModuleMotorSafeToMove() == false)
		{
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->S3VisionModuleMovePosition = smProductTeachPoint->S3VisionForwardLimitPosition - 5000;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->S3VisionModuleMovePosition = 0;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS3VisionModuleMotorMove.Set = false;
			nError = m_cProductMotorControl->S3VisionModuleMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->S3VisionModuleMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move S3 Vision Module Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);


			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move S3 Vision Module Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
	case 2006:
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Press S3 Vision Motor Move.");
		if (m_cProductMotorControl->IsS3VisionModuleMotorSafeToMove() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Motor Not Safe To Move.");
			break;
		}
		m_bManualThreadMoveTop = true;
		while (smProductEvent->ExitRTX.Set == false)
		{
			if (m_bManualThreadMoveTop == true)
			{
				smProductProduction->S3VisionModuleMovePosition = smProductTeachPoint->S3VisionFocusPosition;
				m_bManualThreadMoveTop = false;
			}
			else if (m_bManualThreadMoveTop == false)
			{
				m_bManualThreadMoveTop = true;
				smProductProduction->S3VisionModuleMovePosition += 1000;
			}

			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			smProductEvent->StartS3VisionModuleMotorMove.Set = false;
			nError = m_cProductMotorControl->S3VisionModuleMotorMove(m_cMotion);
			if (nError == 0)
			{
				smProductEvent->S3VisionModuleMotorMoveDone.Set = true;
				if (smProductEvent->JobMode.Set == true)
				{

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualSeq: Move S3 Vision Module Motor Done in %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			}
			else if (nError != 0)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Error move S3 Vision Module Motor %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return nError;
			}
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Stop Manual Mode.");
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_500ms);
		}
		break;
#pragma endregion
#pragma region 3000 : Vision Calibration

#pragma endregion

#pragma region 5000 sequence
#pragma region 5000 input loading sequence
	case 5000:
		if (smProductCustomize->EnableInputTrayTableXAxisMotor)
		{
			smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableXAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputTrayTableYAxisMotor)
		{
			smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableYAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputTrayTableZAxisMotor)
		{
			smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableZAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableXAxisMotor)
		{
			smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableXAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableYAxisMotor)
		{
			smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableYAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableZAxisMotor)
		{
			smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableZAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputVisionMotor)
		{
			smProductEvent->InputVisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartInputVisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS2VisionMotor)
		{
			smProductEvent->S2VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS2VisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS1VisionMotor)
		{
			smProductEvent->S1VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS1VisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS3VisionMotor)
		{
			smProductEvent->S3VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS3VisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace1XAxisMotor == true)
		{
			smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1XAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace1YAxisMotor == true)
		{
			smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1YAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace1Module == true)
		{
			smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1ZAxisMotorSettingUp.Set = true;

			smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1ThetaAxisMotorSettingUp.Set = true;
		}

		if (smProductCustomize->EnablePickAndPlace2XAxisMotor == true)
		{
			smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2XAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace2YAxisMotor == true)
		{
			smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2YAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace2Module == true)
		{
			smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2ZAxisMotorSettingUp.Set = true;

			smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2ThetaAxisMotorSettingUp.Set = true;

		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		while(smProductEvent->ExitRTX.Set==false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		
			if (true			
				&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set == true))			
				&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set == true))			
				&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set == true))			
				&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set == true))			
				&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set == true))			
				&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set == true))			
				&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorSettingUpDone.Set == true))			
				&& (smProductCustomize->EnableS2VisionMotor == false || (smProductCustomize->EnableS2VisionMotor == true && smProductEvent->S2VisionModuleMotorSettingUpDone.Set == true))			
				&& (smProductCustomize->EnableS1VisionMotor == false || (smProductCustomize->EnableS1VisionMotor == true && smProductEvent->S1VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS3VisionMotor == false || (smProductCustomize->EnableS3VisionMotor == true && smProductEvent->S3VisionModuleMotorSettingUpDone.Set == true))			
				&& (smProductCustomize->EnablePickAndPlace1XAxisMotor == false || (smProductCustomize->EnablePickAndPlace1XAxisMotor == true && smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set == true))	
				&& (smProductCustomize->EnablePickAndPlace1YAxisMotor == false || (smProductCustomize->EnablePickAndPlace1YAxisMotor == true && smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set == true))		
				&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set == true))	
				&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set == true))		
				&& (smProductCustomize->EnablePickAndPlace2XAxisMotor == false || (smProductCustomize->EnablePickAndPlace2XAxisMotor == true && smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set == true))		
				&& (smProductCustomize->EnablePickAndPlace2YAxisMotor == false || (smProductCustomize->EnablePickAndPlace2YAxisMotor == true && smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set == true))		
				&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set == true))			
				&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set == true))			
				)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("All Motor Setting up Done %ums\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		smProductEvent->RSEQ_RINT_SEQUENCE_START.Set = true;
		nSequenceNo = nCase.WaitingToReceiveEventStartInputTrayTableSequence;
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		while (smProductEvent->ExitRTX.Set == false)
		{
			switch(nSequenceNo)
			{
			case nCase.WaitingToReceiveEventStartInputTrayTableSequence:
				if (smProductEvent->RSEQ_RINT_SEQUENCE_START.Set == true)
				{
					smProductEvent->RSEQ_RINT_SEQUENCE_START.Set = false;
					m_cLogger->WriteLog("ManualInputLoadingSeq: Come in.\n");
					nSequenceNo = nCase.IsInputTrayTableZAxisAtDownPosition;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				}
				break;

			case nCase.IsInputTrayTableZAxisAtDownPosition:
				//if (smProductEvent->JobStop.Set == true)
				//{
				//	m_cLogger->WriteLog("ManualInputLoadingSeq: User stop sequence.\n");
				//	nSequenceNo = nCase.EndOfSequence;
				//	break;
				//}
				if (m_cProductMotorControl->IsInputTrayTableXAxisMotorSafeToMove() == false || m_cProductMotorControl->IsInputTrayTableYAxisMotorSafeToMove() == false)
				{
					m_cProductShareVariables->SetAlarm(43010);
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Not At Down Position");
					nSequenceNo = nCase.EndOfSequence;
					break;
				}
				else
				{
					nSequenceNo = nCase.IsInputTrayTableReady;
				}
				break;

			case nCase.IsInputTrayTableReady:
				//if (smProductEvent->JobStop.Set == true)
				//{
				//	m_cLogger->WriteLog("ManualInputLoadingSeq: User stop sequence.\n");
				//	nSequenceNo = nCase.EndOfSequence;
				//	break;
				//}
				if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == false)
				{
					if (m_cProductIOControl->IsInputLoadingStackerPresentSensorOn() == true)
					{
						nSequenceNo = nCase.StartMoveInputTrayTableXYAxisToLoadingPosition;
					}
					else
					{
						m_cProductShareVariables->SetAlarm(5402);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Tray not present on input loading stacker.\n");
						nSequenceNo = nCase.EndOfSequence;
						break;
					}
				}
				else if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == true)
				{
					nSequenceNo = nCase.StartMoveInputTrayTableXYVisionZAxisToFirstPosition;
				}
				break;

			case nCase.StartMoveInputTrayTableXYAxisToLoadingPosition:
				//if (smProductEvent->JobStop.Set == true)
				//{
				//	m_cLogger->WriteLog("ManualInputLoadingSeq: User stop sequence.\n");
				//	nSequenceNo = nCase.EndOfSequence;
				//	break;
				//}
				if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
				{
					smProductEvent->InputTrayTableXAxisMotorMoveLoadDone.Set = false;
					smProductEvent->StartInputTrayTableXAxisMotorMoveLoad.Set = true;
				}
				if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
				{
					smProductEvent->InputTrayTableYAxisMotorMoveLoadDone.Set = false;
					smProductEvent->StartInputTrayTableYAxisMotorMoveLoad.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableXYAxisToLoadingPositionDone;
				break;
			case nCase.IsMoveInputTrayTableXYAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveLoadDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveLoadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis Motor move load position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToLoadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis move load position Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);

					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveLoadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(41002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Axis Motor Move Loading position timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveLoadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(42002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Y Axis Motor Move Loading position timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNo = nCase.StopMoveInputTrayTableXYAxisToLoadingPosition;
				}
				break;
			case nCase.StopMoveInputTrayTableXYAxisToLoadingPosition:

				if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
				{
					smProductEvent->InputTrayTableXAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableXAxisMotorStop.Set = true;
				}
				if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
				{
					smProductEvent->InputTrayTableYAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableYAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableXYAxisToLoadingPositionDone;
				break;
			case nCase.IsStopMoveInputTrayTableXYAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableXYAxisToLoadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(41008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(42008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Y Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableXYAxisToLoadingPosition;
				}
				break;
			case nCase.StartMoveInputTrayTableZAxisToLoadingPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorMoveLoadDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorMoveLoad.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableZAxisToLoadingPositionDone;
				break;
			case nCase.IsMoveInputTrayTableZAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveLoadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor move loading position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.InputLoadingStackerUnlockCylinderUnlock;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveLoadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Move Loading timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToLoadingPosition;
				}
				break;
			case nCase.StopMoveInputTrayTableZAxisToLoadingPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToLoadingPositionDone;
				break;
			case nCase.IsStopMoveInputTrayTableZAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToLoadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToLoadingPosition;
				}
				break;
			case nCase.InputLoadingStackerUnlockCylinderUnlock:
				m_cProductIOControl->SetInputLoadingStackerUnlockCylinderOn(true);
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsInputLoadingStackerUnlockCylinderUnlock;
				break;

			case nCase.IsInputLoadingStackerUnlockCylinderUnlock:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsInputLoadingStackerUnlockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Loading Stacker Cylinder Unlock done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToSingulationPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsInputLoadingStackerUnlockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5404);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Loading Stacker Cylinder Unlock Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.InputLoadingStackerUnlockCylinderUnlock;
				}
				break;
			case nCase.StartMoveInputTrayTableZAxisToSingulationPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorMoveSingulation.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableZAxisToSingulationPositionDone;
				break;
			case nCase.IsMoveInputTrayTableZAxisToSingulationPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor move singulation position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.InputLoadingStackerUnlockCylinderLock;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Move Singulation timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToSingulationPosition;
				}
				break;
			case nCase.StopMoveInputTrayTableZAxisToSingulationPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToSingulationPositionDone;
				break;
			case nCase.IsStopMoveInputTrayTableZAxisToSingulationPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToSingulationPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToSingulationPosition;
				}
				break;
			case nCase.InputLoadingStackerUnlockCylinderLock:
				m_cProductIOControl->SetInputLoadingStackerUnlockCylinderOn(false);
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsInputLoadingStackerUnlockCylinderLock;
				break;

			case nCase.IsInputLoadingStackerUnlockCylinderLock:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsInputLoadingStackerLockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Loading Stacker Cylinder lock done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToDownPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsInputLoadingStackerLockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5403);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Loading Stacker Cylinder lock Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.InputLoadingStackerUnlockCylinderLock;
				}
				break;
			case nCase.StartMoveInputTrayTableZAxisToDownPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorMoveDown.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableZAxisToDownPositionDone;
				break;
			case nCase.IsMoveInputTrayTableZAxisToDownPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == false)
				{

					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
					{
						smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToDownPositionAfterTrayNotPresent;
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Tray Not Present %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor move down position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.IsInputTrayTableReady;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Move down timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToDownPosition;
				}
				break;
			case nCase.IsStopMoveInputTrayTableZAxisToDownPositionAfterTrayNotPresent:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1s);
					nSequenceNo = nCase.CheckIsTrayPresentOnInputTrayTableDuringDown;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
					{
						smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
					}
					nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToDownPositionAfterTrayNotPresent;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				}
				break;
			case nCase.CheckIsTrayPresentOnInputTrayTableDuringDown:
				if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == false)
				{
					//if()if time >preset,then
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 5000)//(LONGLONG)smProductProduction->InputTrayPresentSensorOffTimeBeforeAlarm_ms)
					{
						m_cProductShareVariables->SetAlarm(5510);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Tray Not Present %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//nSequenceNo = nCase.StopMoveInputTrayTableZAxisDownAtLoading;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						break;
					}
				}
				else if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == true)

				{
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToDownPosition;
				}
				break;
			case nCase.StopMoveInputTrayTableZAxisToDownPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToDownPositionDone;
				break;

			case nCase.IsStopMoveInputTrayTableZAxisToDownPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToDownPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToDownPosition;
				}
				break;
			case nCase.StartMoveInputTrayTableXYVisionZAxisToFirstPosition:
				//if (smProductEvent->JobStop.Set == true)
				//{
				//	m_cLogger->WriteLog("InputTrayTableseq: User stop sequence.\n");
				//	nSequenceNo = nCase.EndOfSequence;
				//	break;
				//}
				//Need to set move position
				smProductProduction->InputTrayTableXAxisMovePosition = smProductTeachPoint->InputTrayTableXAxisAtInputTrayTableCenterPosition + signed long(smProductSetting->DeviceXPitchInput * ((double)(smProductSetting->NoOfDeviceInRowInput - 1) / 2));
				smProductProduction->InputTrayTableYAxisMovePosition = smProductTeachPoint->InputTrayTableYAxisAtInputTrayTableCenterPosition + signed long(smProductSetting->DeviceYPitchInput * ((double)(smProductSetting->NoOfDeviceInColInput - 1) / 2));
				smProductProduction->InputTableResult[0].InputTrayNo = smProductProduction->nCurrentInputTrayNo;
				smProductProduction->InputTableResult[0].InputColumn = smProductProduction->nEdgeCoordinateY;
				smProductProduction->InputTableResult[0].InputRow = smProductProduction->nEdgeCoordinateX;
				if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
				{
					smProductEvent->InputTrayTableXAxisMotorMoveDone.Set = false;
					smProductEvent->StartInputTrayTableXAxisMotorMove.Set = true;
				}
				if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
				{
					smProductEvent->InputTrayTableYAxisMotorMoveDone.Set = false;
					smProductEvent->StartInputTrayTableYAxisMotorMove.Set = true;
				}
				if (smProductCustomize->EnableInputVisionMotor == true)
				{
					smProductEvent->InputVisionModuleMotorMoveFocusPositionDone.Set = false;
					smProductEvent->StartInputVisionModuleMotorMoveFocusPosition.Set = true;
				}
				//if (smProductSetting->EnableVision == true && smProductSetting->EnableInputVision == true && smProductCustomize->EnableInputVisionModule == true)
				//{
				//	smProductEvent->GMAIN_RTHD_INP_VISION_GET_RC_DONE.Set = false;
				//	smProductEvent->RTHD_GMAIN_SEND_INP_VISION_RC_START.Set = true;
				//}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableXYVisionZAxisToFirstPositionDone;
				break;
			case nCase.IsMoveInputTrayTableXYVisionZAxisToFirstPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveDone.Set == true))
					&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorMoveFocusPositionDone.Set == true))
					//&& ((smProductEvent->GMAIN_RTHD_INP_VISION_GET_RC_DONE.Set == true && smProductSetting->EnableVision == true && smProductSetting->EnableInputVision == true && smProductCustomize->EnableInputVisionModule == true)
					//	|| (smProductSetting->EnableVision == false || smProductSetting->EnableInputVision == false || smProductCustomize->EnableInputVisionModule == false))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y move to first position done, Input Vision Module Z Axis Move to focus position done and Send Input Vision Row and column done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.EndOfSequence;
				}

				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y move to first position timeout, Input Vision Module Z Axis Move to focus position and Send input vision row and column Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					//if (smProductEvent->GMAIN_RTHD_INP_VISION_GET_RC_DONE.Set == false && smProductSetting->EnableVision == true && smProductSetting->EnableInputVision == true && smProductCustomize->EnableInputVisionModule == true)
					//{
					//	m_cProductShareVariables->SetAlarm(6109);
					//	m_cLogger->WriteLog("ManualInputLoadingSeq: Input Vision receive column and row timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					//	nSequenceNo = nCase.StartSendInputVisionRowAndColumn;
					//}
					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(41002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Axis Motor Move to first position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.StopMoveInputTrayTableXYVisionZAxisToFirstPosition;
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(42002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Y Axis Motor Move to first position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.StopMoveInputTrayTableXYVisionZAxisToFirstPosition;
					}
					if (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorMoveFocusPositionDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(48002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Vision Z Axis Motor Move to focus position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.StopMoveInputTrayTableXYVisionZAxisToFirstPosition;
					}

				}
				break;
			case nCase.StopMoveInputTrayTableXYVisionZAxisToFirstPosition:
				if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
				{
					smProductEvent->InputTrayTableXAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableXAxisMotorStop.Set = true;
				}
				if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
				{
					smProductEvent->InputTrayTableYAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableYAxisMotorStop.Set = true;
				}
				if (smProductCustomize->EnableInputVisionMotor == true)
				{
					smProductEvent->InputVisionModuleMotorStopDone.Set = false;
					smProductEvent->StartInputVisionModuleMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableXYVisionZAxisToFirstPositionDone;
				break;
			case nCase.IsStopMoveInputTrayTableXYVisionZAxisToFirstPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == true))
					&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis and Input Vision Module Z Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableXYVisionZAxisToFirstPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis and Input Vision Module Z Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(41008);
						m_cLogger->WriteLog("Input Tray Table X Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(42008);
						m_cLogger->WriteLog("Input Tray Table Y Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(48008);
						m_cLogger->WriteLog("Input Vision Z Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableXYVisionZAxisToFirstPosition;
				}
				break;

			default:
				return -1;
				break;
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Loading Unloading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			if (nSequenceNo == nCase.EndOfSequence)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Loading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		break;
#pragma endregion

#pragma region 5001 input unloading sequence
	case 5001:
		if (smProductCustomize->EnableInputTrayTableXAxisMotor)
		{
			smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableXAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputTrayTableYAxisMotor)
		{
			smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableYAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputTrayTableZAxisMotor)
		{
			smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableZAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableXAxisMotor)
		{
			smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableXAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableYAxisMotor)
		{
			smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableYAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableZAxisMotor)
		{
			smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableZAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputVisionMotor)
		{
			smProductEvent->InputVisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartInputVisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS2VisionMotor)
		{
			smProductEvent->S2VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS2VisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS1VisionMotor)
		{
			smProductEvent->S1VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS1VisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS3VisionMotor)
		{
			smProductEvent->S3VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS3VisionModuleMotorSettingUp.Set = true;
		}

		if (smProductCustomize->EnablePickAndPlace1XAxisMotor == true)
		{
			smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1XAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace1YAxisMotor == true)
		{
			smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1YAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace1Module == true)
		{
			smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1ZAxisMotorSettingUp.Set = true;

			smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1ThetaAxisMotorSettingUp.Set = true;
		}

		if (smProductCustomize->EnablePickAndPlace2XAxisMotor == true)
		{
			smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2XAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace2YAxisMotor == true)
		{
			smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2YAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace2Module == true)
		{
			smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2ZAxisMotorSettingUp.Set = true;

			smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2ThetaAxisMotorSettingUp.Set = true;

		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

			if (true
				&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS2VisionMotor == false || (smProductCustomize->EnableS2VisionMotor == true && smProductEvent->S2VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS1VisionMotor == false || (smProductCustomize->EnableS1VisionMotor == true && smProductEvent->S1VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS3VisionMotor == false || (smProductCustomize->EnableS3VisionMotor == true && smProductEvent->S3VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1XAxisMotor == false || (smProductCustomize->EnablePickAndPlace1XAxisMotor == true && smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1YAxisMotor == false || (smProductCustomize->EnablePickAndPlace1YAxisMotor == true && smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2XAxisMotor == false || (smProductCustomize->EnablePickAndPlace2XAxisMotor == true && smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2YAxisMotor == false || (smProductCustomize->EnablePickAndPlace2YAxisMotor == true && smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set == true))
				)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("All Motor Setting up Done %ums\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		nSequenceNo= nCase.StartMoveInputTrayTableXYAxisToUnloadingPosition;
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		while (smProductEvent->ExitRTX.Set == false)
		{
			switch (nSequenceNo)
			{
#pragma region Unloading
			case nCase.StartMoveInputTrayTableXYAxisToUnloadingPosition:
				if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == false)
				{
					m_cProductShareVariables->SetAlarm(5510);
					m_cLogger->WriteLog("ManualInputLoadingSeq: Tray not present on input tray table.\n");
					nSequenceNo = nCase.EndOfSequence;
					break;

				}
				else
				{
					if (m_cProductIOControl->IsInputUnloadingStackerFullSensorOn() == true)
					{
						m_cProductShareVariables->SetAlarm(5405);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Tray full on input unloading stacker.\n");
						nSequenceNo = nCase.EndOfSequence;
						break;
					}
				}
				if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
				{
					smProductEvent->InputTrayTableXAxisMotorMoveUnloadDone.Set = false;
					smProductEvent->StartInputTrayTableXAxisMotorMoveUnload.Set = true;
				}
				if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
				{
					smProductEvent->InputTrayTableYAxisMotorMoveUnloadDone.Set = false;
					smProductEvent->StartInputTrayTableYAxisMotorMoveUnload.Set = true;
				}

				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableXYAxisToUnloadingPositionDone;
				break;
			case nCase.IsMoveInputTrayTableXYAxisToUnloadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveUnloadDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveUnloadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table X Y Axis Move to Unloading position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToSingulationPositionForUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table X Y Axis Move to Unloading position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveUnloadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(41002);
						m_cLogger->WriteLog("Input Tray Table X Axis Motor Move to Unloading position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveUnloadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(42002);
						m_cLogger->WriteLog("Input Tray Table Y Axis Motor Move to Unloading position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableXYAxisToUnloadingPosition;
				}
				break;
			case nCase.StopMoveInputTrayTableXYAxisToUnloadingPosition:
				if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
				{
					smProductEvent->InputTrayTableXAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableXAxisMotorStop.Set = true;
				}
				if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
				{
					smProductEvent->InputTrayTableYAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableYAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableXYAxisToUnloadingPositionDone;
				break;
			case nCase.IsStopMoveInputTrayTableXYAxisToUnloadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table X Y Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableXYAxisToUnloadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table X Y Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(41008);
						m_cLogger->WriteLog("Input Tray Table X Axis Motor Move stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(42008);
						m_cLogger->WriteLog("Input Tray Table Y Axis Motor Move stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableXYAxisToUnloadingPosition;
				}
				break;
			case nCase.StartMoveInputTrayTableZAxisToSingulationPositionForUnloading:

				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorMoveSingulation.Set = true;
				}

				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableZAxisToSingulationPositionForUnloadingDone;
				break;
			case nCase.IsMoveInputTrayTableZAxisToSingulationPositionForUnloadingDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis Move to Singulation position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.InputUnloadingStackerUnlockCylinderUnlockForUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis Move to Singulation position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43002);
						m_cLogger->WriteLog("Input Tray Table Z Axis Motor Move to Singulation position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToSingulationPositionForUnloading;
				}
				break;
			case nCase.StopMoveInputTrayTableZAxisToSingulationPositionForUnloading:

				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToSingulationPositionForUnloadingDone;
				break;
			case nCase.IsStopMoveInputTrayTableZAxisToSingulationPositionForUnloadingDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToSingulationPositionForUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("Input Tray Table Z Axis Motor stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToSingulationPositionForUnloading;
				}
				break;
			case nCase.InputUnloadingStackerUnlockCylinderUnlockForUnloading:
				m_cProductIOControl->SetInputUnloadingStackerUnlockCylinderOn(true);
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsInputUnloadingStackerUnlockCylinderUnlockForUnloading;
				break;
			case nCase.IsInputUnloadingStackerUnlockCylinderUnlockForUnloading:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsInputUnloadingStackerUnlockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("InputTrayTableSeq: Input Unloading Stacker unlock cylinder done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToUnloadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsInputUnloadingStackerUnlockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5417);
						m_cLogger->WriteLog("Input Unloading Stacker unlock cylinder Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNo = nCase.InputUnloadingStackerUnlockCylinderUnlockForUnloading;
				}
				break;
			case nCase.StartMoveInputTrayTableZAxisToUnloadingPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorMoveUnloadDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorMoveUnload.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableZAxisToUnloadingPositionDone;
				break;
			case nCase.IsMoveInputTrayTableZAxisToUnloadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveUnloadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis Move to Unloading position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.InputUnloadingStackerUnlockCylinderLockForUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveUnloadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43002);
						m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis Motor Move to unload position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToUnloadingPosition;
				}
				break;
			case nCase.StopMoveInputTrayTableZAxisToUnloadingPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
				}

				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToUnloadingPositionDone;
				break;
			case nCase.IsStopMoveInputTrayTableZAxisToUnloadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToUnloadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis Motor stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToUnloadingPosition;
				}
				break;
			case nCase.InputUnloadingStackerUnlockCylinderLockForUnloading:
				m_cProductIOControl->SetInputUnloadingStackerUnlockCylinderOn(false);
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsInputUnloadingStackerUnlockCylinderLockForUnloading;
				break;
			case nCase.IsInputUnloadingStackerUnlockCylinderLockForUnloading:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsInputUnloadingStackerLockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Unloading Stacker lock cylinder done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToDownPositionAfterUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsInputUnloadingStackerLockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5407);
						m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Unloading Stacker lock cylinder Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.InputUnloadingStackerUnlockCylinderLockForUnloading;
				}
				break;
			case nCase.StartMoveInputTrayTableZAxisToDownPositionAfterUnloading:

				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorMoveDown.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableZAxisToDownPositionDoneAfterUnloading;
				break;
			case nCase.IsMoveInputTrayTableZAxisToDownPositionDoneAfterUnloading:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis Move to down position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					
						nSequenceNo = nCase.EndOfSequence;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveUnloadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43002);
						m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis Motor Move to unload position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToDownPositionAfterUnloading;
				}
				break;
			case nCase.StopMoveInputTrayTableZAxisToDownPositionAfterUnloading:

				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToDownPositionDoneAfterUnloading;
				break;
			case nCase.IsStopMoveInputTrayTableZAxisToDownPositionDoneAfterUnloading:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToDownPositionAfterUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis Motor stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToDownPositionAfterUnloading;
				}
				break;
#pragma endregion
			default:
				return -1;
				break;
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Loading Unloading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			if (nSequenceNo == nCase.EndOfSequence)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Unloading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		break;
#pragma endregion

#pragma region 5002 Output loading sequence
	case 5002:
		if (smProductCustomize->EnableInputTrayTableXAxisMotor)
		{
			smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableXAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputTrayTableYAxisMotor)
		{
			smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableYAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputTrayTableZAxisMotor)
		{
			smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableZAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableXAxisMotor)
		{
			smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableXAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableYAxisMotor)
		{
			smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableYAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableZAxisMotor)
		{
			smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableZAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputVisionMotor)
		{
			smProductEvent->InputVisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartInputVisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS2VisionMotor)
		{
			smProductEvent->S2VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS2VisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS1VisionMotor)
		{
			smProductEvent->S1VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS1VisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS3VisionMotor)
		{
			smProductEvent->S3VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS3VisionModuleMotorSettingUp.Set = true;
		}

		if (smProductCustomize->EnablePickAndPlace1XAxisMotor == true)
		{
			smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1XAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace1YAxisMotor == true)
		{
			smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1YAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace1Module == true)
		{
			smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1ZAxisMotorSettingUp.Set = true;

			smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1ThetaAxisMotorSettingUp.Set = true;
		}

		if (smProductCustomize->EnablePickAndPlace2XAxisMotor == true)
		{
			smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2XAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace2YAxisMotor == true)
		{
			smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2YAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace2Module == true)
		{
			smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2ZAxisMotorSettingUp.Set = true;

			smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2ThetaAxisMotorSettingUp.Set = true;

		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

			if (true
				&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS2VisionMotor == false || (smProductCustomize->EnableS2VisionMotor == true && smProductEvent->S2VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS1VisionMotor == false || (smProductCustomize->EnableS1VisionMotor == true && smProductEvent->S1VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS3VisionMotor == false || (smProductCustomize->EnableS3VisionMotor == true && smProductEvent->S3VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1XAxisMotor == false || (smProductCustomize->EnablePickAndPlace1XAxisMotor == true && smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1YAxisMotor == false || (smProductCustomize->EnablePickAndPlace1YAxisMotor == true && smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2XAxisMotor == false || (smProductCustomize->EnablePickAndPlace2XAxisMotor == true && smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2YAxisMotor == false || (smProductCustomize->EnablePickAndPlace2YAxisMotor == true && smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set == true))
				)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("All Motor Setting up Done %ums\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		smProductEvent->RSEQ_ROUT_SEQUENCE_START.Set = true;
		nSequenceNoOutput = nCase2.WaitingToReceiveEventStartOutputAndRejectTrayTableSequence;
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		while (smProductEvent->ExitRTX.Set == false)
		{
			switch (nSequenceNoOutput)
			{
			case nCase2.WaitingToReceiveEventStartOutputAndRejectTrayTableSequence:
				if (smProductEvent->RSEQ_ROUT_SEQUENCE_START.Set == true)
				{
					smProductEvent->RSEQ_ROUT_SEQUENCE_START.Set = false;
					smProductEvent->ROUT_RINT_OUTPUT_PRE_PRODUCTION_DONE.Set = false;
					smProductProduction->OutputTableCheckSequence = 5;
					smProductProduction->nRejectEdgeCoordinateX = 1;
					smProductProduction->nRejectEdgeCoordinateY = 1;
					smProductProduction->nOutputEdgeCoordinateX = 1;
					smProductProduction->nOutputEdgeCoordinateY = 1;
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Come in.\n");
					nSequenceNoOutput = nCase2.IsOutputTrayTableZAxisAtDownPosition;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				}
				break;
			case nCase2.IsOutputTrayTableZAxisAtDownPosition:
				//if (smProductEvent->JobStop.Set == true)
				//{
				//	m_cLogger->WriteLog("ManualOutputLoadingSeq: User stop sequence.\n");
				//	nSequenceNoOutput = nCase2.EndOfSequence;
				//	break;
				//}
				if (m_cProductMotorControl->IsOutputTrayTableXAxisMotorSafeToMove() == false || m_cProductMotorControl->IsOutputTrayTableYAxisMotorSafeToMove() == false)
				{
					m_cProductShareVariables->SetAlarm(47010);
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Not At Down Position");
					nSequenceNoOutput = nCase2.EndOfSequence;
					break;
				}
				else
				{
					nSequenceNoOutput = nCase2.IsOutputTrayTableReady;
				}
				break;

			case nCase2.IsOutputTrayTableReady:
				//if (smProductEvent->JobStop.Set == true)
				//{
				//	m_cLogger->WriteLog("ManualOutputLoadingSeq: User stop sequence.\n");
				//	nSequenceNoOutput = nCase2.EndOfSequence;
				//	break;
				//}
				if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == false)
				{
					if (m_cProductIOControl->IsOutputLoadingStackerPresentSensorOn() == true)
					{
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToLoadingPosition;
					}
					else
					{
						m_cProductShareVariables->SetAlarm(5410);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Tray not present on output loading stacker.\n");
						nSequenceNoOutput = nCase2.EndOfSequence;
						break;
					}
				}
				else if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == true)
				{
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToFirstPosition;
				}
				break;
			case nCase2.StartMoveOutputTrayTableXYAxisToLoadingPosition:
				//if (smProductEvent->JobStop.Set == true)
				//{
				//	m_cLogger->WriteLog("ManualOutputLoadingSeq: User stop sequence.\n");
				//	nSequenceNoOutput = nCase2.EndOfSequence;
				//	break;
				//}
				if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
				{
					smProductEvent->OutputTrayTableXAxisMotorMoveLoadDone.Set = false;
					smProductEvent->StartOutputTrayTableXAxisMotorMoveLoad.Set = true;
				}
				if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
				{
					smProductEvent->OutputTrayTableYAxisMotorMoveLoadDone.Set = false;
					smProductEvent->StartOutputTrayTableYAxisMotorMoveLoad.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableXYAxisToLoadingPositionDone;
				break;
			case nCase2.IsMoveOutputTrayTableXYAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveLoadDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveLoadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis Motor move load position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToLoadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis move load position Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveLoadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(45002);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Axis Motor Move Load timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveLoadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(46002);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Y Axis Motor Move Load timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToLoadingPosition;
				}
				break;
			case nCase2.StopMoveOutputTrayTableXYAxisToLoadingPosition:
				if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
				{
					smProductEvent->OutputTrayTableXAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableXAxisMotorStop.Set = true;
				}
				if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
				{
					smProductEvent->OutputTrayTableYAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableYAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableXYAxisToLoadingPositionDone;
				break;
			case nCase2.IsStopMoveOutputTrayTableXYAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToLoadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(45008);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(46008);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Y Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToLoadingPosition;
				}
				break;
			case nCase2.StartMoveOutputTrayTableZAxisToLoadingPosition:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorMoveLoadDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorMoveLoad.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToLoadingPositionDone;
				break;
			case nCase2.IsMoveOutputTrayTableZAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveLoadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor move loading position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.OutputLoadingStackerUnlockCylinderUnlock;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveLoadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47002);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Move Loading timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToLoadingPosition;
				}
				break;
			case nCase2.StopMoveOutputTrayTableZAxisToLoadingPosition:

				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
				}

				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToLoadingPositionDone;
				break;
			case nCase2.IsStopMoveOutputTrayTableZAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToLoadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{

					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47008);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToLoadingPosition;
				}
				break;
			case nCase2.OutputLoadingStackerUnlockCylinderUnlock:
				m_cProductIOControl->SetOutputLoadingStackerUnlockCylinderOn(true);

				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsOutputLoadingStackerUnlockCylinderUnlock;
				break;

			case nCase2.IsOutputLoadingStackerUnlockCylinderUnlock:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsOutputLoadingStackerUnlockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Loading Stacker Cylinder Unlock done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToSingulationPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsOutputLoadingStackerUnlockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5412);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Loading Stacker Cylinder Unlock Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNoOutput = nCase2.OutputLoadingStackerUnlockCylinderUnlock;
				}
				break;
			case nCase2.StartMoveOutputTrayTableZAxisToSingulationPosition:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorMoveSingulation.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToSingulationPositionDone;
				break;
			case nCase2.IsMoveOutputTrayTableZAxisToSingulationPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor move singulation position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.OutputLoadingStackerUnlockCylinderLock;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47002);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Move Singulation timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToSingulationPosition;
				}
				break;
			case nCase2.StopMoveOutputTrayTableZAxisToSingulationPosition:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToSingulationPositionDone;
				break;
			case nCase2.IsStopMoveOutputTrayTableZAxisToSingulationPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToSingulationPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47008);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToSingulationPosition;
				}
				break;
			case nCase2.OutputLoadingStackerUnlockCylinderLock:

				m_cProductIOControl->SetOutputLoadingStackerUnlockCylinderOn(false);

				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsOutputLoadingStackerUnlockCylinderLock;
				break;

			case nCase2.IsOutputLoadingStackerUnlockCylinderLock:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsOutputLoadingStackerLockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Loading Stacker Cylinder lock done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToDownPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsOutputLoadingStackerLockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5411);
						m_cLogger->WriteLog("ManualOutputLoadingSeq:  Output Loading Stacker Cylinder lock Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.OutputLoadingStackerUnlockCylinderLock;
				}
				break;
			case nCase2.StartMoveOutputTrayTableZAxisToDownPosition:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorMoveDown.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToDownPositionDone;
				break;

			case nCase2.IsMoveOutputTrayTableZAxisToDownPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == false)
				{

					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
					{
						smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionAfterTrayNotPresent;
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Tray Not Present %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor move down position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.IsOutputTrayTableReady;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47002);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Move down timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToDownPosition;
				}
				break;
			case nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionAfterTrayNotPresent:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.CheckIsTrayPresentOnOutputTrayTableDuringDown;
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1s);
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47008);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
					{
						smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
					}
					nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionAfterTrayNotPresent;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				}
				break;
			case nCase2.CheckIsTrayPresentOnOutputTrayTableDuringDown:
				if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == false)
				{
					//if()if time >preset,then
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > (LONGLONG)smProductProduction->TrayPresentSensorOffTimeBeforeAlarm_ms)
					{
						m_cProductShareVariables->SetAlarm(5511);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Tray Not Present %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//nSequenceNo = nCase.StopMoveInputTrayTableZAxisDownAtLoading;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						break;
					}
				}
				else if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == true)

				{
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToDownPosition;
				}
				break;
			case nCase2.StopMoveOutputTrayTableZAxisToDownPosition:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
				}

				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionDone;
				break;
			case nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToDownPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47008);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToDownPosition;
				}
				break;
			//case nCase2.IsRejectTrayTableReady:
			//	//if (smProductEvent->JobStop.Set == true)
			//	//{
			//	//	m_cLogger->WriteLog("ManualOutputLoadingSeq: User stop sequence.\n");
			//	//	nSequenceNoOutput = nCase2.EndOfSequence;
			//	//	break;
			//	//}
			//	if (TemporaryDisable = false && (m_cProductIOControl->IsRejectTrayPresentSensor1On() == false || m_cProductIOControl->IsRejectTrayPresentSensor2On() == false
			//		|| m_cProductIOControl->IsRejectTrayPresentSensor3On() == false || m_cProductIOControl->IsRejectTrayPresentSensor4On() == false
			//		|| m_cProductIOControl->IsRejectTrayPresentSensor5On() == false))
			//	{
			//		nSequenceNoOutput = nCase2.StartMoveRejectTrayTableXYAxisToManualLoadUnloadPosition;
			//	}
			//	else
			//	{
			//		nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToFirstPosition;
			//	}
			//	break;
			//case nCase2.StartMoveRejectTrayTableXYAxisToManualLoadUnloadPosition:
			//	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
			//	{
			//		smProductEvent->OutputTrayTableXAxisMotorMoveManualLoadUnloadDone.Set = false;
			//		smProductEvent->StartOutputTrayTableXAxisMotorMoveManualLoadUnload.Set = true;
			//	}
			//	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
			//	{
			//		smProductEvent->OutputTrayTableYAxisMotorMoveManualLoadUnloadDone.Set = false;
			//		smProductEvent->StartOutputTrayTableYAxisMotorMoveManualLoadUnload.Set = true;
			//	}
			//	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			//	nSequenceNoOutput = nCase2.IsMoveRejectTrayTableXYAxisToManualLoadUnloadPositionDone;
			//	break;
			//case nCase2.IsMoveRejectTrayTableXYAxisToManualLoadUnloadPositionDone:
			//	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			//	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//	if (true
			//		&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveManualLoadUnloadDone.Set == true))
			//		&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveManualLoadUnloadDone.Set == true))
			//		)
			//	{
			//		m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table XY axis move to manual load unload position to fill reject tray done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//		nSequenceNoOutput = nCase2.IsOperatorFillRejectTray;
			//	}
			//	else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			//	{
			//		m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table XY axis move to manual load unload position to fill reject tray timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//		if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveManualLoadUnloadDone.Set == false)
			//		{
			//			m_cProductShareVariables->SetAlarm(45002);
			//			m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table X axis move to manual load unload position to fill reject tray timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//		}
			//		if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveManualLoadUnloadDone.Set == false)
			//		{
			//			m_cProductShareVariables->SetAlarm(46002);
			//			m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table Y axis move to manual load unload position to fill reject tray timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//		}
			//		nSequenceNoOutput = nCase2.StopMoveRejectTrayTableXYAxisToManualLoadUnloadPosition;
			//		break;
			//	}
			//case nCase2.StopMoveRejectTrayTableXYAxisToManualLoadUnloadPosition:
			//	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
			//	{
			//		smProductEvent->OutputTrayTableXAxisMotorStopDone.Set = false;
			//		smProductEvent->StartOutputTrayTableXAxisMotorStop.Set = true;
			//	}
			//	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
			//	{
			//		smProductEvent->OutputTrayTableYAxisMotorStopDone.Set = false;
			//		smProductEvent->StartOutputTrayTableYAxisMotorStop.Set = true;
			//	}
			//	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			//	nSequenceNoOutput = nCase2.IsStopMoveRejectTrayTableXYAxisToManualLoadUnloadPositionDone;
			//	break;
			//case nCase2.IsStopMoveRejectTrayTableXYAxisToManualLoadUnloadPositionDone:
			//	if (true
			//		&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == true))
			//		&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == true))
			//		)
			//	{
			//		m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table XY axis motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//		nSequenceNoOutput = nCase2.StartMoveRejectTrayTableXYAxisToManualLoadUnloadPosition;
			//	}
			//	else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			//	{
			//		m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table XY axis motor stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//		if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == false)
			//		{
			//			m_cProductShareVariables->SetAlarm(45008);
			//			m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table X axis stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//		}
			//		if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == false)
			//		{
			//			m_cProductShareVariables->SetAlarm(46008);
			//			m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table Y axis stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//		}
			//		nSequenceNoOutput = nCase2.StopMoveRejectTrayTableXYAxisToManualLoadUnloadPosition;
			//		break;
			//	}
			//case nCase2.IsOperatorFillRejectTray:
			//	if (m_cProductIOControl->IsRejectTrayPresentSensor1On() == false && TemporaryDisable == false)
			//	{
			//		m_cProductShareVariables->SetAlarm(5512);
			//		m_cLogger->WriteLog("Tray not present on reject tray table 1.\n");
			//		break;
			//	}
			//	if (m_cProductIOControl->IsRejectTrayPresentSensor2On() == false && TemporaryDisable == false)
			//	{
			//		m_cProductShareVariables->SetAlarm(5513);
			//		m_cLogger->WriteLog("Tray not present on reject tray table 2.\n");
			//		break;
			//	}
			//	if (m_cProductIOControl->IsRejectTrayPresentSensor3On() == false && TemporaryDisable == false)
			//	{
			//		m_cProductShareVariables->SetAlarm(5514);
			//		m_cLogger->WriteLog("Tray not present on reject tray table 3.\n");
			//		break;
			//	}
			//	if (m_cProductIOControl->IsRejectTrayPresentSensor4On() == false && TemporaryDisable == false)
			//	{
			//		m_cProductShareVariables->SetAlarm(5515);
			//		m_cLogger->WriteLog("Tray not present on reject tray table 4.\n");
			//		break;
			//	}
			//	if (m_cProductIOControl->IsRejectTrayPresentSensor5On() == false && TemporaryDisable == false)
			//	{
			//		m_cProductShareVariables->SetAlarm(5516);
			//		m_cLogger->WriteLog("Tray not present on reject tray table 5.\n");
			//		break;
			//	}
			//	if (TemporaryDisable == true || (TemporaryDisable == false && m_cProductIOControl->IsRejectTrayPresentSensor1On() == true && m_cProductIOControl->IsRejectTrayPresentSensor2On() == true
			//		&& m_cProductIOControl->IsRejectTrayPresentSensor3On() == true && m_cProductIOControl->IsRejectTrayPresentSensor4On() == true
			//		&& m_cProductIOControl->IsRejectTrayPresentSensor5On() == true))
			//	{
			//		nSequenceNoOutput = nCase2.IsRejectTrayTableReady;
			//	}
			//	break;
			case nCase2.StartMoveOutputTrayTableXYAxisToFirstPosition:
				//Need to set move position
				smProductProduction->OutputTrayTableXAxisMovePosition = smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayTableCenterPosition - (signed long)(smProductSetting->DeviceXPitchOutput * ((double)(smProductSetting->NoOfDeviceInRowOutput - 1) / 2));
				smProductProduction->OutputTrayTableYAxisMovePosition = smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayTableCenterPosition - (signed long)(smProductSetting->DeviceYPitchOutput * ((double)(smProductSetting->NoOfDeviceInColOutput - 1) / 2));
				smProductProduction->OutputTableCheckSequence = 5;
				smProductProduction->OutputTableResult[0].CurrentOutputTableNo = 0;
				smProductProduction->OutputTableResult[0].OutputTrayNo = smProductProduction->nCurrentOutputTrayNo;
				smProductProduction->OutputTableResult[0].OutputColumn = smProductProduction->nOutputEdgeCoordinateY;
				smProductProduction->OutputTableResult[0].OutputRow = smProductProduction->nOutputEdgeCoordinateX;
				//if (smProductSetting->EnableVision == true && smProductSetting->EnableOutputVision == true && smProductCustomize->EnableOutputVisionModule == true)
				//{

				//	smProductEvent->GMAIN_RTHD_OUT_VISION_GET_RC_DONE.Set = false;
				//	smProductEvent->RTHD_GMAIN_SEND_OUT_VISION_RC_START.Set = true;

				//}
				if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
				{
					smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set = false;
					smProductEvent->StartOutputTrayTableXAxisMotorMove.Set = true;
				}
				if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
				{
					smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set = false;
					smProductEvent->StartOutputTrayTableYAxisMotorMove.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableXYAxisToFirstPositionDone;
				break;
			case nCase2.IsMoveOutputTrayTableXYAxisToFirstPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set == true))
					//&& ((smProductEvent->GMAIN_RTHD_OUT_VISION_GET_RC_DONE.Set == true && smProductSetting->EnableVision == true && smProductSetting->EnableOutputVision == true && smProductCustomize->EnableOutputVisionModule == true)
					//	|| (smProductSetting->EnableVision == false || smProductSetting->EnableOutputVision == false || smProductCustomize->EnableOutputVisionModule == false))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y move to first position done and send output vision row and column done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.EndOfSequence;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y move to first position and send output vision row and column Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					//if (smProductEvent->GMAIN_RTHD_OUT_VISION_GET_RC_DONE.Set == false && smProductSetting->EnableVision == true && smProductSetting->EnableOutputVision == true && smProductCustomize->EnableOutputVisionModule == true)
					//{
					//	m_cProductShareVariables->SetAlarm(6807);
					//	m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Vision receive column and row timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					//	nSequenceNoOutput = nCase2.StartSendOutputVisionOutputOrRejectRowAndColumn;
					//}
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(45002);
						m_cLogger->WriteLog("Output Tray Table X Axis Motor Move to first position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToFirstPosition;
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(46002);
						m_cLogger->WriteLog("Output Tray Table Y Axis Motor Move to first position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToFirstPosition;
					}
				}
				break;
			case nCase2.StopMoveOutputTrayTableXYAxisToFirstPosition:
				if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
				{
					smProductEvent->OutputTrayTableXAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableXAxisMotorStop.Set = true;
				}
				if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
				{
					smProductEvent->OutputTrayTableYAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableYAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableXYAxisToFirstPositionDone;
				break;
			case nCase2.IsStopMoveOutputTrayTableXYAxisToFirstPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToFirstPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(45008);
						m_cLogger->WriteLog("Output Tray Table X Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(46008);
						m_cLogger->WriteLog("Output Tray Table Y Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToFirstPosition;
				}
				break;
			default:
				return -1;
				break;
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Loading Unloading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			if (nSequenceNoOutput == nCase2.EndOfSequence)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Loading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		break;
#pragma endregion

#pragma region 5003 Output unloading sequence
	case 5003:
		if (smProductCustomize->EnableInputTrayTableXAxisMotor)
		{
			smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableXAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputTrayTableYAxisMotor)
		{
			smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableYAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputTrayTableZAxisMotor)
		{
			smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableZAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableXAxisMotor)
		{
			smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableXAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableYAxisMotor)
		{
			smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableYAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableZAxisMotor)
		{
			smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableZAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputVisionMotor)
		{
			smProductEvent->InputVisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartInputVisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS2VisionMotor)
		{
			smProductEvent->S2VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS2VisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS1VisionMotor)
		{
			smProductEvent->S1VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS1VisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS3VisionMotor)
		{
			smProductEvent->S3VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS3VisionModuleMotorSettingUp.Set = true;
		}

		if (smProductCustomize->EnablePickAndPlace1XAxisMotor == true)
		{
			smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1XAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace1YAxisMotor == true)
		{
			smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1YAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace1Module == true)
		{
			smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1ZAxisMotorSettingUp.Set = true;

			smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1ThetaAxisMotorSettingUp.Set = true;
		}

		if (smProductCustomize->EnablePickAndPlace2XAxisMotor == true)
		{
			smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2XAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace2YAxisMotor == true)
		{
			smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2YAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace2Module == true)
		{
			smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2ZAxisMotorSettingUp.Set = true;

			smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2ThetaAxisMotorSettingUp.Set = true;

		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

			if (true
				&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS2VisionMotor == false || (smProductCustomize->EnableS2VisionMotor == true && smProductEvent->S2VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS1VisionMotor == false || (smProductCustomize->EnableS1VisionMotor == true && smProductEvent->S1VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS3VisionMotor == false || (smProductCustomize->EnableS3VisionMotor == true && smProductEvent->S3VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1XAxisMotor == false || (smProductCustomize->EnablePickAndPlace1XAxisMotor == true && smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1YAxisMotor == false || (smProductCustomize->EnablePickAndPlace1YAxisMotor == true && smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2XAxisMotor == false || (smProductCustomize->EnablePickAndPlace2XAxisMotor == true && smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2YAxisMotor == false || (smProductCustomize->EnablePickAndPlace2YAxisMotor == true && smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set == true))
				)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("All Motor Setting up Done %ums\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}

		nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToUnloadingPosition;
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		while (smProductEvent->ExitRTX.Set == false)
		{
			switch (nSequenceNoOutput)
			{
#pragma region Unloading
			case nCase2.StartMoveOutputTrayTableXYAxisToUnloadingPosition:
				if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == false)
				{
					m_cProductShareVariables->SetAlarm(5511);
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Tray not present on output tray table during unloading.\n");
					nSequenceNoOutput = nCase2.EndOfSequence;
					break;

				}
				else
				{
					if (m_cProductIOControl->IsOutputUnloadingStackerFullSensorOn() == true)
					{
						m_cProductShareVariables->SetAlarm(5413);
						m_cLogger->WriteLog("ManualOutputUnloadingSeq: Tray full on output unloading stacker.\n");
						nSequenceNoOutput = nCase2.EndOfSequence;
						break;
					}
				}
				if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
				{
					smProductEvent->OutputTrayTableXAxisMotorMoveUnloadDone.Set = false;
					smProductEvent->StartOutputTrayTableXAxisMotorMoveUnload.Set = true;
				}
				if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
				{
					smProductEvent->OutputTrayTableYAxisMotorMoveUnloadDone.Set = false;
					smProductEvent->StartOutputTrayTableYAxisMotorMoveUnload.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableXYAxisToUnloadingPositionDone;
				break;
			case nCase2.IsMoveOutputTrayTableXYAxisToUnloadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveUnloadDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveUnloadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table X Y Axis Move to Unloading position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToSingulationPositionForUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table X Y Axis Move to Unloading position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);

					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveUnloadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(45002);
						m_cLogger->WriteLog("Output Tray Table X Axis Motor Move to Unloading position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveUnloadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(46002);
						m_cLogger->WriteLog("Output Tray Table Y Axis Motor Move to Unloading position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToUnloadingPosition;
				}
				break;
			case nCase2.StopMoveOutputTrayTableXYAxisToUnloadingPosition:
				if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
				{
					smProductEvent->OutputTrayTableXAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableXAxisMotorStop.Set = true;
				}
				if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
				{
					smProductEvent->OutputTrayTableYAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableYAxisMotorStop.Set = true;
				}

				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableXYAxisToUnloadingPositionDone;
				break;
			case nCase2.IsStopMoveOutputTrayTableXYAxisToUnloadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table X Y Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToUnloadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table X Y Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);

					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(45002);
						m_cLogger->WriteLog("Output Tray Table X Axis Motor stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(46002);
						m_cLogger->WriteLog("Output Tray Table Y Axis Motor stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToUnloadingPosition;
				}
				break;
			case nCase2.StartMoveOutputTrayTableZAxisToSingulationPositionForUnloading:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorMoveSingulation.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToSingulationPositionForUnloadingDone;
				break;
			case nCase2.IsMoveOutputTrayTableZAxisToSingulationPositionForUnloadingDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis Move to Singulation position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.OutputUnloadingStackerUnlockCylinderUnlockForUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47002);
						m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis Motor Move to Singulation position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToSingulationPositionForUnloading;
				}
				break;
			case nCase2.StopMoveOutputTrayTableZAxisToSingulationPositionForUnloading:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToSingulationPositionForUnloadingDone;
				break;
			case nCase2.IsStopMoveOutputTrayTableZAxisToSingulationPositionForUnloadingDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToSingulationPositionForUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47008);
						m_cLogger->WriteLog("Output Tray Table Z Axis Motor stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToSingulationPositionForUnloading;
				}
				break;
			case nCase2.OutputUnloadingStackerUnlockCylinderUnlockForUnloading:
				m_cProductIOControl->SetOutputUnloadingStackerUnlockCylinderOn(true);
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsOutputUnloadingStackerUnlockCylinderUnlockForUnloading;
				break;
			case nCase2.IsOutputUnloadingStackerUnlockCylinderUnlockForUnloading:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsOutputUnloadingStackerUnlockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Unloading Stacker unlock cylinder done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToUnloadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsOutputUnloadingStackerUnlockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5418);
						m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Unloading Stacker unlock cylinder Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.OutputUnloadingStackerUnlockCylinderUnlockForUnloading;
				}
				break;
			case nCase2.StartMoveOutputTrayTableZAxisToUnloadingPosition:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorMoveUnloadDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorMoveUnload.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToUnloadingPositionDone;
				break;
			case nCase2.IsMoveOutputTrayTableZAxisToUnloadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveUnloadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis Move to Unloading position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.OutputUnloadingStackerUnlockCylinderLockForUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveUnloadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47002);
						m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis Motor Move to unload position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToUnloadingPosition;
				}
				break;
			case nCase2.StopMoveOutputTrayTableZAxisToUnloadingPosition:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToUnloadingPositionDone;
				break;
			case nCase2.IsStopMoveOutputTrayTableZAxisToUnloadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToUnloadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47002);
						m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis Motor stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToUnloadingPosition;
				}
				break;
			case nCase2.OutputUnloadingStackerUnlockCylinderLockForUnloading:
				m_cProductIOControl->SetOutputUnloadingStackerUnlockCylinderOn(false);
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsOutputUnloadingStackerUnlockCylinderLockForUnloading;
				break;
			case nCase2.IsOutputUnloadingStackerUnlockCylinderLockForUnloading:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsOutputUnloadingStackerLockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Unloading Stacker lock cylinder done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToDownPositionAfterUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsOutputUnloadingStackerLockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5411);
						m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Unloading Stacker lock cylinder Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNoOutput = nCase2.OutputUnloadingStackerUnlockCylinderLockForUnloading;
				}
				break;
			case nCase2.StartMoveOutputTrayTableZAxisToDownPositionAfterUnloading:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorMoveDown.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToDownPositionDoneAfterUnloading;
			case nCase2.IsMoveOutputTrayTableZAxisToDownPositionDoneAfterUnloading:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis Move to down position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.EndOfSequence;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47002);
						m_cLogger->WriteLog("Output Tray Table Z Axis Motor Move to down position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToDownPositionAfterUnloading;
				}
				break;
			case nCase2.StopMoveOutputTrayTableZAxisToDownPositionAfterUnloading:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionDoneAfterUnloading;
				break;
			case nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionDoneAfterUnloading:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToDownPositionAfterUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47008);
						m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis Motor stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToDownPositionAfterUnloading;
				}
				break;
#pragma endregion
			default:
				return -1;
				break;
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Loading Unloading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			if (nSequenceNoOutput == nCase2.EndOfSequence)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Unloading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		break;
#pragma endregion

#pragma region 5004 Output Manual Load Unload sequence
	case 5004:
		if (smProductCustomize->EnableInputTrayTableXAxisMotor)
		{
			smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableXAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputTrayTableYAxisMotor)
		{
			smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableYAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputTrayTableZAxisMotor)
		{
			smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableZAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableXAxisMotor)
		{
			smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableXAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableYAxisMotor)
		{
			smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableYAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableZAxisMotor)
		{
			smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableZAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputVisionMotor)
		{
			smProductEvent->InputVisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartInputVisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS2VisionMotor)
		{
			smProductEvent->S2VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS2VisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS1VisionMotor)
		{
			smProductEvent->S1VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS1VisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS3VisionMotor)
		{
			smProductEvent->S3VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS3VisionModuleMotorSettingUp.Set = true;
		}

		if (smProductCustomize->EnablePickAndPlace1XAxisMotor == true)
		{
			smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1XAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace1YAxisMotor == true)
		{
			smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1YAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace1Module == true)
		{
			smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1ZAxisMotorSettingUp.Set = true;

			smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1ThetaAxisMotorSettingUp.Set = true;
		}

		if (smProductCustomize->EnablePickAndPlace2XAxisMotor == true)
		{
			smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2XAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace2YAxisMotor == true)
		{
			smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2YAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace2Module == true)
		{
			smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2ZAxisMotorSettingUp.Set = true;

			smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2ThetaAxisMotorSettingUp.Set = true;

		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

			if (true
				&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS2VisionMotor == false || (smProductCustomize->EnableS2VisionMotor == true && smProductEvent->S2VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS1VisionMotor == false || (smProductCustomize->EnableS1VisionMotor == true && smProductEvent->S1VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS3VisionMotor == false || (smProductCustomize->EnableS3VisionMotor == true && smProductEvent->S3VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1XAxisMotor == false || (smProductCustomize->EnablePickAndPlace1XAxisMotor == true && smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1YAxisMotor == false || (smProductCustomize->EnablePickAndPlace1YAxisMotor == true && smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2XAxisMotor == false || (smProductCustomize->EnablePickAndPlace2XAxisMotor == true && smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2YAxisMotor == false || (smProductCustomize->EnablePickAndPlace2YAxisMotor == true && smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set == true))
				)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("All Motor Setting up Done %ums\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}

		nSequenceNoOutput = nCase2.StartMoveRejectTrayTableXYAxisToManualLoadUnloadPosition;
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		while (smProductEvent->ExitRTX.Set == false)
		{
			switch (nSequenceNoOutput)
			{
			case nCase2.StartMoveRejectTrayTableXYAxisToManualLoadUnloadPosition:
				if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
				{
					smProductEvent->OutputTrayTableXAxisMotorMoveManualLoadUnloadDone.Set = false;
					smProductEvent->StartOutputTrayTableXAxisMotorMoveManualLoadUnload.Set = true;
				}
				if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
				{
					smProductEvent->OutputTrayTableYAxisMotorMoveManualLoadUnloadDone.Set = false;
					smProductEvent->StartOutputTrayTableYAxisMotorMoveManualLoadUnload.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveRejectTrayTableXYAxisToManualLoadUnloadPositionDone;
				break;
			case nCase2.IsMoveRejectTrayTableXYAxisToManualLoadUnloadPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveManualLoadUnloadDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveManualLoadUnloadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputManualLoadUnloadSeq: Output Tray Table XY axis move to manual load unload position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.EndOfSequence;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputManualLoadUnloadSeq: Output Tray Table XY axis move to manual load unload position timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveManualLoadUnloadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(45002);
						m_cLogger->WriteLog("ManualOutputManualLoadUnloadSeq: Output Tray Table X axis move to manual load unload position timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveManualLoadUnloadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(46002);
						m_cLogger->WriteLog("ManualOutputManualLoadUnloadSeq: Output Tray Table Y axis move to manual load unload position timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveRejectTrayTableXYAxisToManualLoadUnloadPosition;
					break;
				}
			case nCase2.StopMoveRejectTrayTableXYAxisToManualLoadUnloadPosition:
				if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
				{
					smProductEvent->OutputTrayTableXAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableXAxisMotorStop.Set = true;
				}
				if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
				{
					smProductEvent->OutputTrayTableYAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableYAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveRejectTrayTableXYAxisToManualLoadUnloadPositionDone;
				break;
			case nCase2.IsStopMoveRejectTrayTableXYAxisToManualLoadUnloadPositionDone:
				if (true
					&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputManualLoadUnloadSeq: Output Tray Table XY axis motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase2.StartMoveRejectTrayTableXYAxisToManualLoadUnloadPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputManualLoadUnloadSeq: Output Tray Table XY axis motor stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(45008);
						m_cLogger->WriteLog("ManualOutputManualLoadUnloadSeq: Output Tray Table X axis stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(46008);
						m_cLogger->WriteLog("ManualOutputManualLoadUnloadSeq: Output Tray Table Y axis stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveRejectTrayTableXYAxisToManualLoadUnloadPosition;
					break;
				}
			default:
				return -1;
				break;
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Loading Unloading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			if (nSequenceNoOutput == nCase2.EndOfSequence)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Manual Load Unload Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		break;
#pragma endregion

#pragma region 5005 input loading unloading sequence continuously
	case 5005:
		if (smProductCustomize->EnableInputTrayTableXAxisMotor)
		{
			smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableXAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputTrayTableYAxisMotor)
		{
			smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableYAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputTrayTableZAxisMotor)
		{
			smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableZAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableXAxisMotor)
		{
			smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableXAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableYAxisMotor)
		{
			smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableYAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableZAxisMotor)
		{
			smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableZAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputVisionMotor)
		{
			smProductEvent->InputVisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartInputVisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS2VisionMotor)
		{
			smProductEvent->S2VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS2VisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS1VisionMotor)
		{
			smProductEvent->S1VisionModuleMotorHomeDone.Set = false;
			smProductEvent->StartS1VisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS3VisionMotor)
		{
			smProductEvent->S3VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS3VisionModuleMotorSettingUp.Set = true;
		}

		if (smProductCustomize->EnablePickAndPlace1XAxisMotor == true)
		{
			smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1XAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace1YAxisMotor == true)
		{
			smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1YAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace1Module == true)
		{
			smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1ZAxisMotorSettingUp.Set = true;

			smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1ThetaAxisMotorSettingUp.Set = true;
		}

		if (smProductCustomize->EnablePickAndPlace2XAxisMotor == true)
		{
			smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2XAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace2YAxisMotor == true)
		{
			smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2YAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace2Module == true)
		{
			smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2ZAxisMotorSettingUp.Set = true;

			smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2ThetaAxisMotorSettingUp.Set = true;

		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

			if (true
				&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS2VisionMotor == false || (smProductCustomize->EnableS2VisionMotor == true && smProductEvent->S2VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS1VisionMotor == false || (smProductCustomize->EnableS1VisionMotor == true && smProductEvent->S1VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS3VisionMotor == false || (smProductCustomize->EnableS3VisionMotor == true && smProductEvent->S3VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1XAxisMotor == false || (smProductCustomize->EnablePickAndPlace1XAxisMotor == true && smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1YAxisMotor == false || (smProductCustomize->EnablePickAndPlace1YAxisMotor == true && smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2XAxisMotor == false || (smProductCustomize->EnablePickAndPlace2XAxisMotor == true && smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2YAxisMotor == false || (smProductCustomize->EnablePickAndPlace2YAxisMotor == true && smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set == true))
				)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("All Motor Setting up Done %ums\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		smProductEvent->RSEQ_RINT_SEQUENCE_START.Set = true;
		nSequenceNo = nCase.WaitingToReceiveEventStartInputTrayTableSequence;
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		while (smProductEvent->ExitRTX.Set == false)
		{
			switch (nSequenceNo)
			{
			case nCase.WaitingToReceiveEventStartInputTrayTableSequence:
				if (smProductEvent->RSEQ_RINT_SEQUENCE_START.Set == true)
				{
					smProductEvent->RSEQ_RINT_SEQUENCE_START.Set = false;
					m_cLogger->WriteLog("ManualInputLoadingSeq: Come in.\n");
					nSequenceNo = nCase.IsInputTrayTableZAxisAtDownPosition;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				}
				break;

			case nCase.IsInputTrayTableZAxisAtDownPosition:
				//if (smProductEvent->JobStop.Set == true)
				//{
				//	m_cLogger->WriteLog("ManualInputLoadingSeq: User stop sequence.\n");
				//	nSequenceNo = nCase.EndOfSequence;
				//	break;
				//}
				if (m_cProductMotorControl->IsInputTrayTableXAxisMotorSafeToMove() == false || m_cProductMotorControl->IsInputTrayTableYAxisMotorSafeToMove() == false)
				{
					m_cProductShareVariables->SetAlarm(43010);
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Not At Down Position");
					nSequenceNo = nCase.EndOfSequence;
					break;
				}
				else
				{
					nSequenceNo = nCase.IsInputTrayTableReady;
				}
				break;

			case nCase.IsInputTrayTableReady:
				//if (smProductEvent->JobStop.Set == true)
				//{
				//	m_cLogger->WriteLog("ManualInputLoadingSeq: User stop sequence.\n");
				//	nSequenceNo = nCase.EndOfSequence;
				//	break;
				//}
				if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == false)
				{
					if (m_cProductIOControl->IsInputLoadingStackerPresentSensorOn() == true)
					{
						nSequenceNo = nCase.StartMoveInputTrayTableXYAxisToLoadingPosition;
					}
					else
					{
						m_cProductShareVariables->SetAlarm(5402);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Tray not present on input loading stacker.\n");
						nSequenceNo = nCase.EndOfSequence;
						break;
					}
				}
				else if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == true)
				{
					nSequenceNo = nCase.StartMoveInputTrayTableXYAxisToUnloadingPosition;
				}
				break;

			case nCase.StartMoveInputTrayTableXYAxisToLoadingPosition:
				//if (smProductEvent->JobStop.Set == true)
				//{
				//	m_cLogger->WriteLog("ManualInputLoadingSeq: User stop sequence.\n");
				//	nSequenceNo = nCase.EndOfSequence;
				//	break;
				//}
				if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
				{
					smProductEvent->InputTrayTableXAxisMotorMoveLoadDone.Set = false;
					smProductEvent->StartInputTrayTableXAxisMotorMoveLoad.Set = true;
				}
				if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
				{
					smProductEvent->InputTrayTableYAxisMotorMoveLoadDone.Set = false;
					smProductEvent->StartInputTrayTableYAxisMotorMoveLoad.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableXYAxisToLoadingPositionDone;
				break;
			case nCase.IsMoveInputTrayTableXYAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveLoadDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveLoadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis Motor move load position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToLoadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis move load position Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);

					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveLoadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(41002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Axis Motor Move Loading position timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveLoadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(42002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Y Axis Motor Move Loading position timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNo = nCase.StopMoveInputTrayTableXYAxisToLoadingPosition;
				}
				break;
			case nCase.StopMoveInputTrayTableXYAxisToLoadingPosition:

				if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
				{
					smProductEvent->InputTrayTableXAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableXAxisMotorStop.Set = true;
				}
				if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
				{
					smProductEvent->InputTrayTableYAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableYAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableXYAxisToLoadingPositionDone;
				break;
			case nCase.IsStopMoveInputTrayTableXYAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableXYAxisToLoadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(41008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(42008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Y Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableXYAxisToLoadingPosition;
				}
				break;
			case nCase.StartMoveInputTrayTableZAxisToLoadingPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorMoveLoadDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorMoveLoad.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableZAxisToLoadingPositionDone;
				break;
			case nCase.IsMoveInputTrayTableZAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveLoadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor move loading position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.InputLoadingStackerUnlockCylinderUnlock;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveLoadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Move Loading timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToLoadingPosition;
				}
				break;
			case nCase.StopMoveInputTrayTableZAxisToLoadingPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToLoadingPositionDone;
				break;
			case nCase.IsStopMoveInputTrayTableZAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToLoadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToLoadingPosition;
				}
				break;
			case nCase.InputLoadingStackerUnlockCylinderUnlock:
				m_cProductIOControl->SetInputLoadingStackerUnlockCylinderOn(true);
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsInputLoadingStackerUnlockCylinderUnlock;
				break;

			case nCase.IsInputLoadingStackerUnlockCylinderUnlock:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsInputLoadingStackerUnlockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Loading Stacker Cylinder Unlock done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToSingulationPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsInputLoadingStackerUnlockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5404);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Loading Stacker Cylinder Unlock Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.InputLoadingStackerUnlockCylinderUnlock;
				}
				break;
			case nCase.StartMoveInputTrayTableZAxisToSingulationPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorMoveSingulation.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableZAxisToSingulationPositionDone;
				break;
			case nCase.IsMoveInputTrayTableZAxisToSingulationPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor move singulation position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.InputLoadingStackerUnlockCylinderLock;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Move Singulation timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToSingulationPosition;
				}
				break;
			case nCase.StopMoveInputTrayTableZAxisToSingulationPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToSingulationPositionDone;
				break;
			case nCase.IsStopMoveInputTrayTableZAxisToSingulationPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToSingulationPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToSingulationPosition;
				}
				break;
			case nCase.InputLoadingStackerUnlockCylinderLock:
				m_cProductIOControl->SetInputLoadingStackerUnlockCylinderOn(false);
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsInputLoadingStackerUnlockCylinderLock;
				break;

			case nCase.IsInputLoadingStackerUnlockCylinderLock:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsInputLoadingStackerLockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Loading Stacker Cylinder lock done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToDownPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsInputLoadingStackerLockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5403);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Loading Stacker Cylinder lock Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.InputLoadingStackerUnlockCylinderLock;
				}
				break;
			case nCase.StartMoveInputTrayTableZAxisToDownPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorMoveDown.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableZAxisToDownPositionDone;
				break;
			case nCase.IsMoveInputTrayTableZAxisToDownPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == false)
				{

					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
					{
						smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToDownPositionAfterTrayNotPresent;
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Tray Not Present %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor move down position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.IsInputTrayTableReady;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Move down timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToDownPosition;
				}
				break;
			case nCase.IsStopMoveInputTrayTableZAxisToDownPositionAfterTrayNotPresent:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1s);
					nSequenceNo = nCase.CheckIsTrayPresentOnInputTrayTableDuringDown;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
					{
						smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
					}
					nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToDownPositionAfterTrayNotPresent;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				}
				break;
			case nCase.CheckIsTrayPresentOnInputTrayTableDuringDown:
				if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == false)
				{
					//if()if time >preset,then
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 5000)//(LONGLONG)smProductProduction->InputTrayPresentSensorOffTimeBeforeAlarm_ms)
					{
						m_cProductShareVariables->SetAlarm(5510);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Tray Not Present %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//nSequenceNo = nCase.StopMoveInputTrayTableZAxisDownAtLoading;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						break;
					}
				}
				else if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == true)

				{
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToDownPosition;
				}
				break;
			case nCase.StopMoveInputTrayTableZAxisToDownPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToDownPositionDone;
				break;

			case nCase.IsStopMoveInputTrayTableZAxisToDownPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToDownPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToDownPosition;
				}
				break;
			
#pragma region Unloading
			case nCase.StartMoveInputTrayTableXYAxisToUnloadingPosition:
				if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == false)
				{
					m_cProductShareVariables->SetAlarm(5510);
					m_cLogger->WriteLog("ManualInputLoadingSeq: Tray not present on input tray table.\n");
					nSequenceNo = nCase.EndOfSequence;
					break;

				}
				else
				{
					if (m_cProductIOControl->IsInputUnloadingStackerFullSensorOn() == true)
					{
						m_cProductShareVariables->SetAlarm(5405);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Tray full on input unloading stacker.\n");
						break;
					}
				}
				if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
				{
					smProductEvent->InputTrayTableXAxisMotorMoveUnloadDone.Set = false;
					smProductEvent->StartInputTrayTableXAxisMotorMoveUnload.Set = true;
				}
				if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
				{
					smProductEvent->InputTrayTableYAxisMotorMoveUnloadDone.Set = false;
					smProductEvent->StartInputTrayTableYAxisMotorMoveUnload.Set = true;
				}

				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableXYAxisToUnloadingPositionDone;
				break;
			case nCase.IsMoveInputTrayTableXYAxisToUnloadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveUnloadDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveUnloadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table X Y Axis Move to Unloading position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToSingulationPositionForUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table X Y Axis Move to Unloading position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveUnloadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(41002);
						m_cLogger->WriteLog("Input Tray Table X Axis Motor Move to Unloading position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveUnloadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(42002);
						m_cLogger->WriteLog("Input Tray Table Y Axis Motor Move to Unloading position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableXYAxisToUnloadingPosition;
				}
				break;
			case nCase.StopMoveInputTrayTableXYAxisToUnloadingPosition:
				if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
				{
					smProductEvent->InputTrayTableXAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableXAxisMotorStop.Set = true;
				}
				if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
				{
					smProductEvent->InputTrayTableYAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableYAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableXYAxisToUnloadingPositionDone;
				break;
			case nCase.IsStopMoveInputTrayTableXYAxisToUnloadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table X Y Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableXYAxisToUnloadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table X Y Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(41008);
						m_cLogger->WriteLog("Input Tray Table X Axis Motor Move stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(42008);
						m_cLogger->WriteLog("Input Tray Table Y Axis Motor Move stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableXYAxisToUnloadingPosition;
				}
				break;
			case nCase.StartMoveInputTrayTableZAxisToSingulationPositionForUnloading:

				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorMoveSingulation.Set = true;
				}

				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableZAxisToSingulationPositionForUnloadingDone;
				break;
			case nCase.IsMoveInputTrayTableZAxisToSingulationPositionForUnloadingDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis Move to Singulation position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.InputUnloadingStackerUnlockCylinderUnlockForUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis Move to Singulation position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43002);
						m_cLogger->WriteLog("Input Tray Table Z Axis Motor Move to Singulation position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToSingulationPositionForUnloading;
				}
				break;
			case nCase.StopMoveInputTrayTableZAxisToSingulationPositionForUnloading:

				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToSingulationPositionForUnloadingDone;
				break;
			case nCase.IsStopMoveInputTrayTableZAxisToSingulationPositionForUnloadingDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToSingulationPositionForUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("Input Tray Table Z Axis Motor stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToSingulationPositionForUnloading;
				}
				break;
			case nCase.InputUnloadingStackerUnlockCylinderUnlockForUnloading:
				m_cProductIOControl->SetInputUnloadingStackerUnlockCylinderOn(true);
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsInputUnloadingStackerUnlockCylinderUnlockForUnloading;
				break;
			case nCase.IsInputUnloadingStackerUnlockCylinderUnlockForUnloading:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsInputUnloadingStackerUnlockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("InputTrayTableSeq: Input Unloading Stacker unlock cylinder done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToUnloadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsInputUnloadingStackerUnlockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5417);
						m_cLogger->WriteLog("Input Unloading Stacker unlock cylinder Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNo = nCase.InputUnloadingStackerUnlockCylinderUnlockForUnloading;
				}
				break;
			case nCase.StartMoveInputTrayTableZAxisToUnloadingPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorMoveUnloadDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorMoveUnload.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableZAxisToUnloadingPositionDone;
				break;
			case nCase.IsMoveInputTrayTableZAxisToUnloadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveUnloadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis Move to Unloading position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.InputUnloadingStackerUnlockCylinderLockForUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveUnloadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43002);
						m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis Motor Move to unload position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToUnloadingPosition;
				}
				break;
			case nCase.StopMoveInputTrayTableZAxisToUnloadingPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
				}

				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToUnloadingPositionDone;
				break;
			case nCase.IsStopMoveInputTrayTableZAxisToUnloadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToUnloadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis Motor stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToUnloadingPosition;
				}
				break;
			case nCase.InputUnloadingStackerUnlockCylinderLockForUnloading:
				m_cProductIOControl->SetInputUnloadingStackerUnlockCylinderOn(false);
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsInputUnloadingStackerUnlockCylinderLockForUnloading;
				break;
			case nCase.IsInputUnloadingStackerUnlockCylinderLockForUnloading:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsInputUnloadingStackerLockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Unloading Stacker lock cylinder done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToDownPositionAfterUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsInputUnloadingStackerLockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5407);
						m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Unloading Stacker lock cylinder Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.InputUnloadingStackerUnlockCylinderLockForUnloading;
				}
				break;
			case nCase.StartMoveInputTrayTableZAxisToDownPositionAfterUnloading:

				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorMoveDown.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableZAxisToDownPositionDoneAfterUnloading;
				break;
			case nCase.IsMoveInputTrayTableZAxisToDownPositionDoneAfterUnloading:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis Move to down position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);

					nSequenceNo = nCase.IsInputTrayTableZAxisAtDownPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveUnloadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43002);
						m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis Motor Move to unload position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToDownPositionAfterUnloading;
				}
				break;
			case nCase.StopMoveInputTrayTableZAxisToDownPositionAfterUnloading:

				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToDownPositionDoneAfterUnloading;
				break;
			case nCase.IsStopMoveInputTrayTableZAxisToDownPositionDoneAfterUnloading:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToDownPositionAfterUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("ManualInputUnloadingSeq: Input Tray Table Z Axis Motor stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToDownPositionAfterUnloading;
				}
				break;
#pragma endregion
			default:
				return -1;
				break;
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Loading Unloading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			if (nSequenceNo == nCase.EndOfSequence)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Loading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		break;
#pragma endregion

#pragma region 5006 Output loading unloading sequence continuously
	case 5006:
		if (smProductCustomize->EnableInputTrayTableXAxisMotor)
		{
			smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableXAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputTrayTableYAxisMotor)
		{
			smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableYAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputTrayTableZAxisMotor)
		{
			smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableZAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableXAxisMotor)
		{
			smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableXAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableYAxisMotor)
		{
			smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableYAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableZAxisMotor)
		{
			smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableZAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputVisionMotor)
		{
			smProductEvent->InputVisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartInputVisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS2VisionMotor)
		{
			smProductEvent->S2VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS2VisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS1VisionMotor)
		{
			smProductEvent->S1VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS1VisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS3VisionMotor)
		{
			smProductEvent->S3VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS3VisionModuleMotorSettingUp.Set = true;
		}

		if (smProductCustomize->EnablePickAndPlace1XAxisMotor == true)
		{
			smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1XAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace1YAxisMotor == true)
		{
			smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1YAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace1Module == true)
		{
			smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1ZAxisMotorSettingUp.Set = true;

			smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1ThetaAxisMotorSettingUp.Set = true;
		}

		if (smProductCustomize->EnablePickAndPlace2XAxisMotor == true)
		{
			smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2XAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace2YAxisMotor == true)
		{
			smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2YAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace2Module == true)
		{
			smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2ZAxisMotorSettingUp.Set = true;

			smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2ThetaAxisMotorSettingUp.Set = true;

		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

			if (true
				&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS2VisionMotor == false || (smProductCustomize->EnableS2VisionMotor == true && smProductEvent->S2VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS1VisionMotor == false || (smProductCustomize->EnableS1VisionMotor == true && smProductEvent->S1VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS3VisionMotor == false || (smProductCustomize->EnableS3VisionMotor == true && smProductEvent->S3VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1XAxisMotor == false || (smProductCustomize->EnablePickAndPlace1XAxisMotor == true && smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1YAxisMotor == false || (smProductCustomize->EnablePickAndPlace1YAxisMotor == true && smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2XAxisMotor == false || (smProductCustomize->EnablePickAndPlace2XAxisMotor == true && smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2YAxisMotor == false || (smProductCustomize->EnablePickAndPlace2YAxisMotor == true && smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set == true))
				)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("All Motor Setting up Done %ums\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		smProductEvent->RSEQ_ROUT_SEQUENCE_START.Set = true;
		nSequenceNoOutput = nCase2.WaitingToReceiveEventStartOutputAndRejectTrayTableSequence;
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		while (smProductEvent->ExitRTX.Set == false)
		{
			switch (nSequenceNoOutput)
			{
			case nCase2.WaitingToReceiveEventStartOutputAndRejectTrayTableSequence:
				if (smProductEvent->RSEQ_ROUT_SEQUENCE_START.Set == true)
				{
					smProductEvent->RSEQ_ROUT_SEQUENCE_START.Set = false;
					smProductEvent->ROUT_RINT_OUTPUT_PRE_PRODUCTION_DONE.Set = false;
					smProductProduction->OutputTableCheckSequence = 5;
					smProductProduction->nRejectEdgeCoordinateX = 1;
					smProductProduction->nRejectEdgeCoordinateY = 1;
					smProductProduction->nOutputEdgeCoordinateX = 1;
					smProductProduction->nOutputEdgeCoordinateY = 1;
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Come in.\n");
					nSequenceNoOutput = nCase2.IsOutputTrayTableZAxisAtDownPosition;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				}
				break;
			case nCase2.IsOutputTrayTableZAxisAtDownPosition:
				//if (smProductEvent->JobStop.Set == true)
				//{
				//	m_cLogger->WriteLog("ManualOutputLoadingSeq: User stop sequence.\n");
				//	nSequenceNoOutput = nCase2.EndOfSequence;
				//	break;
				//}
				if (m_cProductMotorControl->IsOutputTrayTableXAxisMotorSafeToMove() == false || m_cProductMotorControl->IsOutputTrayTableYAxisMotorSafeToMove() == false)
				{
					m_cProductShareVariables->SetAlarm(47010);
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Not At Down Position");
					nSequenceNoOutput = nCase2.EndOfSequence;
					break;
				}
				else
				{
					nSequenceNoOutput = nCase2.IsOutputTrayTableReady;
				}
				break;

			case nCase2.IsOutputTrayTableReady:
				//if (smProductEvent->JobStop.Set == true)
				//{
				//	m_cLogger->WriteLog("ManualOutputLoadingSeq: User stop sequence.\n");
				//	nSequenceNoOutput = nCase2.EndOfSequence;
				//	break;
				//}
				if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == false)
				{
					if (m_cProductIOControl->IsOutputLoadingStackerPresentSensorOn() == true)
					{
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToLoadingPosition;
					}
					else
					{
						m_cProductShareVariables->SetAlarm(5410);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Tray not present on output loading stacker.\n");
						nSequenceNoOutput = nCase2.EndOfSequence;
						break;
					}
				}
				else if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == true)
				{
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToFirstPosition;
				}
				break;
			case nCase2.StartMoveOutputTrayTableXYAxisToLoadingPosition:
				//if (smProductEvent->JobStop.Set == true)
				//{
				//	m_cLogger->WriteLog("ManualOutputLoadingSeq: User stop sequence.\n");
				//	nSequenceNoOutput = nCase2.EndOfSequence;
				//	break;
				//}
				if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
				{
					smProductEvent->OutputTrayTableXAxisMotorMoveLoadDone.Set = false;
					smProductEvent->StartOutputTrayTableXAxisMotorMoveLoad.Set = true;
				}
				if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
				{
					smProductEvent->OutputTrayTableYAxisMotorMoveLoadDone.Set = false;
					smProductEvent->StartOutputTrayTableYAxisMotorMoveLoad.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableXYAxisToLoadingPositionDone;
				break;
			case nCase2.IsMoveOutputTrayTableXYAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveLoadDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveLoadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis Motor move load position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToLoadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis move load position Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveLoadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(45002);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Axis Motor Move Load timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveLoadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(46002);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Y Axis Motor Move Load timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToLoadingPosition;
				}
				break;
			case nCase2.StopMoveOutputTrayTableXYAxisToLoadingPosition:
				if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
				{
					smProductEvent->OutputTrayTableXAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableXAxisMotorStop.Set = true;
				}
				if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
				{
					smProductEvent->OutputTrayTableYAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableYAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableXYAxisToLoadingPositionDone;
				break;
			case nCase2.IsStopMoveOutputTrayTableXYAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToLoadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(45008);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(46008);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Y Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToLoadingPosition;
				}
				break;
			case nCase2.StartMoveOutputTrayTableZAxisToLoadingPosition:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorMoveLoadDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorMoveLoad.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToLoadingPositionDone;
				break;
			case nCase2.IsMoveOutputTrayTableZAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveLoadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor move loading position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.OutputLoadingStackerUnlockCylinderUnlock;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveLoadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47002);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Move Loading timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToLoadingPosition;
				}
				break;
			case nCase2.StopMoveOutputTrayTableZAxisToLoadingPosition:

				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
				}

				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToLoadingPositionDone;
				break;
			case nCase2.IsStopMoveOutputTrayTableZAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToLoadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{

					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47008);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToLoadingPosition;
				}
				break;
			case nCase2.OutputLoadingStackerUnlockCylinderUnlock:
				m_cProductIOControl->SetOutputLoadingStackerUnlockCylinderOn(true);

				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsOutputLoadingStackerUnlockCylinderUnlock;
				break;

			case nCase2.IsOutputLoadingStackerUnlockCylinderUnlock:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsOutputLoadingStackerUnlockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Loading Stacker Cylinder Unlock done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToSingulationPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsOutputLoadingStackerUnlockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5412);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Loading Stacker Cylinder Unlock Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNoOutput = nCase2.OutputLoadingStackerUnlockCylinderUnlock;
				}
				break;
			case nCase2.StartMoveOutputTrayTableZAxisToSingulationPosition:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorMoveSingulation.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToSingulationPositionDone;
				break;
			case nCase2.IsMoveOutputTrayTableZAxisToSingulationPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor move singulation position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.OutputLoadingStackerUnlockCylinderLock;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47002);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Move Singulation timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToSingulationPosition;
				}
				break;
			case nCase2.StopMoveOutputTrayTableZAxisToSingulationPosition:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToSingulationPositionDone;
				break;
			case nCase2.IsStopMoveOutputTrayTableZAxisToSingulationPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToSingulationPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47008);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToSingulationPosition;
				}
				break;
			case nCase2.OutputLoadingStackerUnlockCylinderLock:

				m_cProductIOControl->SetOutputLoadingStackerUnlockCylinderOn(false);

				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsOutputLoadingStackerUnlockCylinderLock;
				break;

			case nCase2.IsOutputLoadingStackerUnlockCylinderLock:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsOutputLoadingStackerLockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Loading Stacker Cylinder lock done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToDownPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsOutputLoadingStackerLockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5411);
						m_cLogger->WriteLog("ManualOutputLoadingSeq:  Output Loading Stacker Cylinder lock Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.OutputLoadingStackerUnlockCylinderLock;
				}
				break;
			case nCase2.StartMoveOutputTrayTableZAxisToDownPosition:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorMoveDown.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToDownPositionDone;
				break;

			case nCase2.IsMoveOutputTrayTableZAxisToDownPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == false)
				{

					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
					{
						smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionAfterTrayNotPresent;
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Tray Not Present %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor move down position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.IsOutputTrayTableReady;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47002);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Move down timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToDownPosition;
				}
				break;
			case nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionAfterTrayNotPresent:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.CheckIsTrayPresentOnOutputTrayTableDuringDown;
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1s);
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47008);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
					{
						smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
					}
					nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionAfterTrayNotPresent;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				}
				break;
			case nCase2.CheckIsTrayPresentOnOutputTrayTableDuringDown:
				if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == false)
				{
					//if()if time >preset,then
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > (LONGLONG)smProductProduction->TrayPresentSensorOffTimeBeforeAlarm_ms)
					{
						m_cProductShareVariables->SetAlarm(5511);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Tray Not Present %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//nSequenceNo = nCase.StopMoveInputTrayTableZAxisDownAtLoading;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						break;
					}
				}
				else if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == true)

				{
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToDownPosition;
				}
				break;
			case nCase2.StopMoveOutputTrayTableZAxisToDownPosition:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
				}

				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionDone;
				break;
			case nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToDownPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47008);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToDownPosition;
				}
				break;
			//case nCase2.IsRejectTrayTableReady:
			//	//if (smProductEvent->JobStop.Set == true)
			//	//{
			//	//	m_cLogger->WriteLog("ManualOutputLoadingSeq: User stop sequence.\n");
			//	//	nSequenceNoOutput = nCase2.EndOfSequence;
			//	//	break;
			//	//}
			//	if (TemporaryDisable = false && (m_cProductIOControl->IsRejectTrayPresentSensor1On() == false || m_cProductIOControl->IsRejectTrayPresentSensor2On() == false
			//		|| m_cProductIOControl->IsRejectTrayPresentSensor3On() == false || m_cProductIOControl->IsRejectTrayPresentSensor4On() == false
			//		|| m_cProductIOControl->IsRejectTrayPresentSensor5On() == false))
			//	{
			//		nSequenceNoOutput = nCase2.StartMoveRejectTrayTableXYAxisToManualLoadUnloadPosition;
			//	}
			//	else
			//	{
			//		nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToFirstPosition;
			//	}
			//	break;
			//case nCase2.StartMoveRejectTrayTableXYAxisToManualLoadUnloadPosition:
			//	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
			//	{
			//		smProductEvent->OutputTrayTableXAxisMotorMoveManualLoadUnloadDone.Set = false;
			//		smProductEvent->StartOutputTrayTableXAxisMotorMoveManualLoadUnload.Set = true;
			//	}
			//	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
			//	{
			//		smProductEvent->OutputTrayTableYAxisMotorMoveManualLoadUnloadDone.Set = false;
			//		smProductEvent->StartOutputTrayTableYAxisMotorMoveManualLoadUnload.Set = true;
			//	}
			//	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			//	nSequenceNoOutput = nCase2.IsMoveRejectTrayTableXYAxisToManualLoadUnloadPositionDone;
			//	break;
			//case nCase2.IsMoveRejectTrayTableXYAxisToManualLoadUnloadPositionDone:
			//	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			//	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//	if (true
			//		&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveManualLoadUnloadDone.Set == true))
			//		&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveManualLoadUnloadDone.Set == true))
			//		)
			//	{
			//		m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table XY axis move to manual load unload position to fill reject tray done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//		nSequenceNoOutput = nCase2.IsOperatorFillRejectTray;
			//	}
			//	else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			//	{
			//		m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table XY axis move to manual load unload position to fill reject tray timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//		if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveManualLoadUnloadDone.Set == false)
			//		{
			//			m_cProductShareVariables->SetAlarm(45002);
			//			m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table X axis move to manual load unload position to fill reject tray timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//		}
			//		if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveManualLoadUnloadDone.Set == false)
			//		{
			//			m_cProductShareVariables->SetAlarm(46002);
			//			m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table Y axis move to manual load unload position to fill reject tray timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//		}
			//		nSequenceNoOutput = nCase2.StopMoveRejectTrayTableXYAxisToManualLoadUnloadPosition;
			//		break;
			//	}
			//case nCase2.StopMoveRejectTrayTableXYAxisToManualLoadUnloadPosition:
			//	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
			//	{
			//		smProductEvent->OutputTrayTableXAxisMotorStopDone.Set = false;
			//		smProductEvent->StartOutputTrayTableXAxisMotorStop.Set = true;
			//	}
			//	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
			//	{
			//		smProductEvent->OutputTrayTableYAxisMotorStopDone.Set = false;
			//		smProductEvent->StartOutputTrayTableYAxisMotorStop.Set = true;
			//	}
			//	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
			//	nSequenceNoOutput = nCase2.IsStopMoveRejectTrayTableXYAxisToManualLoadUnloadPositionDone;
			//	break;
			//case nCase2.IsStopMoveRejectTrayTableXYAxisToManualLoadUnloadPositionDone:
			//	if (true
			//		&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == true))
			//		&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == true))
			//		)
			//	{
			//		m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table XY axis motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//		nSequenceNoOutput = nCase2.StartMoveRejectTrayTableXYAxisToManualLoadUnloadPosition;
			//	}
			//	else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			//	{
			//		m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table XY axis motor stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//		if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == false)
			//		{
			//			m_cProductShareVariables->SetAlarm(45008);
			//			m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table X axis stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//		}
			//		if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == false)
			//		{
			//			m_cProductShareVariables->SetAlarm(46008);
			//			m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table Y axis stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//		}
			//		nSequenceNoOutput = nCase2.StopMoveRejectTrayTableXYAxisToManualLoadUnloadPosition;
			//		break;
			//	}
			//case nCase2.IsOperatorFillRejectTray:
			//	if (m_cProductIOControl->IsRejectTrayPresentSensor1On() == false && TemporaryDisable == false)
			//	{
			//		m_cProductShareVariables->SetAlarm(5512);
			//		m_cLogger->WriteLog("Tray not present on reject tray table 1.\n");
			//		break;
			//	}
			//	if (m_cProductIOControl->IsRejectTrayPresentSensor2On() == false && TemporaryDisable == false)
			//	{
			//		m_cProductShareVariables->SetAlarm(5513);
			//		m_cLogger->WriteLog("Tray not present on reject tray table 2.\n");
			//		break;
			//	}
			//	if (m_cProductIOControl->IsRejectTrayPresentSensor3On() == false && TemporaryDisable == false)
			//	{
			//		m_cProductShareVariables->SetAlarm(5514);
			//		m_cLogger->WriteLog("Tray not present on reject tray table 3.\n");
			//		break;
			//	}
			//	if (m_cProductIOControl->IsRejectTrayPresentSensor4On() == false && TemporaryDisable == false)
			//	{
			//		m_cProductShareVariables->SetAlarm(5515);
			//		m_cLogger->WriteLog("Tray not present on reject tray table 4.\n");
			//		break;
			//	}
			//	if (m_cProductIOControl->IsRejectTrayPresentSensor5On() == false && TemporaryDisable == false)
			//	{
			//		m_cProductShareVariables->SetAlarm(5516);
			//		m_cLogger->WriteLog("Tray not present on reject tray table 5.\n");
			//		break;
			//	}
			//	if (TemporaryDisable == true || (TemporaryDisable == false && m_cProductIOControl->IsRejectTrayPresentSensor1On() == true && m_cProductIOControl->IsRejectTrayPresentSensor2On() == true
			//		&& m_cProductIOControl->IsRejectTrayPresentSensor3On() == true && m_cProductIOControl->IsRejectTrayPresentSensor4On() == true
			//		&& m_cProductIOControl->IsRejectTrayPresentSensor5On() == true))
			//	{
			//		nSequenceNoOutput = nCase2.IsRejectTrayTableReady;
			//	}
			//	break;
			case nCase2.StartMoveOutputTrayTableXYAxisToFirstPosition:
				//Need to set move position
				smProductProduction->OutputTrayTableXAxisMovePosition = smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayTableCenterPosition - (signed long)(smProductSetting->DeviceXPitchOutput*4.5);
				smProductProduction->OutputTrayTableYAxisMovePosition = smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayTableCenterPosition - (signed long)(smProductSetting->DeviceYPitchOutput*4.5);
				smProductProduction->OutputTableCheckSequence = 5;
				smProductProduction->OutputTableResult[0].CurrentOutputTableNo = 0;
				smProductProduction->OutputTableResult[0].OutputTrayNo = smProductProduction->nCurrentOutputTrayNo;
				smProductProduction->OutputTableResult[0].OutputColumn = smProductProduction->nOutputEdgeCoordinateY;
				smProductProduction->OutputTableResult[0].OutputRow = smProductProduction->nOutputEdgeCoordinateX;
				//if (smProductSetting->EnableVision == true && smProductSetting->EnableOutputVision == true && smProductCustomize->EnableOutputVisionModule == true)
				//{

				//	smProductEvent->GMAIN_RTHD_OUT_VISION_GET_RC_DONE.Set = false;
				//	smProductEvent->RTHD_GMAIN_SEND_OUT_VISION_RC_START.Set = true;

				//}
				if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
				{
					smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set = false;
					smProductEvent->StartOutputTrayTableXAxisMotorMove.Set = true;
				}
				if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
				{
					smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set = false;
					smProductEvent->StartOutputTrayTableYAxisMotorMove.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableXYAxisToFirstPositionDone;
				break;
			case nCase2.IsMoveOutputTrayTableXYAxisToFirstPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set == true))
					//&& ((smProductEvent->GMAIN_RTHD_OUT_VISION_GET_RC_DONE.Set == true && smProductSetting->EnableVision == true && smProductSetting->EnableOutputVision == true && smProductCustomize->EnableOutputVisionModule == true)
					//	|| (smProductSetting->EnableVision == false || smProductSetting->EnableOutputVision == false || smProductCustomize->EnableOutputVisionModule == false))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y move to first position done and send output vision row and column done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToUnloadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y move to first position and send output vision row and column Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					//if (smProductEvent->GMAIN_RTHD_OUT_VISION_GET_RC_DONE.Set == false && smProductSetting->EnableVision == true && smProductSetting->EnableOutputVision == true && smProductCustomize->EnableOutputVisionModule == true)
					//{
					//	m_cProductShareVariables->SetAlarm(6807);
					//	m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Vision receive column and row timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					//	nSequenceNoOutput = nCase2.StartSendOutputVisionOutputOrRejectRowAndColumn;
					//}
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(45002);
						m_cLogger->WriteLog("Output Tray Table X Axis Motor Move to first position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToFirstPosition;
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(46002);
						m_cLogger->WriteLog("Output Tray Table Y Axis Motor Move to first position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToFirstPosition;
					}
				}
				break;
			case nCase2.StopMoveOutputTrayTableXYAxisToFirstPosition:
				if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
				{
					smProductEvent->OutputTrayTableXAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableXAxisMotorStop.Set = true;
				}
				if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
				{
					smProductEvent->OutputTrayTableYAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableYAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableXYAxisToFirstPositionDone;
				break;
			case nCase2.IsStopMoveOutputTrayTableXYAxisToFirstPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToFirstPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(45008);
						m_cLogger->WriteLog("Output Tray Table X Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(46008);
						m_cLogger->WriteLog("Output Tray Table Y Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToFirstPosition;
				}
				break;
#pragma region Unloading
			case nCase2.StartMoveOutputTrayTableXYAxisToUnloadingPosition:
				if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == false)
				{
					m_cProductShareVariables->SetAlarm(5511);
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Tray not present on output tray table during unloading.\n");
					nSequenceNoOutput = nCase2.EndOfSequence;
					break;

				}
				else
				{
					if (m_cProductIOControl->IsOutputUnloadingStackerFullSensorOn() == true)
					{
						m_cProductShareVariables->SetAlarm(5413);
						m_cLogger->WriteLog("ManualOutputUnloadingSeq: Tray full on output unloading stacker.\n");
						break;
					}
				}
				if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
				{
					smProductEvent->OutputTrayTableXAxisMotorMoveUnloadDone.Set = false;
					smProductEvent->StartOutputTrayTableXAxisMotorMoveUnload.Set = true;
				}
				if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
				{
					smProductEvent->OutputTrayTableYAxisMotorMoveUnloadDone.Set = false;
					smProductEvent->StartOutputTrayTableYAxisMotorMoveUnload.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableXYAxisToUnloadingPositionDone;
				break;
			case nCase2.IsMoveOutputTrayTableXYAxisToUnloadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveUnloadDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveUnloadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table X Y Axis Move to Unloading position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToSingulationPositionForUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table X Y Axis Move to Unloading position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);

					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveUnloadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(45002);
						m_cLogger->WriteLog("Output Tray Table X Axis Motor Move to Unloading position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveUnloadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(46002);
						m_cLogger->WriteLog("Output Tray Table Y Axis Motor Move to Unloading position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToUnloadingPosition;
				}
				break;
			case nCase2.StopMoveOutputTrayTableXYAxisToUnloadingPosition:
				if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
				{
					smProductEvent->OutputTrayTableXAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableXAxisMotorStop.Set = true;
				}
				if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
				{
					smProductEvent->OutputTrayTableYAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableYAxisMotorStop.Set = true;
				}

				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableXYAxisToUnloadingPositionDone;
				break;
			case nCase2.IsStopMoveOutputTrayTableXYAxisToUnloadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table X Y Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToUnloadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table X Y Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);

					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(45002);
						m_cLogger->WriteLog("Output Tray Table X Axis Motor stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(46002);
						m_cLogger->WriteLog("Output Tray Table Y Axis Motor stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToUnloadingPosition;
				}
				break;
			case nCase2.StartMoveOutputTrayTableZAxisToSingulationPositionForUnloading:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorMoveSingulation.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToSingulationPositionForUnloadingDone;
				break;
			case nCase2.IsMoveOutputTrayTableZAxisToSingulationPositionForUnloadingDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis Move to Singulation position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.OutputUnloadingStackerUnlockCylinderUnlockForUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47002);
						m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis Motor Move to Singulation position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToSingulationPositionForUnloading;
				}
				break;
			case nCase2.StopMoveOutputTrayTableZAxisToSingulationPositionForUnloading:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToSingulationPositionForUnloadingDone;
				break;
			case nCase2.IsStopMoveOutputTrayTableZAxisToSingulationPositionForUnloadingDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToSingulationPositionForUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47008);
						m_cLogger->WriteLog("Output Tray Table Z Axis Motor stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToSingulationPositionForUnloading;
				}
				break;
			case nCase2.OutputUnloadingStackerUnlockCylinderUnlockForUnloading:
				m_cProductIOControl->SetOutputUnloadingStackerUnlockCylinderOn(true);
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsOutputUnloadingStackerUnlockCylinderUnlockForUnloading;
				break;
			case nCase2.IsOutputUnloadingStackerUnlockCylinderUnlockForUnloading:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsOutputUnloadingStackerUnlockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Unloading Stacker unlock cylinder done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToUnloadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsOutputUnloadingStackerUnlockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5418);
						m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Unloading Stacker unlock cylinder Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.OutputUnloadingStackerUnlockCylinderUnlockForUnloading;
				}
				break;
			case nCase2.StartMoveOutputTrayTableZAxisToUnloadingPosition:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorMoveUnloadDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorMoveUnload.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToUnloadingPositionDone;
				break;
			case nCase2.IsMoveOutputTrayTableZAxisToUnloadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveUnloadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis Move to Unloading position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.OutputUnloadingStackerUnlockCylinderLockForUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveUnloadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47002);
						m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis Motor Move to unload position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToUnloadingPosition;
				}
				break;
			case nCase2.StopMoveOutputTrayTableZAxisToUnloadingPosition:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToUnloadingPositionDone;
				break;
			case nCase2.IsStopMoveOutputTrayTableZAxisToUnloadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToUnloadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47002);
						m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis Motor stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToUnloadingPosition;
				}
				break;
			case nCase2.OutputUnloadingStackerUnlockCylinderLockForUnloading:
				m_cProductIOControl->SetOutputUnloadingStackerUnlockCylinderOn(false);
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsOutputUnloadingStackerUnlockCylinderLockForUnloading;
				break;
			case nCase2.IsOutputUnloadingStackerUnlockCylinderLockForUnloading:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsOutputUnloadingStackerLockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Unloading Stacker lock cylinder done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToDownPositionAfterUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsOutputUnloadingStackerLockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5411);
						m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Unloading Stacker lock cylinder Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNoOutput = nCase2.OutputUnloadingStackerUnlockCylinderLockForUnloading;
				}
				break;
			case nCase2.StartMoveOutputTrayTableZAxisToDownPositionAfterUnloading:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorMoveDown.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToDownPositionDoneAfterUnloading;
			case nCase2.IsMoveOutputTrayTableZAxisToDownPositionDoneAfterUnloading:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis Move to down position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.IsOutputTrayTableZAxisAtDownPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47002);
						m_cLogger->WriteLog("Output Tray Table Z Axis Motor Move to down position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToDownPositionAfterUnloading;
				}
				break;
			case nCase2.StopMoveOutputTrayTableZAxisToDownPositionAfterUnloading:
				if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
				{
					smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;

				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionDoneAfterUnloading;
				break;
			case nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionDoneAfterUnloading:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToDownPositionAfterUnloading;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(47008);
						m_cLogger->WriteLog("ManualOutputUnloadingSeq: Output Tray Table Z Axis Motor stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToDownPositionAfterUnloading;
				}
				break;
#pragma endregion
			default:
				return -1;
				break;
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Loading Unloading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			if (nSequenceNoOutput == nCase2.EndOfSequence)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Loading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		break;
#pragma endregion

#pragma region 5007 input loading and vision sequence
	case 5007:
		if (smProductCustomize->EnableInputTrayTableXAxisMotor)
		{
			smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableXAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputTrayTableYAxisMotor)
		{
			smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableYAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputTrayTableZAxisMotor)
		{
			smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartInputTrayTableZAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableXAxisMotor)
		{
			smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableXAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableYAxisMotor)
		{
			smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableYAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableOutputTrayTableZAxisMotor)
		{
			smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartOutputTrayTableZAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableInputVisionMotor)
		{
			smProductEvent->InputVisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartInputVisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS2VisionMotor)
		{
			smProductEvent->S2VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS2VisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS1VisionMotor)
		{
			smProductEvent->S1VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS1VisionModuleMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnableS3VisionMotor)
		{
			smProductEvent->S3VisionModuleMotorSettingUpDone.Set = false;
			smProductEvent->StartS3VisionModuleMotorSettingUp.Set = true;
		}

		if (smProductCustomize->EnablePickAndPlace1XAxisMotor == true)
		{
			smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1XAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace1YAxisMotor == true)
		{
			smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1YAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace1Module == true)
		{
			smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1ZAxisMotorSettingUp.Set = true;

			smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace1ThetaAxisMotorSettingUp.Set = true;
		}

		if (smProductCustomize->EnablePickAndPlace2XAxisMotor == true)
		{
			smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2XAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace2YAxisMotor == true)
		{
			smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2YAxisMotorSettingUp.Set = true;
		}
		if (smProductCustomize->EnablePickAndPlace2Module == true)
		{
			smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2ZAxisMotorSettingUp.Set = true;

			smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set = false;
			smProductEvent->StartPickAndPlace2ThetaAxisMotorSettingUp.Set = true;

		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

			if (true
				&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS2VisionMotor == false || (smProductCustomize->EnableS2VisionMotor == true && smProductEvent->S2VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnableS1VisionMotor == false || (smProductCustomize->EnableS1VisionMotor == true && smProductEvent->S1VisionModuleMotorHomeDone.Set == true))
				&& (smProductCustomize->EnableS3VisionMotor == false || (smProductCustomize->EnableS3VisionMotor == true && smProductEvent->S3VisionModuleMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1XAxisMotor == false || (smProductCustomize->EnablePickAndPlace1XAxisMotor == true && smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1YAxisMotor == false || (smProductCustomize->EnablePickAndPlace1YAxisMotor == true && smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2XAxisMotor == false || (smProductCustomize->EnablePickAndPlace2XAxisMotor == true && smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2YAxisMotor == false || (smProductCustomize->EnablePickAndPlace2YAxisMotor == true && smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set == true))
				&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set == true))
				)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("All Motor Setting up Done %ums\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		smProductEvent->RSEQ_RINT_SEQUENCE_START.Set = true;
		nSequenceNo = nCase.WaitingToReceiveEventStartInputTrayTableSequence;
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		while (smProductEvent->ExitRTX.Set == false)
		{
			switch (nSequenceNo)
			{
			case nCase.WaitingToReceiveEventStartInputTrayTableSequence:
				if (smProductEvent->RSEQ_RINT_SEQUENCE_START.Set == true)
				{
					smProductEvent->RSEQ_RINT_SEQUENCE_START.Set = false;
					smProductProduction->nEdgeCoordinateX = 1;
					smProductProduction->nEdgeCoordinateY = 1;
					InputVisionSequence = 1;
					nCurrentInputVisionDoneCount = 0;
					nCurrentS2VisionDoneCount = 0;
					m_cLogger->WriteLog("ManualInputLoadingSeq: Come in.\n");
					nSequenceNo = nCase.IsInputTrayTableZAxisAtDownPosition;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				}
				break;

			case nCase.IsInputTrayTableZAxisAtDownPosition:
				//if (smProductEvent->JobStop.Set == true)
				//{
				//	m_cLogger->WriteLog("ManualInputLoadingSeq: User stop sequence.\n");
				//	nSequenceNo = nCase.EndOfSequence;
				//	break;
				//}
				if (m_cProductMotorControl->ReadInputTrayTableZAxisMotorEncoder() > smProductTeachPoint->InputTrayTableZAxisDownPosition + 5)
				{
					m_cProductShareVariables->SetAlarm(43010);
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Not At Down Position");
					nSequenceNo = nCase.EndOfSequence;
					break;
				}
				else
				{
					nSequenceNo = nCase.IsInputTrayTableReady;
				}
				break;

			case nCase.IsInputTrayTableReady:
				//if (smProductEvent->JobStop.Set == true)
				//{
				//	m_cLogger->WriteLog("ManualInputLoadingSeq: User stop sequence.\n");
				//	nSequenceNo = nCase.EndOfSequence;
				//	break;
				//}
				if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == false)
				{
					if (m_cProductIOControl->IsInputLoadingStackerPresentSensorOn() == true)
					{
						nSequenceNo = nCase.StartMoveInputTrayTableXYAxisToLoadingPosition;
					}
					else
					{
						m_cProductShareVariables->SetAlarm(5402);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Tray not present on input loading stacker.\n");
						nSequenceNo = nCase.EndOfSequence;
						break;
					}
				}
				else if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == true)
				{
					nSequenceNo = nCase.StartMoveInputTrayTableXYVisionZAxisToFirstPosition;
				}
				break;

			case nCase.StartMoveInputTrayTableXYAxisToLoadingPosition:
				//if (smProductEvent->JobStop.Set == true)
				//{
				//	m_cLogger->WriteLog("ManualInputLoadingSeq: User stop sequence.\n");
				//	nSequenceNo = nCase.EndOfSequence;
				//	break;
				//}
				if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
				{
					smProductEvent->InputTrayTableXAxisMotorMoveLoadDone.Set = false;
					smProductEvent->StartInputTrayTableXAxisMotorMoveLoad.Set = true;
				}
				if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
				{
					smProductEvent->InputTrayTableYAxisMotorMoveLoadDone.Set = false;
					smProductEvent->StartInputTrayTableYAxisMotorMoveLoad.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableXYAxisToLoadingPositionDone;
				break;
			case nCase.IsMoveInputTrayTableXYAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveLoadDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveLoadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis Motor move load position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToLoadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis move load position Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);

					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveLoadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(41002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Axis Motor Move Loading position timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveLoadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(42002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Y Axis Motor Move Loading position timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}

					nSequenceNo = nCase.StopMoveInputTrayTableXYAxisToLoadingPosition;
				}
				break;
			case nCase.StopMoveInputTrayTableXYAxisToLoadingPosition:

				if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
				{
					smProductEvent->InputTrayTableXAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableXAxisMotorStop.Set = true;
				}
				if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
				{
					smProductEvent->InputTrayTableYAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableYAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableXYAxisToLoadingPositionDone;
				break;
			case nCase.IsStopMoveInputTrayTableXYAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableXYAxisToLoadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(41008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(42008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Y Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableXYAxisToLoadingPosition;
				}
				break;
			case nCase.StartMoveInputTrayTableZAxisToLoadingPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorMoveLoadDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorMoveLoad.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableZAxisToLoadingPositionDone;
				break;
			case nCase.IsMoveInputTrayTableZAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveLoadDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor move loading position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.InputLoadingStackerUnlockCylinderUnlock;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveLoadDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Move Loading timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToLoadingPosition;
				}
				break;
			case nCase.StopMoveInputTrayTableZAxisToLoadingPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToLoadingPositionDone;
				break;
			case nCase.IsStopMoveInputTrayTableZAxisToLoadingPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToLoadingPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToLoadingPosition;
				}
				break;
			case nCase.InputLoadingStackerUnlockCylinderUnlock:
				m_cProductIOControl->SetInputLoadingStackerUnlockCylinderOn(true);
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsInputLoadingStackerUnlockCylinderUnlock;
				break;

			case nCase.IsInputLoadingStackerUnlockCylinderUnlock:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsInputLoadingStackerUnlockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Loading Stacker Cylinder Unlock done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToSingulationPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsInputLoadingStackerUnlockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5404);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Loading Stacker Cylinder Unlock Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.InputLoadingStackerUnlockCylinderUnlock;
				}
				break;
			case nCase.StartMoveInputTrayTableZAxisToSingulationPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorMoveSingulation.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableZAxisToSingulationPositionDone;
				break;
			case nCase.IsMoveInputTrayTableZAxisToSingulationPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor move singulation position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.InputLoadingStackerUnlockCylinderLock;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Move Singulation timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToSingulationPosition;
				}
				break;
			case nCase.StopMoveInputTrayTableZAxisToSingulationPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToSingulationPositionDone;
				break;
			case nCase.IsStopMoveInputTrayTableZAxisToSingulationPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToSingulationPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToSingulationPosition;
				}
				break;
			case nCase.InputLoadingStackerUnlockCylinderLock:
				m_cProductIOControl->SetInputLoadingStackerUnlockCylinderOn(false);
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsInputLoadingStackerUnlockCylinderLock;
				break;

			case nCase.IsInputLoadingStackerUnlockCylinderLock:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& m_cProductIOControl->IsInputLoadingStackerLockSensorOn() == true
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Loading Stacker Cylinder lock done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToDownPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (m_cProductIOControl->IsInputLoadingStackerLockSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5403);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Loading Stacker Cylinder lock Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.InputLoadingStackerUnlockCylinderLock;
				}
				break;
			case nCase.StartMoveInputTrayTableZAxisToDownPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorMoveDown.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableZAxisToDownPositionDone;
				break;
			case nCase.IsMoveInputTrayTableZAxisToDownPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == false)
				{

					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
					{
						smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToDownPositionAfterTrayNotPresent;
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Tray Not Present %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor move down position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.IsInputTrayTableReady;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Move down timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToDownPosition;
				}
				break;
			case nCase.IsStopMoveInputTrayTableZAxisToDownPositionAfterTrayNotPresent:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1s);
					nSequenceNo = nCase.CheckIsTrayPresentOnInputTrayTableDuringDown;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
					{
						smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
					}
					nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToDownPositionAfterTrayNotPresent;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				}
				break;
			case nCase.CheckIsTrayPresentOnInputTrayTableDuringDown:
				if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == false)
				{
					//if()if time >preset,then
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 5000)//(LONGLONG)smProductProduction->InputTrayPresentSensorOffTimeBeforeAlarm_ms)
					{
						m_cProductShareVariables->SetAlarm(5510);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Tray Not Present %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//nSequenceNo = nCase.StopMoveInputTrayTableZAxisDownAtLoading;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						break;
					}
				}
				else if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == true)

				{
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToDownPosition;
				}
				break;
			case nCase.StopMoveInputTrayTableZAxisToDownPosition:
				if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
				{
					smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToDownPositionDone;
				break;

			case nCase.IsStopMoveInputTrayTableZAxisToDownPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableZAxisToDownPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(43008);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableZAxisToDownPosition;
				}
				break;
			case nCase.StartMoveInputTrayTableXYVisionZAxisToFirstPosition:
				if (smProductEvent->JobStop.Set == true)
				{
					m_cLogger->WriteLog("InputTrayTableseq: User stop sequence.\n");
					nSequenceNo = nCase.EndOfSequence;
					break;
				}
				//Need to set move position
				smProductProduction->InputTrayTableXAxisMovePosition = smProductTeachPoint->InputTrayTableXAxisAtInputTrayTableCenterPosition + signed long(smProductSetting->DeviceXPitchInput * 4.5);
				smProductProduction->InputTrayTableYAxisMovePosition = smProductTeachPoint->InputTrayTableYAxisAtInputTrayTableCenterPosition + signed long(smProductSetting->DeviceYPitchInput * 9.5);
				smProductProduction->InputTableResult[0].InputTrayNo = smProductProduction->nCurrentInputTrayNo;
				smProductProduction->InputTableResult[0].InputColumn = smProductProduction->nEdgeCoordinateY;
				smProductProduction->InputTableResult[0].InputRow = smProductProduction->nEdgeCoordinateX;
				if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
				{
					smProductEvent->InputTrayTableXAxisMotorMoveDone.Set = false;
					smProductEvent->StartInputTrayTableXAxisMotorMove.Set = true;
				}
				if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
				{
					smProductEvent->InputTrayTableYAxisMotorMoveDone.Set = false;
					smProductEvent->StartInputTrayTableYAxisMotorMove.Set = true;
				}
				if (smProductCustomize->EnableInputVisionMotor == true)
				{
					smProductEvent->InputVisionModuleMotorMoveFocusPositionDone.Set = false;
					smProductEvent->StartInputVisionModuleMotorMoveFocusPosition.Set = true;
				}
				//if (smProductSetting->EnableVision == true && smProductSetting->EnableInputVision == true && smProductCustomize->EnableInputVisionModule == true)
				//{
				//	smProductEvent->GMAIN_RTHD_INP_VISION_GET_RC_DONE.Set = false;
				//	smProductEvent->RTHD_GMAIN_SEND_INP_VISION_RC_START.Set = true;
				//}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsMoveInputTrayTableXYVisionZAxisToFirstPositionDone;
				break;
			case nCase.IsMoveInputTrayTableXYVisionZAxisToFirstPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveDone.Set == true))
					&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorMoveFocusPositionDone.Set == true))
					//&& ((smProductEvent->GMAIN_RTHD_INP_VISION_GET_RC_DONE.Set == true && smProductSetting->EnableVision == true && smProductSetting->EnableInputVision == true && smProductCustomize->EnableInputVisionModule == true)
					//	|| (smProductSetting->EnableVision == false || smProductSetting->EnableInputVision == false || smProductCustomize->EnableInputVisionModule == false))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y move to first position done, Input Vision Module Z Axis Move to focus position done and Send Input Vision Row and column done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.EndOfSequence;
				}

				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y move to first position timeout, Input Vision Module Z Axis Move to focus position and Send input vision row and column Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					//if (smProductEvent->GMAIN_RTHD_INP_VISION_GET_RC_DONE.Set == false && smProductSetting->EnableVision == true && smProductSetting->EnableInputVision == true && smProductCustomize->EnableInputVisionModule == true)
					//{
					//	m_cProductShareVariables->SetAlarm(6109);
					//	m_cLogger->WriteLog("ManualInputLoadingSeq: Input Vision receive column and row timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					//	nSequenceNo = nCase.StartSendInputVisionRowAndColumn;
					//}
					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(41002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Axis Motor Move to first position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.StopMoveInputTrayTableXYVisionZAxisToFirstPosition;
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(42002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Y Axis Motor Move to first position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.StopMoveInputTrayTableXYVisionZAxisToFirstPosition;
					}
					if (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorMoveFocusPositionDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(48002);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Vision Z Axis Motor Move to focus position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.StopMoveInputTrayTableXYVisionZAxisToFirstPosition;
					}

				}
				break;
			case nCase.StopMoveInputTrayTableXYVisionZAxisToFirstPosition:
				if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
				{
					smProductEvent->InputTrayTableXAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableXAxisMotorStop.Set = true;
				}
				if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
				{
					smProductEvent->InputTrayTableYAxisMotorStopDone.Set = false;
					smProductEvent->StartInputTrayTableYAxisMotorStop.Set = true;
				}
				if (smProductCustomize->EnableInputVisionMotor == true)
				{
					smProductEvent->InputVisionModuleMotorStopDone.Set = false;
					smProductEvent->StartInputVisionModuleMotorStop.Set = true;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
				nSequenceNo = nCase.IsStopMoveInputTrayTableXYVisionZAxisToFirstPositionDone;
				break;
			case nCase.IsStopMoveInputTrayTableXYVisionZAxisToFirstPositionDone:
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				if (true
					&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == true))
					&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorStopDone.Set == true))
					)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis and Input Vision Module Z Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					nSequenceNo = nCase.StartMoveInputTrayTableXYVisionZAxisToFirstPosition;
				}
				else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
				{
					m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis and Input Vision Module Z Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(41008);
						m_cLogger->WriteLog("Input Tray Table X Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(42008);
						m_cLogger->WriteLog("Input Tray Table Y Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					if (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorStopDone.Set == false)
					{
						m_cProductShareVariables->SetAlarm(48008);
						m_cLogger->WriteLog("Input Vision Z Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					}
					nSequenceNo = nCase.StopMoveInputTrayTableXYVisionZAxisToFirstPosition;
				}
				break;
			default:
				return -1;
				break;
			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			if (smProductEvent->StopManualMode.Set == true)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Loading Unloading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			if (nSequenceNo == nCase.EndOfSequence)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Loading and Vision Snap 1 Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		break;
#pragma endregion

#pragma region 5008 input tray move to next unit position
		case 5008:
			if (smProductCustomize->EnableInputTrayTableXAxisMotor)
			{
				smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartInputTrayTableXAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableInputTrayTableYAxisMotor)
			{
				smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartInputTrayTableYAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableInputTrayTableZAxisMotor)
			{
				smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartInputTrayTableZAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableOutputTrayTableXAxisMotor)
			{
				smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartOutputTrayTableXAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableOutputTrayTableYAxisMotor)
			{
				smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartOutputTrayTableYAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableOutputTrayTableZAxisMotor)
			{
				smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartOutputTrayTableZAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableInputVisionMotor)
			{
				smProductEvent->InputVisionModuleMotorSettingUpDone.Set = false;
				smProductEvent->StartInputVisionModuleMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableS2VisionMotor)
			{
				smProductEvent->S2VisionModuleMotorSettingUpDone.Set = false;
				smProductEvent->StartS2VisionModuleMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableS1VisionMotor)
			{
				smProductEvent->S1VisionModuleMotorSettingUpDone.Set = false;
				smProductEvent->StartS1VisionModuleMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableS3VisionMotor)
			{
				smProductEvent->S3VisionModuleMotorSettingUpDone.Set = false;
				smProductEvent->StartS3VisionModuleMotorSettingUp.Set = true;
			}

			if (smProductCustomize->EnablePickAndPlace1XAxisMotor == true)
			{
				smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace1XAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnablePickAndPlace1YAxisMotor == true)
			{
				smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace1YAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnablePickAndPlace1Module == true)
			{
				smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace1ZAxisMotorSettingUp.Set = true;

				smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace1ThetaAxisMotorSettingUp.Set = true;
			}

			if (smProductCustomize->EnablePickAndPlace2XAxisMotor == true)
			{
				smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace2XAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnablePickAndPlace2YAxisMotor == true)
			{
				smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace2YAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnablePickAndPlace2Module == true)
			{
				smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace2ZAxisMotorSettingUp.Set = true;

				smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace2ThetaAxisMotorSettingUp.Set = true;

			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			while (smProductEvent->ExitRTX.Set == false)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

				if (true
					&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableS2VisionMotor == false || (smProductCustomize->EnableS2VisionMotor == true && smProductEvent->S2VisionModuleMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableS1VisionMotor == false || (smProductCustomize->EnableS1VisionMotor == true && smProductEvent->S1VisionModuleMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableS3VisionMotor == false || (smProductCustomize->EnableS3VisionMotor == true && smProductEvent->S3VisionModuleMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace1XAxisMotor == false || (smProductCustomize->EnablePickAndPlace1XAxisMotor == true && smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace1YAxisMotor == false || (smProductCustomize->EnablePickAndPlace1YAxisMotor == true && smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace2XAxisMotor == false || (smProductCustomize->EnablePickAndPlace2XAxisMotor == true && smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace2YAxisMotor == false || (smProductCustomize->EnablePickAndPlace2YAxisMotor == true && smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set == true))
					)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("All Motor Setting up Done %ums\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			}
			smProductEvent->RSEQ_RINT_SEQUENCE_START.Set = true;
			nSequenceNo = nCase.WaitingToReceiveEventStartInputTrayTableSequence;
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			while (smProductEvent->ExitRTX.Set == false)
			{
				switch (nSequenceNo)
				{
				case nCase.WaitingToReceiveEventStartInputTrayTableSequence:
					if (smProductEvent->RSEQ_RINT_SEQUENCE_START.Set == true)
					{
						smProductEvent->RSEQ_RINT_SEQUENCE_START.Set = false;
						smProductProduction->nEdgeCoordinateX = 1;
						smProductProduction->nEdgeCoordinateY = 1;
						InputVisionSequence = 1;
						nCurrentInputVisionDoneCount = 0;
						nCurrentS2VisionDoneCount = 0;
						m_cLogger->WriteLog("ManualInputLoadingSeq: Come in.\n");
						nSequenceNo = nCase.IsInputTrayTableZAxisAtDownPosition;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
					}
					break;

				case nCase.IsInputTrayTableZAxisAtDownPosition:
					//if (smProductEvent->JobStop.Set == true)
					//{
					//	m_cLogger->WriteLog("ManualInputLoadingSeq: User stop sequence.\n");
					//	nSequenceNo = nCase.EndOfSequence;
					//	break;
					//}
					if (m_cProductMotorControl->ReadInputTrayTableZAxisMotorEncoder() > smProductTeachPoint->InputTrayTableZAxisDownPosition + 5)
					{
						m_cProductShareVariables->SetAlarm(43010);
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Not At Down Position");
						nSequenceNo = nCase.EndOfSequence;
						break;
					}
					else
					{
						nSequenceNo = nCase.IsInputTrayTableReady;
					}
					break;

				case nCase.IsInputTrayTableReady:
					//if (smProductEvent->JobStop.Set == true)
					//{
					//	m_cLogger->WriteLog("ManualInputLoadingSeq: User stop sequence.\n");
					//	nSequenceNo = nCase.EndOfSequence;
					//	break;
					//}
					if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == false)
					{
						if (m_cProductIOControl->IsInputLoadingStackerPresentSensorOn() == true)
						{
							nSequenceNo = nCase.StartMoveInputTrayTableXYAxisToLoadingPosition;
						}
						else
						{
							m_cProductShareVariables->SetAlarm(5402);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Tray not present on input loading stacker.\n");
							nSequenceNo = nCase.EndOfSequence;
							break;
						}
					}
					else if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == true)
					{
						nSequenceNo = nCase.StartMoveInputTrayTableXYVisionZAxisToFirstPosition;
					}
					break;

				case nCase.StartMoveInputTrayTableXYAxisToLoadingPosition:
					//if (smProductEvent->JobStop.Set == true)
					//{
					//	m_cLogger->WriteLog("ManualInputLoadingSeq: User stop sequence.\n");
					//	nSequenceNo = nCase.EndOfSequence;
					//	break;
					//}
					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
					{
						smProductEvent->InputTrayTableXAxisMotorMoveLoadDone.Set = false;
						smProductEvent->StartInputTrayTableXAxisMotorMoveLoad.Set = true;
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
					{
						smProductEvent->InputTrayTableYAxisMotorMoveLoadDone.Set = false;
						smProductEvent->StartInputTrayTableYAxisMotorMoveLoad.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNo = nCase.IsMoveInputTrayTableXYAxisToLoadingPositionDone;
					break;
				case nCase.IsMoveInputTrayTableXYAxisToLoadingPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveLoadDone.Set == true))
						&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveLoadDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis Motor move load position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.StartMoveInputTrayTableZAxisToLoadingPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis move load position Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);

						if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveLoadDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(41002);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Axis Motor Move Loading position timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveLoadDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(42002);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Y Axis Motor Move Loading position timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}

						nSequenceNo = nCase.StopMoveInputTrayTableXYAxisToLoadingPosition;
					}
					break;
				case nCase.StopMoveInputTrayTableXYAxisToLoadingPosition:

					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
					{
						smProductEvent->InputTrayTableXAxisMotorStopDone.Set = false;
						smProductEvent->StartInputTrayTableXAxisMotorStop.Set = true;
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
					{
						smProductEvent->InputTrayTableYAxisMotorStopDone.Set = false;
						smProductEvent->StartInputTrayTableYAxisMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNo = nCase.IsStopMoveInputTrayTableXYAxisToLoadingPositionDone;
					break;
				case nCase.IsStopMoveInputTrayTableXYAxisToLoadingPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == true))
						&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.StartMoveInputTrayTableXYAxisToLoadingPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(41008);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(42008);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Y Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNo = nCase.StopMoveInputTrayTableXYAxisToLoadingPosition;
					}
					break;
				case nCase.StartMoveInputTrayTableZAxisToLoadingPosition:
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
					{
						smProductEvent->InputTrayTableZAxisMotorMoveLoadDone.Set = false;
						smProductEvent->StartInputTrayTableZAxisMotorMoveLoad.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNo = nCase.IsMoveInputTrayTableZAxisToLoadingPositionDone;
					break;
				case nCase.IsMoveInputTrayTableZAxisToLoadingPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveLoadDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor move loading position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.InputLoadingStackerUnlockCylinderUnlock;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveLoadDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(43002);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Move Loading timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNo = nCase.StopMoveInputTrayTableZAxisToLoadingPosition;
					}
					break;
				case nCase.StopMoveInputTrayTableZAxisToLoadingPosition:
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
					{
						smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToLoadingPositionDone;
					break;
				case nCase.IsStopMoveInputTrayTableZAxisToLoadingPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.StartMoveInputTrayTableZAxisToLoadingPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(43008);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNo = nCase.StopMoveInputTrayTableZAxisToLoadingPosition;
					}
					break;
				case nCase.InputLoadingStackerUnlockCylinderUnlock:
					m_cProductIOControl->SetInputLoadingStackerUnlockCylinderOn(true);
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNo = nCase.IsInputLoadingStackerUnlockCylinderUnlock;
					break;

				case nCase.IsInputLoadingStackerUnlockCylinderUnlock:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& m_cProductIOControl->IsInputLoadingStackerUnlockSensorOn() == true
						)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Loading Stacker Cylinder Unlock done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.StartMoveInputTrayTableZAxisToSingulationPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (m_cProductIOControl->IsInputLoadingStackerUnlockSensorOn() == false)
						{
							m_cProductShareVariables->SetAlarm(5404);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Input Loading Stacker Cylinder Unlock Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNo = nCase.InputLoadingStackerUnlockCylinderUnlock;
					}
					break;
				case nCase.StartMoveInputTrayTableZAxisToSingulationPosition:
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
					{
						smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set = false;
						smProductEvent->StartInputTrayTableZAxisMotorMoveSingulation.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNo = nCase.IsMoveInputTrayTableZAxisToSingulationPositionDone;
					break;
				case nCase.IsMoveInputTrayTableZAxisToSingulationPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor move singulation position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.InputLoadingStackerUnlockCylinderLock;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveSingulationDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(43002);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Move Singulation timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNo = nCase.StopMoveInputTrayTableZAxisToSingulationPosition;
					}
					break;
				case nCase.StopMoveInputTrayTableZAxisToSingulationPosition:
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
					{
						smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToSingulationPositionDone;
					break;
				case nCase.IsStopMoveInputTrayTableZAxisToSingulationPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.StartMoveInputTrayTableZAxisToSingulationPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(43008);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNo = nCase.StopMoveInputTrayTableZAxisToSingulationPosition;
					}
					break;
				case nCase.InputLoadingStackerUnlockCylinderLock:
					m_cProductIOControl->SetInputLoadingStackerUnlockCylinderOn(false);
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNo = nCase.IsInputLoadingStackerUnlockCylinderLock;
					break;

				case nCase.IsInputLoadingStackerUnlockCylinderLock:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& m_cProductIOControl->IsInputLoadingStackerLockSensorOn() == true
						)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Loading Stacker Cylinder lock done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.StartMoveInputTrayTableZAxisToDownPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (m_cProductIOControl->IsInputLoadingStackerLockSensorOn() == false)
						{
							m_cProductShareVariables->SetAlarm(5403);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Input Loading Stacker Cylinder lock Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNo = nCase.InputLoadingStackerUnlockCylinderLock;
					}
					break;
				case nCase.StartMoveInputTrayTableZAxisToDownPosition:
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
					{
						smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set = false;
						smProductEvent->StartInputTrayTableZAxisMotorMoveDown.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNo = nCase.IsMoveInputTrayTableZAxisToDownPositionDone;
					break;
				case nCase.IsMoveInputTrayTableZAxisToDownPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == false)
					{

						if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
						{
							smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
							smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
						}
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToDownPositionAfterTrayNotPresent;
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Tray Not Present %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						break;
					}
					if (true
						&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor move down position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.IsInputTrayTableReady;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorMoveDownDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(43002);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Move down timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNo = nCase.StopMoveInputTrayTableZAxisToDownPosition;
					}
					break;
				case nCase.IsStopMoveInputTrayTableZAxisToDownPositionAfterTrayNotPresent:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1s);
						nSequenceNo = nCase.CheckIsTrayPresentOnInputTrayTableDuringDown;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(43008);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
						{
							smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
							smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
						}
						nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToDownPositionAfterTrayNotPresent;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					}
					break;
				case nCase.CheckIsTrayPresentOnInputTrayTableDuringDown:
					if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == false)
					{
						//if()if time >preset,then
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
						if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 5000)//(LONGLONG)smProductProduction->InputTrayPresentSensorOffTimeBeforeAlarm_ms)
						{
							m_cProductShareVariables->SetAlarm(5510);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Tray Not Present %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							//nSequenceNo = nCase.StopMoveInputTrayTableZAxisDownAtLoading;
							RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
							break;
						}
					}
					else if (m_cProductIOControl->IsInputTrayTableTrayPresentSensorOn() == true)

					{
						nSequenceNo = nCase.StartMoveInputTrayTableZAxisToDownPosition;
					}
					break;
				case nCase.StopMoveInputTrayTableZAxisToDownPosition:
					if (smProductCustomize->EnableInputTrayTableZAxisMotor == true)
					{
						smProductEvent->InputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartInputTrayTableZAxisMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNo = nCase.IsStopMoveInputTrayTableZAxisToDownPositionDone;
					break;

				case nCase.IsStopMoveInputTrayTableZAxisToDownPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.StartMoveInputTrayTableZAxisToDownPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(43008);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNo = nCase.StopMoveInputTrayTableZAxisToDownPosition;
					}
					break;
				case nCase.StartMoveInputTrayTableXYVisionZAxisToFirstPosition:
					if (smProductEvent->StopManualMode.Set == true)
					{
						m_cLogger->WriteLog("InputTrayTableseq: User stop sequence.\n");
						nSequenceNo = nCase.EndOfSequence;
						break;
					}
					//Need to set move position
					//smProductProduction->InputTrayTableXAxisMovePosition = smProductTeachPoint->InputTrayTableXAxisAtInputTrayTableCenterPosition + signed long(smProductSetting->DeviceXPitchInput * 4.5);
					//smProductProduction->InputTrayTableYAxisMovePosition = smProductTeachPoint->InputTrayTableYAxisAtInputTrayTableCenterPosition + signed long(smProductSetting->DeviceYPitchInput * 9.5);
														
					smProductProduction->InputTrayTableXAxisMovePosition = smProductTeachPoint->InputTrayTableXAxisAtInputTrayTableCenterPosition + signed long(smProductSetting->DeviceXPitchInput * ((double)(smProductSetting->NoOfDeviceInRowInput - 1) / 2));
					smProductProduction->InputTrayTableYAxisMovePosition = smProductTeachPoint->InputTrayTableYAxisAtInputTrayTableCenterPosition + signed long(smProductSetting->DeviceYPitchInput * ((double)(smProductSetting->NoOfDeviceInColInput - 1) / 2));

					smProductProduction->InputTableResult[0].InputTrayNo = smProductProduction->nCurrentInputTrayNo;
					smProductProduction->InputTableResult[0].InputColumn = smProductProduction->nEdgeCoordinateY;
					smProductProduction->InputTableResult[0].InputRow = smProductProduction->nEdgeCoordinateX;
					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
					{
						smProductEvent->InputTrayTableXAxisMotorMoveDone.Set = false;
						smProductEvent->StartInputTrayTableXAxisMotorMove.Set = true;
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
					{
						smProductEvent->InputTrayTableYAxisMotorMoveDone.Set = false;
						smProductEvent->StartInputTrayTableYAxisMotorMove.Set = true;
					}
					if (smProductCustomize->EnableInputVisionMotor == true)
					{
						smProductEvent->InputVisionModuleMotorMoveFocusPositionDone.Set = false;
						smProductEvent->StartInputVisionModuleMotorMoveFocusPosition.Set = true;
					}
					//if (smProductSetting->EnableVision == true && smProductSetting->EnableInputVision == true && smProductCustomize->EnableInputVisionModule == true)
					//{
					//	smProductEvent->GMAIN_RTHD_INP_VISION_GET_RC_DONE.Set = false;
					//	smProductEvent->RTHD_GMAIN_SEND_INP_VISION_RC_START.Set = true;
					//}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNo = nCase.IsMoveInputTrayTableXYVisionZAxisToFirstPositionDone;
					break;
				case nCase.IsMoveInputTrayTableXYVisionZAxisToFirstPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveDone.Set == true))
						&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveDone.Set == true))
						&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorMoveFocusPositionDone.Set == true))
						//&& ((smProductEvent->GMAIN_RTHD_INP_VISION_GET_RC_DONE.Set == true && smProductSetting->EnableVision == true && smProductSetting->EnableInputVision == true && smProductCustomize->EnableInputVisionModule == true)
						//	|| (smProductSetting->EnableVision == false || smProductSetting->EnableInputVision == false || smProductCustomize->EnableInputVisionModule == false))
						)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y move to first position done, Input Vision Module Z Axis Move to focus position done and Send Input Vision Row and column done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						smProductProduction->nEdgeCoordinateX = 1;
						smProductProduction->nEdgeCoordinateY = 1;
						smProductProduction->InputTrayTableXIndexPosition = smProductProduction->InputTrayTableXAxisMovePosition;
						smProductProduction->InputTrayTableYIndexPosition = smProductProduction->InputTrayTableYAxisMovePosition;
						nSequenceNo = nCase.SetNextUnitInput;
					}

					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y move to first position timeout, Input Vision Module Z Axis Move to focus position and Send input vision row and column Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//if (smProductEvent->GMAIN_RTHD_INP_VISION_GET_RC_DONE.Set == false && smProductSetting->EnableVision == true && smProductSetting->EnableInputVision == true && smProductCustomize->EnableInputVisionModule == true)
						//{
						//	m_cProductShareVariables->SetAlarm(6109);
						//	m_cLogger->WriteLog("ManualInputLoadingSeq: Input Vision receive column and row timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//	nSequenceNo = nCase.StartSendInputVisionRowAndColumn;
						//}
						if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(41002);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Axis Motor Move to first position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nSequenceNo = nCase.StopMoveInputTrayTableXYVisionZAxisToFirstPosition;
						}
						if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(42002);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table Y Axis Motor Move to first position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nSequenceNo = nCase.StopMoveInputTrayTableXYVisionZAxisToFirstPosition;
						}
						if (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorMoveFocusPositionDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(48002);
							m_cLogger->WriteLog("ManualInputLoadingSeq: Input Vision Z Axis Motor Move to focus position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nSequenceNo = nCase.StopMoveInputTrayTableXYVisionZAxisToFirstPosition;
						}

					}
					break;
				case nCase.StopMoveInputTrayTableXYVisionZAxisToFirstPosition:
					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
					{
						smProductEvent->InputTrayTableXAxisMotorStopDone.Set = false;
						smProductEvent->StartInputTrayTableXAxisMotorStop.Set = true;
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
					{
						smProductEvent->InputTrayTableYAxisMotorStopDone.Set = false;
						smProductEvent->StartInputTrayTableYAxisMotorStop.Set = true;
					}
					if (smProductCustomize->EnableInputVisionMotor == true)
					{
						smProductEvent->InputVisionModuleMotorStopDone.Set = false;
						smProductEvent->StartInputVisionModuleMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNo = nCase.IsStopMoveInputTrayTableXYVisionZAxisToFirstPositionDone;
					break;
				case nCase.IsStopMoveInputTrayTableXYVisionZAxisToFirstPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == true))
						&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == true))
						&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis and Input Vision Module Z Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.StartMoveInputTrayTableXYVisionZAxisToFirstPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualInputLoadingSeq: Input Tray Table X Y Axis and Input Vision Module Z Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(41008);
							m_cLogger->WriteLog("Input Tray Table X Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(42008);
							m_cLogger->WriteLog("Input Tray Table Y Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(48008);
							m_cLogger->WriteLog("Input Vision Z Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNo = nCase.StopMoveInputTrayTableXYVisionZAxisToFirstPosition;
					}
					break;

				case nCase.SetNextUnitInput:
					if (smProductEvent->StopManualMode.Set == true)
					{
						m_cLogger->WriteLog("ManualInputNextPosSeq: User stop sequence.\n");
						nSequenceNo = nCase.EndOfSequence;
						break;
					}

					{
						if (smProductProduction->InputTableResult[0].InputRow % 2 != 0) //odd
						{
							smProductProduction->nEdgeCoordinateY++;

							smProductProduction->InputTrayTableYIndexPosition -= (signed long)(smProductSetting->DeviceYPitchInput);

							if (smProductProduction->nEdgeCoordinateY > smProductSetting->NoOfDeviceInColInput)
							{
								smProductProduction->nEdgeCoordinateY--;
								smProductProduction->nEdgeCoordinateX++;
								if (smProductProduction->nEdgeCoordinateX > smProductSetting->NoOfDeviceInRowInput)
								{
									smProductEvent->RINP_RSEQ_INPUT_TRAY_FULL.Set = true;
									smProductProduction->nCurrentInputUnitOnTray = 0;
									smProductProduction->LastUnit = true;
									nSequenceNo = nCase.EndOfSequence;
									break;
								}
								smProductProduction->InputTrayTableXIndexPosition -= (signed long)(smProductSetting->DeviceXPitchInput);
								smProductProduction->InputTrayTableYIndexPosition += (signed long)(smProductSetting->DeviceYPitchInput);
							}

						}
						else if (smProductProduction->InputTableResult[0].InputRow % 2 == 0) //even
						{
							smProductProduction->nEdgeCoordinateY--;

							smProductProduction->InputTrayTableYIndexPosition += (signed long)(smProductSetting->DeviceYPitchInput);

							if (smProductProduction->nEdgeCoordinateY < 1)
							{
								smProductProduction->nEdgeCoordinateY++;
								smProductProduction->nEdgeCoordinateX++;
								if (smProductProduction->nEdgeCoordinateX > smProductSetting->NoOfDeviceInRowInput)
								{
									smProductEvent->RINP_RSEQ_INPUT_TRAY_FULL.Set = true;
									smProductProduction->nCurrentInputUnitOnTray = 0;
									smProductProduction->LastUnit = true;
									nSequenceNo = nCase.EndOfSequence;
									break;
								}
								smProductProduction->InputTrayTableYIndexPosition -= (signed long)(smProductSetting->DeviceYPitchInput);
								smProductProduction->InputTrayTableXIndexPosition -= (signed long)(smProductSetting->DeviceXPitchInput);

							}
						}
						smProductProduction->InputTrayTableXAxisMovePosition = smProductProduction->InputTrayTableXIndexPosition;
						smProductProduction->InputTrayTableYAxisMovePosition = smProductProduction->InputTrayTableYIndexPosition;
					}
					nSequenceNo = nCase.StartSendInputVisionRowAndColumnBeforeToNextPosition;
					break;

				case nCase.StartSendInputVisionRowAndColumnBeforeToNextPosition:
					if (smProductEvent->StopManualMode.Set == true)
					{
						m_cLogger->WriteLog("ManualInputNextPosSeq: User stop sequence.\n");
						nSequenceNo = nCase.EndOfSequence;
						break;
					}
					smProductProduction->InputTableResult[0].InputTrayNo = smProductProduction->nCurrentInputTrayNo;
					smProductProduction->InputTableResult[0].InputColumn = smProductProduction->nEdgeCoordinateY;
					smProductProduction->InputTableResult[0].InputRow = smProductProduction->nEdgeCoordinateX;


					m_cLogger->WriteLog("ManualInputNextPosSeq: Start send input vision row and column before to next position.\n");
					nSequenceNo = nCase.StartMoveInputTrayTableXYAxisToNextPosition;
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					break;
				case nCase.StartMoveInputTrayTableXYAxisToNextPosition:
					if (smProductEvent->StopManualMode.Set == true)
					{
						m_cLogger->WriteLog("ManualInputNextPosSeq: User stop sequence.\n");
						nSequenceNo = nCase.EndOfSequence;
						break;
					}
					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
					{
						smProductEvent->InputTrayTableXAxisMotorMoveDone.Set = false;
						smProductEvent->StartInputTrayTableXAxisMotorMove.Set = true;
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
					{
						smProductEvent->InputTrayTableYAxisMotorMoveDone.Set = false;
						smProductEvent->StartInputTrayTableYAxisMotorMove.Set = true;
					}
					if (smProductCustomize->EnableInputVisionMotor == true)
					{
						smProductEvent->InputVisionModuleMotorMoveFocusPositionDone.Set = false;
						smProductEvent->StartInputVisionModuleMotorMoveFocusPosition.Set = true;
					}
					m_cLogger->WriteLog("ManualInputNextPosSeq: Start Input Tray Table X Y Axis Move to next position, input vision move to focus position.\n");
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNo = nCase.IsMoveInputTrayTableXYAxisToNextPositionDone;
					break;
				case nCase.IsMoveInputTrayTableXYAxisToNextPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveDone.Set == true))
						&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveDone.Set == true))
						&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorMoveFocusPositionDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualInputNextPosSeq: Input Tray Table X Y Axis Move to next position done, input vision move to focus position done done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.SetNextUnitInput;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualInputNextPosSeq: Input Tray Table X Y Axis Move to next position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorMoveDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(41002);
							m_cLogger->WriteLog("ManualInputNextPosSeq: Input Tray Table X Axis Motor Move to next position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nSequenceNo = nCase.StopMoveInputTrayTableXYAxisToNextPosition;
						}
						if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorMoveDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(42002);
							m_cLogger->WriteLog("ManualInputNextPosSeq: Input Tray Table Y Axis Motor Move to next position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nSequenceNo = nCase.StopMoveInputTrayTableXYAxisToNextPosition;
						}
						if (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorMoveFocusPositionDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(48002);
							m_cLogger->WriteLog("ManualInputNextPosSeq: InputTrayTableSeq: Input Vision Z Axis Motor Move to focus position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nSequenceNo = nCase.StopMoveInputTrayTableXYAxisToNextPosition;
						}
					}
					break;
				case nCase.StopMoveInputTrayTableXYAxisToNextPosition:

					if (smProductCustomize->EnableInputTrayTableXAxisMotor == true)
					{
						smProductEvent->InputTrayTableXAxisMotorStopDone.Set = false;
						smProductEvent->StartInputTrayTableXAxisMotorStop.Set = true;
					}
					if (smProductCustomize->EnableInputTrayTableYAxisMotor == true)
					{
						smProductEvent->InputTrayTableYAxisMotorStopDone.Set = false;
						smProductEvent->StartInputTrayTableYAxisMotorStop.Set = true;
					}
					if (smProductCustomize->EnableInputVisionMotor == true)
					{
						smProductEvent->InputVisionModuleMotorStopDone.Set = false;
						smProductEvent->StartInputVisionModuleMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNo = nCase.IsStopMoveInputTrayTableXYAxisToNextPositionDone;
					break;
				case nCase.IsStopMoveInputTrayTableXYAxisToNextPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == true))
						&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == true))
						&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualInputNextPosSeq: Input Tray Table X Y Axis and input vision stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNo = nCase.StartMoveInputTrayTableXYAxisToNextPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualInputNextPosSeq: Input Tray Table X Y Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(41008);
							m_cLogger->WriteLog("ManualInputNextPosSeq: Input Tray Table X Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(42008);
							m_cLogger->WriteLog("ManualInputNextPosSeq: Input Tray Table Y Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(48008);
							m_cLogger->WriteLog("ManualInputNextPosSeq: InputTrayTableSeq: Input Vision Z Axis Motor stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNo = nCase.StopMoveInputTrayTableXYAxisToNextPosition;
					}
					break;
				default:
					return -1;
					break;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				if (smProductEvent->StopManualMode.Set == true)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualInputNextPosSeq: Input Loading Unloading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				if (nSequenceNo == nCase.EndOfSequence)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("ManualInputNextPosSeq: Input Loading and Vision Snap 1 Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			}
			break;
#pragma endregion

#pragma region 5009 output tray move to next unit position
		case 5009:
			if (smProductCustomize->EnableInputTrayTableXAxisMotor)
			{
				smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartInputTrayTableXAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableInputTrayTableYAxisMotor)
			{
				smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartInputTrayTableYAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableInputTrayTableZAxisMotor)
			{
				smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartInputTrayTableZAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableOutputTrayTableXAxisMotor)
			{
				smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartOutputTrayTableXAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableOutputTrayTableYAxisMotor)
			{
				smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartOutputTrayTableYAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableOutputTrayTableZAxisMotor)
			{
				smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartOutputTrayTableZAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableInputVisionMotor)
			{
				smProductEvent->InputVisionModuleMotorSettingUpDone.Set = false;
				smProductEvent->StartInputVisionModuleMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableS2VisionMotor)
			{
				smProductEvent->S2VisionModuleMotorSettingUpDone.Set = false;
				smProductEvent->StartS2VisionModuleMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableS1VisionMotor)
			{
				smProductEvent->S1VisionModuleMotorSettingUpDone.Set = false;
				smProductEvent->StartS1VisionModuleMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableS3VisionMotor)
			{
				smProductEvent->S3VisionModuleMotorSettingUpDone.Set = false;
				smProductEvent->StartS3VisionModuleMotorSettingUp.Set = true;
			}

			if (smProductCustomize->EnablePickAndPlace1XAxisMotor == true)
			{
				smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace1XAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnablePickAndPlace1YAxisMotor == true)
			{
				smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace1YAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnablePickAndPlace1Module == true)
			{
				smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace1ZAxisMotorSettingUp.Set = true;

				smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace1ThetaAxisMotorSettingUp.Set = true;
			}

			if (smProductCustomize->EnablePickAndPlace2XAxisMotor == true)
			{
				smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace2XAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnablePickAndPlace2YAxisMotor == true)
			{
				smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace2YAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnablePickAndPlace2Module == true)
			{
				smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace2ZAxisMotorSettingUp.Set = true;

				smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace2ThetaAxisMotorSettingUp.Set = true;

			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			while (smProductEvent->ExitRTX.Set == false)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

				if (true
					&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableS2VisionMotor == false || (smProductCustomize->EnableS2VisionMotor == true && smProductEvent->S2VisionModuleMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableS1VisionMotor == false || (smProductCustomize->EnableS1VisionMotor == true && smProductEvent->S1VisionModuleMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableS3VisionMotor == false || (smProductCustomize->EnableS3VisionMotor == true && smProductEvent->S3VisionModuleMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace1XAxisMotor == false || (smProductCustomize->EnablePickAndPlace1XAxisMotor == true && smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace1YAxisMotor == false || (smProductCustomize->EnablePickAndPlace1YAxisMotor == true && smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace2XAxisMotor == false || (smProductCustomize->EnablePickAndPlace2XAxisMotor == true && smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace2YAxisMotor == false || (smProductCustomize->EnablePickAndPlace2YAxisMotor == true && smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set == true))
					)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("All Motor Setting up Done %ums\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			}
			smProductEvent->RSEQ_ROUT_SEQUENCE_START.Set = true;
			nSequenceNoOutput = nCase2.WaitingToReceiveEventStartOutputAndRejectTrayTableSequence;
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			while (smProductEvent->ExitRTX.Set == false)
			{
				switch (nSequenceNoOutput)
				{
				case nCase2.WaitingToReceiveEventStartOutputAndRejectTrayTableSequence:
					if (smProductEvent->RSEQ_ROUT_SEQUENCE_START.Set == true)
					{
						smProductEvent->RSEQ_ROUT_SEQUENCE_START.Set = false;
						smProductEvent->ROUT_RINT_OUTPUT_PRE_PRODUCTION_DONE.Set = false;
						smProductProduction->nRejectEdgeCoordinateX = 1;
						smProductProduction->nRejectEdgeCoordinateY = 1;
						smProductProduction->nOutputEdgeCoordinateX = 1;
						smProductProduction->nOutputEdgeCoordinateY = 1;
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Come in.\n");
						nSequenceNoOutput = nCase2.IsOutputTrayTableZAxisAtDownPosition;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
					}
					break;
				case nCase2.IsOutputTrayTableZAxisAtDownPosition:
					//if (smProductEvent->JobStop.Set == true)
					//{
					//	m_cLogger->WriteLog("ManualOutputLoadingSeq: User stop sequence.\n");
					//	nSequenceNoOutput = nCase2.EndOfSequence;
					//	break;
					//}
					if (m_cProductMotorControl->IsOutputTrayTableXAxisMotorSafeToMove() == false || m_cProductMotorControl->IsOutputTrayTableYAxisMotorSafeToMove() == false)
					{
						m_cProductShareVariables->SetAlarm(47010);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Not At Down Position");
						nSequenceNoOutput = nCase2.EndOfSequence;
						break;
					}
					else
					{
						nSequenceNoOutput = nCase2.IsOutputTrayTableReady;
					}
					break;

				case nCase2.IsOutputTrayTableReady:
					//if (smProductEvent->JobStop.Set == true)
					//{
					//	m_cLogger->WriteLog("ManualOutputLoadingSeq: User stop sequence.\n");
					//	nSequenceNoOutput = nCase2.EndOfSequence;
					//	break;
					//}
					if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == false)
					{
						if (m_cProductIOControl->IsOutputLoadingStackerPresentSensorOn() == true)
						{
							nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToLoadingPosition;
						}
						else
						{
							m_cProductShareVariables->SetAlarm(5410);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Tray not present on output loading stacker.\n");
							nSequenceNoOutput = nCase2.EndOfSequence;
							break;
						}
					}
					else if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == true)
					{
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToFirstPosition;
					}
					break;
				case nCase2.StartMoveOutputTrayTableXYAxisToLoadingPosition:
					//if (smProductEvent->JobStop.Set == true)
					//{
					//	m_cLogger->WriteLog("ManualOutputLoadingSeq: User stop sequence.\n");
					//	nSequenceNoOutput = nCase2.EndOfSequence;
					//	break;
					//}
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
					{
						smProductEvent->OutputTrayTableXAxisMotorMoveLoadDone.Set = false;
						smProductEvent->StartOutputTrayTableXAxisMotorMoveLoad.Set = true;
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
					{
						smProductEvent->OutputTrayTableYAxisMotorMoveLoadDone.Set = false;
						smProductEvent->StartOutputTrayTableYAxisMotorMoveLoad.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsMoveOutputTrayTableXYAxisToLoadingPositionDone;
					break;
				case nCase2.IsMoveOutputTrayTableXYAxisToLoadingPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveLoadDone.Set == true))
						&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveLoadDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis Motor move load position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToLoadingPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis move load position Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveLoadDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(45002);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Axis Motor Move Load timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveLoadDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(46002);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Y Axis Motor Move Load timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToLoadingPosition;
					}
					break;
				case nCase2.StopMoveOutputTrayTableXYAxisToLoadingPosition:
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
					{
						smProductEvent->OutputTrayTableXAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableXAxisMotorStop.Set = true;
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
					{
						smProductEvent->OutputTrayTableYAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableYAxisMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableXYAxisToLoadingPositionDone;
					break;
				case nCase2.IsStopMoveOutputTrayTableXYAxisToLoadingPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == true))
						&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToLoadingPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(45008);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(46008);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Y Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}

						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToLoadingPosition;
					}
					break;
				case nCase2.StartMoveOutputTrayTableZAxisToLoadingPosition:
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
					{
						smProductEvent->OutputTrayTableZAxisMotorMoveLoadDone.Set = false;
						smProductEvent->StartOutputTrayTableZAxisMotorMoveLoad.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToLoadingPositionDone;
					break;
				case nCase2.IsMoveOutputTrayTableZAxisToLoadingPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveLoadDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor move loading position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.OutputLoadingStackerUnlockCylinderUnlock;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveLoadDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(47002);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Move Loading timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToLoadingPosition;
					}
					break;
				case nCase2.StopMoveOutputTrayTableZAxisToLoadingPosition:

					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
					{
						smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
					}

					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToLoadingPositionDone;
					break;
				case nCase2.IsStopMoveOutputTrayTableZAxisToLoadingPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToLoadingPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{

						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(47008);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}

						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToLoadingPosition;
					}
					break;
				case nCase2.OutputLoadingStackerUnlockCylinderUnlock:
					m_cProductIOControl->SetOutputLoadingStackerUnlockCylinderOn(true);

					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsOutputLoadingStackerUnlockCylinderUnlock;
					break;

				case nCase2.IsOutputLoadingStackerUnlockCylinderUnlock:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& m_cProductIOControl->IsOutputLoadingStackerUnlockSensorOn() == true
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Loading Stacker Cylinder Unlock done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToSingulationPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (m_cProductIOControl->IsOutputLoadingStackerUnlockSensorOn() == false)
						{
							m_cProductShareVariables->SetAlarm(5412);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Loading Stacker Cylinder Unlock Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}

						nSequenceNoOutput = nCase2.OutputLoadingStackerUnlockCylinderUnlock;
					}
					break;
				case nCase2.StartMoveOutputTrayTableZAxisToSingulationPosition:
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
					{
						smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set = false;
						smProductEvent->StartOutputTrayTableZAxisMotorMoveSingulation.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToSingulationPositionDone;
					break;
				case nCase2.IsMoveOutputTrayTableZAxisToSingulationPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor move singulation position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.OutputLoadingStackerUnlockCylinderLock;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(47002);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Move Singulation timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToSingulationPosition;
					}
					break;
				case nCase2.StopMoveOutputTrayTableZAxisToSingulationPosition:
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
					{
						smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToSingulationPositionDone;
					break;
				case nCase2.IsStopMoveOutputTrayTableZAxisToSingulationPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToSingulationPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(47008);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToSingulationPosition;
					}
					break;
				case nCase2.OutputLoadingStackerUnlockCylinderLock:

					m_cProductIOControl->SetOutputLoadingStackerUnlockCylinderOn(false);

					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsOutputLoadingStackerUnlockCylinderLock;
					break;

				case nCase2.IsOutputLoadingStackerUnlockCylinderLock:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& m_cProductIOControl->IsOutputLoadingStackerLockSensorOn() == true
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Loading Stacker Cylinder lock done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToDownPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (m_cProductIOControl->IsOutputLoadingStackerLockSensorOn() == false)
						{
							m_cProductShareVariables->SetAlarm(5411);
							m_cLogger->WriteLog("ManualOutputLoadingSeq:  Output Loading Stacker Cylinder lock Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.OutputLoadingStackerUnlockCylinderLock;
					}
					break;
				case nCase2.StartMoveOutputTrayTableZAxisToDownPosition:
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
					{
						smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set = false;
						smProductEvent->StartOutputTrayTableZAxisMotorMoveDown.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToDownPositionDone;
					break;

				case nCase2.IsMoveOutputTrayTableZAxisToDownPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == false)
					{

						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
						{
							smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
							smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
						}
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionAfterTrayNotPresent;
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Tray Not Present %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						break;
					}
					if (true
						&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor move down position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.IsOutputTrayTableReady;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(47002);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Move down timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToDownPosition;
					}
					break;
				case nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionAfterTrayNotPresent:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.CheckIsTrayPresentOnOutputTrayTableDuringDown;
						RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1s);
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(47008);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
						{
							smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
							smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
						}
						nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionAfterTrayNotPresent;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					}
					break;
				case nCase2.CheckIsTrayPresentOnOutputTrayTableDuringDown:
					if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == false)
					{
						//if()if time >preset,then
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
						if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > (LONGLONG)smProductProduction->TrayPresentSensorOffTimeBeforeAlarm_ms)
						{
							m_cProductShareVariables->SetAlarm(5511);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Tray Not Present %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							//nSequenceNo = nCase.StopMoveInputTrayTableZAxisDownAtLoading;
							RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
							break;
						}
					}
					else if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == true)

					{
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToDownPosition;
					}
					break;
				case nCase2.StopMoveOutputTrayTableZAxisToDownPosition:
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
					{
						smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
					}

					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionDone;
					break;
				case nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToDownPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(47008);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToDownPosition;
					}
					break;

				case nCase2.StartMoveOutputTrayTableXYAxisToFirstPosition:
					//Need to set move position
					//smProductProduction->OutputTrayTableXAxisMovePosition = smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayTableCenterPosition - (signed long)(smProductSetting->DeviceXPitchOutput*4.5);
					//smProductProduction->OutputTrayTableYAxisMovePosition = smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayTableCenterPosition - (signed long)(smProductSetting->DeviceYPitchOutput*4.5);

					smProductProduction->OutputTrayTableXAxisMovePosition = smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayTableCenterPosition - signed long(smProductSetting->DeviceXPitchOutput * ((double)(smProductSetting->NoOfDeviceInRowOutput - 1) / 2));
					smProductProduction->OutputTrayTableYAxisMovePosition = smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayTableCenterPosition - signed long(smProductSetting->DeviceYPitchOutput * ((double)(smProductSetting->NoOfDeviceInColOutput - 1) / 2));
									

					smProductProduction->OutputTableResult[0].CurrentOutputTableNo = 0;
					smProductProduction->OutputTableResult[0].OutputTrayNo = smProductProduction->nCurrentOutputTrayNo;
					smProductProduction->OutputTableResult[0].OutputColumn = smProductProduction->nOutputEdgeCoordinateY;
					smProductProduction->OutputTableResult[0].OutputRow = smProductProduction->nOutputEdgeCoordinateX;
					//if (smProductSetting->EnableVision == true && smProductSetting->EnableOutputVision == true && smProductCustomize->EnableOutputVisionModule == true)
					//{

					//	smProductEvent->GMAIN_RTHD_OUT_VISION_GET_RC_DONE.Set = false;
					//	smProductEvent->RTHD_GMAIN_SEND_OUT_VISION_RC_START.Set = true;

					//}
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
					{
						smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set = false;
						smProductEvent->StartOutputTrayTableXAxisMotorMove.Set = true;
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
					{
						smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set = false;
						smProductEvent->StartOutputTrayTableYAxisMotorMove.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsMoveOutputTrayTableXYAxisToFirstPositionDone;
					break;
				case nCase2.IsMoveOutputTrayTableXYAxisToFirstPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set == true))
						&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set == true))
						//&& ((smProductEvent->GMAIN_RTHD_OUT_VISION_GET_RC_DONE.Set == true && smProductSetting->EnableVision == true && smProductSetting->EnableOutputVision == true && smProductCustomize->EnableOutputVisionModule == true)
						//	|| (smProductSetting->EnableVision == false || smProductSetting->EnableOutputVision == false || smProductCustomize->EnableOutputVisionModule == false))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y move to first position done and send output vision row and column done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						smProductProduction->nOutputEdgeCoordinateX = 1;
						smProductProduction->nOutputEdgeCoordinateY = 1;
						smProductProduction->OutputTrayTableXIndexPosition = smProductProduction->OutputTrayTableXAxisMovePosition;
						smProductProduction->OutputTrayTableYIndexPosition = smProductProduction->OutputTrayTableYAxisMovePosition;
						nSequenceNoOutput = nCase2.SetNextUnitOutput;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y move to first position and send output vision row and column Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//if (smProductEvent->GMAIN_RTHD_OUT_VISION_GET_RC_DONE.Set == false && smProductSetting->EnableVision == true && smProductSetting->EnableOutputVision == true && smProductCustomize->EnableOutputVisionModule == true)
						//{
						//	m_cProductShareVariables->SetAlarm(6807);
						//	m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Vision receive column and row timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//	nSequenceNoOutput = nCase2.StartSendOutputVisionOutputOrRejectRowAndColumn;
						//}
						if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(45002);
							m_cLogger->WriteLog("Output Tray Table X Axis Motor Move to first position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToFirstPosition;
						}
						if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(46002);
							m_cLogger->WriteLog("Output Tray Table Y Axis Motor Move to first position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToFirstPosition;
						}
					}
					break;
				case nCase2.StopMoveOutputTrayTableXYAxisToFirstPosition:
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
					{
						smProductEvent->OutputTrayTableXAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableXAxisMotorStop.Set = true;
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
					{
						smProductEvent->OutputTrayTableYAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableYAxisMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableXYAxisToFirstPositionDone;
					break;
				case nCase2.IsStopMoveOutputTrayTableXYAxisToFirstPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == true))
						&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToFirstPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(45008);
							m_cLogger->WriteLog("Output Tray Table X Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(46008);
							m_cLogger->WriteLog("Output Tray Table Y Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToFirstPosition;
					}
					break;
				case nCase2.SetNextUnitOutput:
				{
					//smProductProduction->OutputTrayTableXIndexPosition = smProductProduction->OutputTrayTableCurrentXPosition;
					//smProductProduction->OutputTrayTableYIndexPosition = smProductProduction->OutputTrayTableCurrentYPosition;
					if (smProductProduction->OutputTableResult[0].OutputRow % 2 != 0)
					{
						smProductProduction->nOutputEdgeCoordinateY++;
						smProductProduction->OutputTrayTableYIndexPosition += (signed long)(smProductSetting->DeviceYPitchOutput);
						if (smProductProduction->nOutputEdgeCoordinateY > smProductSetting->NoOfDeviceInColOutput)
						{
							smProductProduction->nOutputEdgeCoordinateY--;
							smProductProduction->nOutputEdgeCoordinateX++;
							if (smProductProduction->nOutputEdgeCoordinateX > smProductSetting->NoOfDeviceInRowOutput)
							{
								//smProductEvent->RMAIN_RTHD_OUTPUT_OR_REJECT_FULL.Set = true;
								//smProductEvent->RMAIN_RTHD_OUTPUT_FULL.Set = true;
								nSequenceNoOutput = nCase2.EndOfSequence;
								break;
							}
							smProductProduction->OutputTrayTableXIndexPosition += (signed long)(smProductSetting->DeviceXPitchOutput);
							smProductProduction->OutputTrayTableYIndexPosition -= (signed long)(smProductSetting->DeviceYPitchOutput);
						}
					}
					else if (smProductProduction->OutputTableResult[0].OutputRow % 2 == 0)
					{
						smProductProduction->nOutputEdgeCoordinateY--;
						smProductProduction->OutputTrayTableYIndexPosition -= (signed long)(smProductSetting->DeviceYPitchOutput);
						if (smProductProduction->nOutputEdgeCoordinateY < 1)
						{
							smProductProduction->nOutputEdgeCoordinateX++;
							smProductProduction->nOutputEdgeCoordinateY++;
							if (smProductProduction->nOutputEdgeCoordinateX > smProductSetting->NoOfDeviceInRowOutput)
							{
								//smProductEvent->RMAIN_RTHD_OUTPUT_OR_REJECT_FULL.Set = true;
								//smProductEvent->RMAIN_RTHD_OUTPUT_FULL.Set = true;
								nSequenceNoOutput = nCase2.EndOfSequence;
								break;
							}
							smProductProduction->OutputTrayTableYIndexPosition += (signed long)(smProductSetting->DeviceYPitchOutput);
							smProductProduction->OutputTrayTableXIndexPosition += (signed long)(smProductSetting->DeviceXPitchOutput);
						}
					}
				}
				smProductProduction->OutputTrayTableXAxisMovePosition = smProductProduction->OutputTrayTableXIndexPosition;
				smProductProduction->OutputTrayTableYAxisMovePosition = smProductProduction->OutputTrayTableYIndexPosition;
				nSequenceNoOutput = nCase2.StartSendOutputVisionOutputOrRejectRowAndColumn;
				break;
				case nCase2.StartSendOutputVisionOutputOrRejectRowAndColumn:
					if (smProductEvent->StopManualMode.Set == true)
					{
						m_cLogger->WriteLog("OutputTrayTableseq: User stop sequence.\n");

						nSequenceNoOutput = nCase2.EndOfSequence;
						break;
					}
					smProductProduction->OutputTableResult[0].OutputColumn = smProductProduction->nOutputEdgeCoordinateY;
					smProductProduction->OutputTableResult[0].OutputRow = smProductProduction->nOutputEdgeCoordinateX;
					smProductProduction->OutputTableResult[0].OutputTrayNo = smProductProduction->nCurrentOutputTrayNo;

					m_cLogger->WriteLog("OutputTrayTableSeq: Output Vision Start Send Row and Column before to set position.\n");
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToSetPosition;
					break;

				case nCase2.StartMoveOutputTrayTableXYAxisToSetPosition:
					if (smProductEvent->StopManualMode.Set == true)
					{
						m_cLogger->WriteLog("OutputTrayTableseq: User stop sequence.\n");

						nSequenceNoOutput = nCase2.EndOfSequence;
						break;
					}
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
					{
						smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set = false;
						smProductEvent->StartOutputTrayTableXAxisMotorMove.Set = true;
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
					{
						smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set = false;
						smProductEvent->StartOutputTrayTableYAxisMotorMove.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsMoveOutputTrayTableXYAxisToSetPositionDone;
					break;

				case nCase2.IsMoveOutputTrayTableXYAxisToSetPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set == true))
						&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set == true))
						)
					{
						m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table X Y move to set position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						{
							nSequenceNoOutput = nCase2.SetNextUnitOutput;
						}
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table X Y move to set position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(45002);
							m_cLogger->WriteLog("Output Tray Table X Axis Motor Move to set position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(46002);
							m_cLogger->WriteLog("Output Tray Table Y Axis Motor Move to set position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToSetPosition;
					}
					break;

				case nCase2.StopMoveOutputTrayTableXYAxisToSetPosition:
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
					{
						smProductEvent->OutputTrayTableXAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableXAxisMotorStop.Set = true;
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
					{
						smProductEvent->OutputTrayTableYAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableYAxisMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableXYAxisToSetPositionDone;
					break;

				case nCase2.IsStopMoveOutputTrayTableXYAxisToSetPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == true))
						&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table X Y Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToSetPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table X Y Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(45008);
							m_cLogger->WriteLog("Output Tray Table X Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(46008);
							m_cLogger->WriteLog("Output Tray Table Y Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToSetPosition;
					}
					break;

				default:
					return -1;
					break;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				if (smProductEvent->StopManualMode.Set == true)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Loading Unloading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				if (nSequenceNoOutput == nCase2.EndOfSequence)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Loading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			}
			break;
#pragma endregion

#pragma region 5010 Reject tray move to Next unit position
		case 5010:
			if (smProductCustomize->EnableInputTrayTableXAxisMotor)
			{
				smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartInputTrayTableXAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableInputTrayTableYAxisMotor)
			{
				smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartInputTrayTableYAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableInputTrayTableZAxisMotor)
			{
				smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartInputTrayTableZAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableOutputTrayTableXAxisMotor)
			{
				smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartOutputTrayTableXAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableOutputTrayTableYAxisMotor)
			{
				smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartOutputTrayTableYAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableOutputTrayTableZAxisMotor)
			{
				smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartOutputTrayTableZAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableInputVisionMotor)
			{
				smProductEvent->InputVisionModuleMotorSettingUpDone.Set = false;
				smProductEvent->StartInputVisionModuleMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableS2VisionMotor)
			{
				smProductEvent->S2VisionModuleMotorSettingUpDone.Set = false;
				smProductEvent->StartS2VisionModuleMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableS1VisionMotor)
			{
				smProductEvent->S1VisionModuleMotorSettingUpDone.Set = false;
				smProductEvent->StartS1VisionModuleMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnableS3VisionMotor)
			{
				smProductEvent->S3VisionModuleMotorSettingUpDone.Set = false;
				smProductEvent->StartS3VisionModuleMotorSettingUp.Set = true;
			}

			if (smProductCustomize->EnablePickAndPlace1XAxisMotor == true)
			{
				smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace1XAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnablePickAndPlace1YAxisMotor == true)
			{
				smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace1YAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnablePickAndPlace1Module == true)
			{
				smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace1ZAxisMotorSettingUp.Set = true;

				smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace1ThetaAxisMotorSettingUp.Set = true;
			}

			if (smProductCustomize->EnablePickAndPlace2XAxisMotor == true)
			{
				smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace2XAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnablePickAndPlace2YAxisMotor == true)
			{
				smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace2YAxisMotorSettingUp.Set = true;
			}
			if (smProductCustomize->EnablePickAndPlace2Module == true)
			{
				smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace2ZAxisMotorSettingUp.Set = true;

				smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set = false;
				smProductEvent->StartPickAndPlace2ThetaAxisMotorSettingUp.Set = true;

			}
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			while (smProductEvent->ExitRTX.Set == false)
			{
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

				if (true
					&& (smProductCustomize->EnableInputTrayTableXAxisMotor == false || (smProductCustomize->EnableInputTrayTableXAxisMotor == true && smProductEvent->InputTrayTableXAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableYAxisMotor == false || (smProductCustomize->EnableInputTrayTableYAxisMotor == true && smProductEvent->InputTrayTableYAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableInputTrayTableZAxisMotor == false || (smProductCustomize->EnableInputTrayTableZAxisMotor == true && smProductEvent->InputTrayTableZAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableInputVisionMotor == false || (smProductCustomize->EnableInputVisionMotor == true && smProductEvent->InputVisionModuleMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableS2VisionMotor == false || (smProductCustomize->EnableS2VisionMotor == true && smProductEvent->S2VisionModuleMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableS1VisionMotor == false || (smProductCustomize->EnableS1VisionMotor == true && smProductEvent->S1VisionModuleMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnableS3VisionMotor == false || (smProductCustomize->EnableS3VisionMotor == true && smProductEvent->S3VisionModuleMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace1XAxisMotor == false || (smProductCustomize->EnablePickAndPlace1XAxisMotor == true && smProductEvent->PickAndPlace1XAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace1YAxisMotor == false || (smProductCustomize->EnablePickAndPlace1YAxisMotor == true && smProductEvent->PickAndPlace1YAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ZAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace1Module == false || (smProductCustomize->EnablePickAndPlace1Module == true && smProductEvent->PickAndPlace1ThetaAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace2XAxisMotor == false || (smProductCustomize->EnablePickAndPlace2XAxisMotor == true && smProductEvent->PickAndPlace2XAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace2YAxisMotor == false || (smProductCustomize->EnablePickAndPlace2YAxisMotor == true && smProductEvent->PickAndPlace2YAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ZAxisMotorSettingUpDone.Set == true))
					&& (smProductCustomize->EnablePickAndPlace2Module == false || (smProductCustomize->EnablePickAndPlace2Module == true && smProductEvent->PickAndPlace2ThetaAxisMotorSettingUpDone.Set == true))
					)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("All Motor Setting up Done %ums\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			}
			smProductEvent->RSEQ_ROUT_SEQUENCE_START.Set = true;
			nSequenceNoOutput = nCase2.WaitingToReceiveEventStartOutputAndRejectTrayTableSequence;
			RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
			while (smProductEvent->ExitRTX.Set == false)
			{
				switch (nSequenceNoOutput)
				{
				case nCase2.WaitingToReceiveEventStartOutputAndRejectTrayTableSequence:
					if (smProductEvent->RSEQ_ROUT_SEQUENCE_START.Set == true)
					{
						smProductEvent->RSEQ_ROUT_SEQUENCE_START.Set = false;
						smProductEvent->ROUT_RINT_OUTPUT_PRE_PRODUCTION_DONE.Set = false;
						smProductProduction->nRejectEdgeCoordinateX = 1;
						smProductProduction->nRejectEdgeCoordinateY = 1;
						smProductProduction->nOutputEdgeCoordinateX = 1;
						smProductProduction->nOutputEdgeCoordinateY = 1;
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Come in.\n");
						nSequenceNoOutput = nCase2.IsOutputTrayTableZAxisAtDownPosition;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
					}
					break;
				case nCase2.IsOutputTrayTableZAxisAtDownPosition:
					//if (smProductEvent->JobStop.Set == true)
					//{
					//	m_cLogger->WriteLog("ManualOutputLoadingSeq: User stop sequence.\n");
					//	nSequenceNoOutput = nCase2.EndOfSequence;
					//	break;
					//}
					if (m_cProductMotorControl->IsOutputTrayTableXAxisMotorSafeToMove() == false || m_cProductMotorControl->IsOutputTrayTableYAxisMotorSafeToMove() == false)
					{
						m_cProductShareVariables->SetAlarm(47010);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Not At Down Position");
						nSequenceNoOutput = nCase2.EndOfSequence;
						break;
					}
					else
					{
						nSequenceNoOutput = nCase2.IsOutputTrayTableReady;
					}
					break;

				case nCase2.IsOutputTrayTableReady:
					//if (smProductEvent->JobStop.Set == true)
					//{
					//	m_cLogger->WriteLog("ManualOutputLoadingSeq: User stop sequence.\n");
					//	nSequenceNoOutput = nCase2.EndOfSequence;
					//	break;
					//}
					if (m_cProductIOControl->IsRejectTrayPresentSensorOn() == false)
					{
						m_cProductShareVariables->SetAlarm(5512);
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Tray not present on reject tray 1.\n");
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToLoadingPosition;
						break;
					}
					else if (m_cProductIOControl->IsRejectTrayPresentSensorOn() == true)
					{
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToFirstPosition;
					}
					break;
				case nCase2.StartMoveOutputTrayTableXYAxisToLoadingPosition:
					//if (smProductEvent->JobStop.Set == true)
					//{
					//	m_cLogger->WriteLog("ManualOutputLoadingSeq: User stop sequence.\n");
					//	nSequenceNoOutput = nCase2.EndOfSequence;
					//	break;
					//}
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
					{
						smProductEvent->OutputTrayTableXAxisMotorMoveManualLoadUnloadDone.Set = false;
						smProductEvent->StartOutputTrayTableXAxisMotorMoveManualLoadUnload.Set = true;
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
					{
						smProductEvent->OutputTrayTableYAxisMotorMoveManualLoadUnloadDone.Set = false;
						smProductEvent->StartOutputTrayTableYAxisMotorMoveManualLoadUnload.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsMoveOutputTrayTableXYAxisToLoadingPositionDone;
					break;
				case nCase2.IsMoveOutputTrayTableXYAxisToLoadingPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveManualLoadUnloadDone.Set == true))
						&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveManualLoadUnloadDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis Motor move load position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.EndOfSequence;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis move load position Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveLoadDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(45002);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Axis Motor Move Load timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveLoadDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(46002);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Y Axis Motor Move Load timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToLoadingPosition;
					}
					break;
				case nCase2.StopMoveOutputTrayTableXYAxisToLoadingPosition:
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
					{
						smProductEvent->OutputTrayTableXAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableXAxisMotorStop.Set = true;
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
					{
						smProductEvent->OutputTrayTableYAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableYAxisMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableXYAxisToLoadingPositionDone;
					break;
				case nCase2.IsStopMoveOutputTrayTableXYAxisToLoadingPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == true))
						&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToLoadingPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(45008);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(46008);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Y Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}

						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToLoadingPosition;
					}
					break;
				case nCase2.StartMoveOutputTrayTableZAxisToLoadingPosition:
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
					{
						smProductEvent->OutputTrayTableZAxisMotorMoveLoadDone.Set = false;
						smProductEvent->StartOutputTrayTableZAxisMotorMoveLoad.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToLoadingPositionDone;
					break;
				case nCase2.IsMoveOutputTrayTableZAxisToLoadingPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveLoadDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor move loading position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.OutputLoadingStackerUnlockCylinderUnlock;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveLoadDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(47002);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Move Loading timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToLoadingPosition;
					}
					break;
				case nCase2.StopMoveOutputTrayTableZAxisToLoadingPosition:

					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
					{
						smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
					}

					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToLoadingPositionDone;
					break;
				case nCase2.IsStopMoveOutputTrayTableZAxisToLoadingPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToLoadingPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{

						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(47008);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}

						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToLoadingPosition;
					}
					break;
				case nCase2.OutputLoadingStackerUnlockCylinderUnlock:
					m_cProductIOControl->SetOutputLoadingStackerUnlockCylinderOn(true);

					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsOutputLoadingStackerUnlockCylinderUnlock;
					break;

				case nCase2.IsOutputLoadingStackerUnlockCylinderUnlock:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& m_cProductIOControl->IsOutputLoadingStackerUnlockSensorOn() == true
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Loading Stacker Cylinder Unlock done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToSingulationPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (m_cProductIOControl->IsOutputLoadingStackerUnlockSensorOn() == false)
						{
							m_cProductShareVariables->SetAlarm(5412);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Loading Stacker Cylinder Unlock Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}

						nSequenceNoOutput = nCase2.OutputLoadingStackerUnlockCylinderUnlock;
					}
					break;
				case nCase2.StartMoveOutputTrayTableZAxisToSingulationPosition:
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
					{
						smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set = false;
						smProductEvent->StartOutputTrayTableZAxisMotorMoveSingulation.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToSingulationPositionDone;
					break;
				case nCase2.IsMoveOutputTrayTableZAxisToSingulationPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor move singulation position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.OutputLoadingStackerUnlockCylinderLock;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveSingulationDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(47002);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Move Singulation timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToSingulationPosition;
					}
					break;
				case nCase2.StopMoveOutputTrayTableZAxisToSingulationPosition:
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
					{
						smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToSingulationPositionDone;
					break;
				case nCase2.IsStopMoveOutputTrayTableZAxisToSingulationPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToSingulationPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(47008);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToSingulationPosition;
					}
					break;
				case nCase2.OutputLoadingStackerUnlockCylinderLock:

					m_cProductIOControl->SetOutputLoadingStackerUnlockCylinderOn(false);

					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsOutputLoadingStackerUnlockCylinderLock;
					break;

				case nCase2.IsOutputLoadingStackerUnlockCylinderLock:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& m_cProductIOControl->IsOutputLoadingStackerLockSensorOn() == true
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Loading Stacker Cylinder lock done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToDownPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (m_cProductIOControl->IsOutputLoadingStackerLockSensorOn() == false)
						{
							m_cProductShareVariables->SetAlarm(5411);
							m_cLogger->WriteLog("ManualOutputLoadingSeq:  Output Loading Stacker Cylinder lock Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.OutputLoadingStackerUnlockCylinderLock;
					}
					break;
				case nCase2.StartMoveOutputTrayTableZAxisToDownPosition:
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
					{
						smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set = false;
						smProductEvent->StartOutputTrayTableZAxisMotorMoveDown.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsMoveOutputTrayTableZAxisToDownPositionDone;
					break;

				case nCase2.IsMoveOutputTrayTableZAxisToDownPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == false)
					{

						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
						{
							smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
							smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
						}
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionAfterTrayNotPresent;
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Tray Not Present %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						break;
					}
					if (true
						&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor move down position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.IsOutputTrayTableReady;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorMoveDownDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(47002);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Move down timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToDownPosition;
					}
					break;
				case nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionAfterTrayNotPresent:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.CheckIsTrayPresentOnOutputTrayTableDuringDown;
						RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1s);
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis stop Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(47008);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
						{
							smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
							smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
						}
						nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionAfterTrayNotPresent;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					}
					break;
				case nCase2.CheckIsTrayPresentOnOutputTrayTableDuringDown:
					if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == false)
					{
						//if()if time >preset,then
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
						if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > (LONGLONG)smProductProduction->TrayPresentSensorOffTimeBeforeAlarm_ms)
						{
							m_cProductShareVariables->SetAlarm(5511);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Tray Not Present %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							//nSequenceNo = nCase.StopMoveInputTrayTableZAxisDownAtLoading;
							RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
							break;
						}
					}
					else if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == true)

					{
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToDownPosition;
					}
					break;
				case nCase2.StopMoveOutputTrayTableZAxisToDownPosition:
					if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true)
					{
						smProductEvent->OutputTrayTableZAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableZAxisMotorStop.Set = true;
					}

					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionDone;
					break;
				case nCase2.IsStopMoveOutputTrayTableZAxisToDownPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableZAxisMotor == false || (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor stop done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableZAxisToDownPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						if (smProductCustomize->EnableOutputTrayTableZAxisMotor == true && smProductEvent->OutputTrayTableZAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(47008);
							m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table Z Axis Motor Stop timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableZAxisToDownPosition;
					}
					break;

				case nCase2.StartMoveOutputTrayTableXYAxisToFirstPosition:
					//Need to set move position
					//smProductProduction->OutputTrayTableXAxisMovePosition = smProductTeachPoint->OutputTrayTableXAxisAtRejectTrayCenterPosition - (signed long)(smProductSetting->DeviceXPitchOutput*4.5);
					//smProductProduction->OutputTrayTableYAxisMovePosition = smProductTeachPoint->OutputTrayTableYAxisAtRejectTrayCenterPosition - (signed long)(smProductSetting->DeviceYPitchOutput*4.5);
									

					smProductProduction->OutputTrayTableXAxisMovePosition = smProductTeachPoint->OutputTrayTableXAxisAtRejectTrayCenterPosition - signed long(smProductSetting->DeviceXPitchOutput * ((double)(smProductSetting->NoOfDeviceInColOutput - 1) / 2));
					smProductProduction->OutputTrayTableYAxisMovePosition = smProductTeachPoint->OutputTrayTableYAxisAtRejectTrayCenterPosition - signed long(smProductSetting->DeviceYPitchOutput * ((double)(smProductSetting->NoOfDeviceInRowOutput - 1) / 2));

					smProductProduction->OutputTableResult[0].CurrentOutputTableNo = 0;
					smProductProduction->OutputTableResult[0].OutputTrayNo = smProductProduction->nCurrentOutputTrayNo;
					smProductProduction->OutputTableResult[0].OutputColumn = smProductProduction->nOutputEdgeCoordinateY;
					smProductProduction->OutputTableResult[0].OutputRow = smProductProduction->nOutputEdgeCoordinateX;
					//if (smProductSetting->EnableVision == true && smProductSetting->EnableOutputVision == true && smProductCustomize->EnableOutputVisionModule == true)
					//{

					//	smProductEvent->GMAIN_RTHD_OUT_VISION_GET_RC_DONE.Set = false;
					//	smProductEvent->RTHD_GMAIN_SEND_OUT_VISION_RC_START.Set = true;

					//}
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
					{
						smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set = false;
						smProductEvent->StartOutputTrayTableXAxisMotorMove.Set = true;
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
					{
						smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set = false;
						smProductEvent->StartOutputTrayTableYAxisMotorMove.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsMoveOutputTrayTableXYAxisToFirstPositionDone;
					break;
				case nCase2.IsMoveOutputTrayTableXYAxisToFirstPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set == true))
						&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set == true))
						//&& ((smProductEvent->GMAIN_RTHD_OUT_VISION_GET_RC_DONE.Set == true && smProductSetting->EnableVision == true && smProductSetting->EnableOutputVision == true && smProductCustomize->EnableOutputVisionModule == true)
						//	|| (smProductSetting->EnableVision == false || smProductSetting->EnableOutputVision == false || smProductCustomize->EnableOutputVisionModule == false))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y move to first position done and send output vision row and column done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);

						smProductProduction->RejectTrayTableXIndexPosition = smProductProduction->OutputTrayTableXAxisMovePosition;
						smProductProduction->RejectTrayTableYIndexPosition = smProductProduction->OutputTrayTableYAxisMovePosition;
						smProductProduction->nRejectEdgeCoordinateX = 1;
						smProductProduction->nRejectEdgeCoordinateY = 1;
						nSequenceNoOutput = nCase2.SetNextUnitOutput;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y move to first position and send output vision row and column Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//if (smProductEvent->GMAIN_RTHD_OUT_VISION_GET_RC_DONE.Set == false && smProductSetting->EnableVision == true && smProductSetting->EnableOutputVision == true && smProductCustomize->EnableOutputVisionModule == true)
						//{
						//	m_cProductShareVariables->SetAlarm(6807);
						//	m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Vision receive column and row timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//	nSequenceNoOutput = nCase2.StartSendOutputVisionOutputOrRejectRowAndColumn;
						//}
						if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(45002);
							m_cLogger->WriteLog("Output Tray Table X Axis Motor Move to first position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToFirstPosition;
						}
						if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(46002);
							m_cLogger->WriteLog("Output Tray Table Y Axis Motor Move to first position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToFirstPosition;
						}
					}
					break;
				case nCase2.StopMoveOutputTrayTableXYAxisToFirstPosition:
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
					{
						smProductEvent->OutputTrayTableXAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableXAxisMotorStop.Set = true;
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
					{
						smProductEvent->OutputTrayTableYAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableYAxisMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableXYAxisToFirstPositionDone;
					break;
				case nCase2.IsStopMoveOutputTrayTableXYAxisToFirstPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == true))
						&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);

						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToFirstPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("ManualOutputLoadingSeq: Output Tray Table X Y Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(45008);
							m_cLogger->WriteLog("Output Tray Table X Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(46008);
							m_cLogger->WriteLog("Output Tray Table Y Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToFirstPosition;
					}
					break;
				case nCase2.SetNextUnitOutput:
				{
					if (smProductProduction->OutputTableResult[0].RejectRow % 2 != 0)
					{
						smProductProduction->nRejectEdgeCoordinateY++;
						smProductProduction->RejectTrayTableYIndexPosition += (signed long)(smProductSetting->DeviceYPitchOutput);
						if (smProductProduction->nRejectEdgeCoordinateY > smProductSetting->NoOfDeviceInColOutput)
						{
							smProductProduction->nRejectEdgeCoordinateY--;
							smProductProduction->nRejectEdgeCoordinateX++;
							if (smProductProduction->nRejectEdgeCoordinateX > smProductSetting->NoOfDeviceInRowOutput)
							{
								//smProductEvent->RMAIN_RTHD_OUTPUT_OR_REJECT_FULL.Set = true;
								//smProductEvent->RMAIN_RTHD_OUTPUT_FULL.Set = true;
								//nSequenceNoOutput = nCase2.StartMoveRejectTrayTableXYAxisToManualLoadUnloadPosition;
								nSequenceNoOutput = nCase2.EndOfSequence;
								break;
							}
							smProductProduction->RejectTrayTableXIndexPosition += (signed long)(smProductSetting->DeviceXPitchOutput);
							smProductProduction->RejectTrayTableYIndexPosition -= (signed long)(smProductSetting->DeviceYPitchOutput);
						}
					}
					else if (smProductProduction->OutputTableResult[0].RejectRow % 2 == 0)
					{
						smProductProduction->nRejectEdgeCoordinateY--;
						smProductProduction->RejectTrayTableYIndexPosition -= (signed long)(smProductSetting->DeviceYPitchOutput);
						if (smProductProduction->nRejectEdgeCoordinateY < 1)
						{
							smProductProduction->nRejectEdgeCoordinateX++;
							smProductProduction->nRejectEdgeCoordinateY++;
							if (smProductProduction->nRejectEdgeCoordinateX > smProductSetting->NoOfDeviceInRowOutput)
							{
								//smProductEvent->RMAIN_RTHD_OUTPUT_OR_REJECT_FULL.Set = true;
								//smProductEvent->RMAIN_RTHD_OUTPUT_FULL.Set = true;
								//nSequenceNoOutput = nCase2.StartMoveRejectTrayTableXYAxisToManualLoadUnloadPosition;
								nSequenceNoOutput = nCase2.EndOfSequence;
								break;
							}
							smProductProduction->RejectTrayTableYIndexPosition += (signed long)(smProductSetting->DeviceYPitchOutput);
							smProductProduction->RejectTrayTableXIndexPosition += (signed long)(smProductSetting->DeviceXPitchOutput);
						}
					}
				}
				smProductProduction->OutputTrayTableXAxisMovePosition = smProductProduction->RejectTrayTableXIndexPosition;
				smProductProduction->OutputTrayTableYAxisMovePosition = smProductProduction->RejectTrayTableYIndexPosition;
				nSequenceNoOutput = nCase2.StartSendOutputVisionOutputOrRejectRowAndColumn;
				break;
				case nCase2.StartSendOutputVisionOutputOrRejectRowAndColumn:
					if (smProductEvent->StopManualMode.Set == true)
					{
						m_cLogger->WriteLog("OutputTrayTableseq: User stop sequence.\n");
						//if (m_cProductIOControl->IsOutputTrayTableTrayPresentSensorOn() == false)
						//{
						//	if ((m_cProductIOControl->IsRejectTrayPresentSensorOn() == true && smProductProduction->nCurrentRejectUnitOnTray > 0))
						//		nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToUnloadingPositionDuringPostProduction;
						//	else
						//		nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToManualLoadUnloadPositionPostProduction;
						//}
						//else
						//{
						//	nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToUnloadingPosition;
						//}
						nSequenceNoOutput = nCase2.EndOfSequence;
						break;
					}
					smProductProduction->OutputTableResult[0].RejectColumn = smProductProduction->nRejectEdgeCoordinateY;
					smProductProduction->OutputTableResult[0].RejectRow = smProductProduction->nRejectEdgeCoordinateX;
					smProductProduction->OutputTableResult[0].RejectTrayNo = smProductProduction->nCurrentRejectTrayNo;

					m_cLogger->WriteLog("OutputTrayTableSeq: Output Vision Start Send Row and Column before to set position.\n");
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToSetPosition;
					break;

				case nCase2.StartMoveOutputTrayTableXYAxisToSetPosition:
					if (smProductEvent->StopManualMode.Set == true)
					{
						m_cLogger->WriteLog("OutputTrayTableseq: User stop sequence.\n");
						nSequenceNoOutput = nCase2.EndOfSequence;
						break;
					}
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
					{
						smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set = false;
						smProductEvent->StartOutputTrayTableXAxisMotorMove.Set = true;
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
					{
						smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set = false;
						smProductEvent->StartOutputTrayTableYAxisMotorMove.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsMoveOutputTrayTableXYAxisToSetPositionDone;
					break;

				case nCase2.IsMoveOutputTrayTableXYAxisToSetPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set == true))
						&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set == true))
						)
					{
						m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table X Y move to set position done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						{
							nSequenceNoOutput = nCase2.SetNextUnitOutput;
						}
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table X Y move to set position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorMoveDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(45002);
							m_cLogger->WriteLog("Output Tray Table X Axis Motor Move to set position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorMoveDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(46002);
							m_cLogger->WriteLog("Output Tray Table Y Axis Motor Move to set position Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToSetPosition;
					}
					break;

				case nCase2.StopMoveOutputTrayTableXYAxisToSetPosition:
					if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true)
					{
						smProductEvent->OutputTrayTableXAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableXAxisMotorStop.Set = true;
					}
					if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true)
					{
						smProductEvent->OutputTrayTableYAxisMotorStopDone.Set = false;
						smProductEvent->StartOutputTrayTableYAxisMotorStop.Set = true;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
					nSequenceNoOutput = nCase2.IsStopMoveOutputTrayTableXYAxisToSetPositionDone;
					break;

				case nCase2.IsStopMoveOutputTrayTableXYAxisToSetPositionDone:
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
					if (true
						&& (smProductCustomize->EnableOutputTrayTableXAxisMotor == false || (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == true))
						&& (smProductCustomize->EnableOutputTrayTableYAxisMotor == false || (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == true))
						)
					{
						m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table X Y Axis stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						nSequenceNoOutput = nCase2.StartMoveOutputTrayTableXYAxisToSetPosition;
					}
					else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
					{
						m_cLogger->WriteLog("OutputTrayTableSeq: Output Tray Table X Y Axis stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						if (smProductCustomize->EnableOutputTrayTableXAxisMotor == true && smProductEvent->OutputTrayTableXAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(45008);
							m_cLogger->WriteLog("Output Tray Table X Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						if (smProductCustomize->EnableOutputTrayTableYAxisMotor == true && smProductEvent->OutputTrayTableYAxisMotorStopDone.Set == false)
						{
							m_cProductShareVariables->SetAlarm(46008);
							m_cLogger->WriteLog("Output Tray Table Y Axis Motor Stop Timeout %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						}
						nSequenceNoOutput = nCase2.StopMoveOutputTrayTableXYAxisToSetPosition;
					}
					break;

				default:
					return -1;
					break;
				}
				RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				if (smProductEvent->StopManualMode.Set == true)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Loading Unloading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				if (nSequenceNoOutput == nCase2.EndOfSequence)
				{
					m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Loading Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
					break;
				}
				RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
			}
			break;
#pragma endregion

#pragma region 5011 PNP1 Calibration
			case 5011:
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				smProductEvent->GMNL_RMNL_MANUAL_MODE.Set = true;
				smProductProduction->PickUpHeadNoForCalibration = 1;
				smProductProduction->nCurrentPickupHeadAtS1 = 0;
				smProductEvent->START_PNP_Calibration.Set = true;
				nCase1 = 0;
				while (smProductEvent->ExitRTX.Set == false)
				{
					switch (nCase1)
					{
					case 0:
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
						if (smProductEvent->GMAIN_RMAIN_LOADING_CALIBRATION_RECIPE_DONE.Set == true)
						{
							m_cLogger->WriteLog("PNP1 Calibration: Send RECIPE Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 1;
							RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						}
						//else if(lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
						//{
						//	m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP1 Calibration: RECIPE Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//	nCase1 = 999;
						//}
						break;

					case 1:
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
						if (smProductEvent->GMAIN_RTHD_BOTTOM_SEND_NEWLOT_DONE.Set == true)
						{
							m_cLogger->WriteLog("PNP1 Calibration: Send NEWLOT Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							smProductProduction->nCurrentInputTrayNo = 1;
							smProductEvent->GMAIN_RTHD_BTM_SEND_TRAYNO_DONE.Set = false;
							smProductEvent->RTHD_GMAIN_BTM_SEND_TRAYNO.Set = true;
							nCase1 = 2;
							RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						}
						//else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
						//{
						//	m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP1 Calibration: NEWLOT Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//	nCase1 = 999;
						//}
						break;

					case 2:
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
						if (smProductEvent->GMAIN_RTHD_BTM_SEND_TRAYNO_DONE.Set == true)
						{
							m_cLogger->WriteLog("PNP1 Calibration: Send TRAYNO Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 3;
							RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						}
						else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
						{
							m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP1 Calibration: TRAYNO Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 1;
						}
						break;

					case 3:
						smProductProduction->PickAndPlacePickUpHeadStationResult[0].InputRow = 0;
						smProductProduction->PickAndPlacePickUpHeadStationResult[0].InputColumn = 0;
						smProductProduction->PickAndPlacePickUpHeadStationResult[0].InputTrayNo = 1;
						smProductEvent->GMAIN_RTHD_BOTTOM_VISION_GET_RC_DONE.Set = false;
						smProductEvent->RTHD_GMAIN_SEND_BOTTOM_VISION_RC_START.Set = true;
						nCase1 = 5;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						m_cLogger->WriteLog("PNP1 Calibration: Start Send RC.\n");
						break;

					case 4:
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
						if (smProductEvent->GMAIN_RTHD_BOTTOM_VISION_GET_RC_DONE.Set == true)
						{
							m_cLogger->WriteLog("PNP1 Calibration: Send RC Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 5;
						}
						else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
						{
							m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP1 Calibration: RC Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 3;
						}
						break;

					case 5:
						for (int i = nCurrentDegree; i <= 360; i++)
						{
							//nCurrentDegree = i;
							smProductProduction->PickAndPlacePickUpHeadStationResult[0].InputColumn = nCurrentDegree;
							bIsNeedConitinue = true;
							break;
						}
						if (bIsNeedConitinue == true)
						{
							bIsNeedConitinue = false;
							nCase1 = 8;
						}
						else
						{
							smProductEvent->PNP_CALIBRATION_WRITE_REPORT.Set = true;
							nCase1 = 999;
						}
						break;

					case 6:
						smProductEvent->GMAIN_RBTMV_GET_VISION_RESULT_DONE.Set = false;
						smProductEvent->RSEQ_RBTMV_START_VISION.Set = true;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						nCase1 = 7;
						break;

					case 7:
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
						if (smProductEvent->GMAIN_RBTMV_GET_VISION_RESULT_DONE.Set == true)
						{
							m_cLogger->WriteLog("PNP1 Calibration: BTM vision Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 5;
						}
						//else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
						//{
						//	m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP1 Calibration: BTM vision Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//	nCase1 = 6;
						//}
						break;

					case 8:
						smProductProduction->PickAndPlace1ThetaAxisMovePosition = smProductTeachPoint->PickAndPlace1ThetaAxisStandbyPosition + ((signed long)nCurrentDegree * 1000);
						smProductEvent->PickAndPlace1ThetaAxisMotorMoveDone.Set = false;
						smProductEvent->StartPickAndPlace1ThetaAxisMotorMove.Set = true;
						nCase1 = 9;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						break;

					case 9:
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
						if (smProductEvent->PickAndPlace1ThetaAxisMotorMoveDone.Set == true)
						{
							m_cLogger->WriteLog("PNP1 Calibration: THETA move Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 10;
							nCurrentDegree++;
						}
						else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
						{
							m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP1 Calibration: THETA move Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 8;
						}
						break;

					case 10:
						smProductEvent->GMAIN_RTHD_BOTTOM_VISION_GET_RC_DONE.Set = false;
						smProductEvent->RTHD_GMAIN_SEND_BOTTOM_VISION_RC_START.Set = true;
						nCase1 = 11;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						break;

					case 11:
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
						if (smProductEvent->GMAIN_RTHD_BOTTOM_VISION_GET_RC_DONE.Set == true)
						{
							m_cLogger->WriteLog("PNP1 Calibration: Send RC Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 6;
						}
						else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
						{
							m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP1 Calibration: RC Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 10;
						}
						break;

					default:
						nCase1 = 999;
						break;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					if (smProductEvent->StopManualMode.Set == true)
					{
						m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP1 Calibration Stop %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						break;
					}
					if (nCase1 == 999)
					{
						m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP1 Calibration Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						break;
					}
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
				}
				break;
#pragma endregion

#pragma region 5012 PNP2 Calibration
			case 5012:
				RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
				smProductEvent->GMNL_RMNL_MANUAL_MODE.Set = true;
				smProductProduction->PickUpHeadNoForCalibration = 2;
				smProductProduction->nCurrentPickupHeadAtS1 = 1;
				smProductEvent->START_PNP_Calibration.Set = true;
				nCase1 = 0;
				while (smProductEvent->ExitRTX.Set == false)
				{
					switch (nCase1)
					{
					case 0:
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
						if (smProductEvent->GMAIN_RMAIN_LOADING_CALIBRATION_RECIPE_DONE.Set == true)
						{
							m_cLogger->WriteLog("PNP2 Calibration: Send RECIPE Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 1;
							RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						}
						//else if(lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
						//{
						//	m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP2 Calibration: RECIPE Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//	nCase1 = 999;
						//}
						break;

					case 1:
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
						if (smProductEvent->GMAIN_RTHD_BOTTOM_SEND_NEWLOT_DONE.Set == true)
						{
							m_cLogger->WriteLog("PNP2 Calibration: Send NEWLOT Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							smProductProduction->nCurrentInputTrayNo = 1;
							smProductEvent->GMAIN_RTHD_BTM_SEND_TRAYNO_DONE.Set = false;
							smProductEvent->RTHD_GMAIN_BTM_SEND_TRAYNO.Set = true;
							nCase1 = 2;
							RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						}
						//else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
						//{
						//	m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP2 Calibration: NEWLOT Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//	nCase1 = 999;
						//}
						break;

					case 2:
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
						if (smProductEvent->GMAIN_RTHD_BTM_SEND_TRAYNO_DONE.Set == true)
						{
							m_cLogger->WriteLog("PNP2 Calibration: Send TRAYNO Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 3;
							RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						}
						else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
						{
							m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP2 Calibration: TRAYNO Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 1;
						}
						break;

					case 3:
						smProductProduction->PickAndPlacePickUpHeadStationResult[1].InputRow = 0;
						smProductProduction->PickAndPlacePickUpHeadStationResult[1].InputColumn = 0;
						smProductProduction->PickAndPlacePickUpHeadStationResult[1].InputTrayNo = 1;
						smProductEvent->GMAIN_RTHD_BOTTOM_VISION_GET_RC_DONE.Set = false;
						smProductEvent->RTHD_GMAIN_SEND_BOTTOM_VISION_RC_START.Set = true;
						nCase1 = 5;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						m_cLogger->WriteLog("PNP2 Calibration: Start Send RC.\n");
						break;

					case 4:
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
						if (smProductEvent->GMAIN_RTHD_BOTTOM_VISION_GET_RC_DONE.Set == true)
						{
							m_cLogger->WriteLog("PNP2 Calibration: Send RC Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 5;
						}
						else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
						{
							m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP2 Calibration: RC Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 3;
						}
						break;

					case 5:
						for (int i = nCurrentDegree; i <= 360; i++)
						{
							//nCurrentDegree = i;
							smProductProduction->PickAndPlacePickUpHeadStationResult[1].InputColumn = nCurrentDegree;
							bIsNeedConitinue = true;
							break;
						}
						if (bIsNeedConitinue == true)
						{
							bIsNeedConitinue = false;
							nCase1 = 8;
						}
						else
						{
							smProductEvent->PNP_CALIBRATION_WRITE_REPORT.Set = true;
							nCase1 = 999;
						}
						break;

					case 6:
						smProductEvent->GMAIN_RBTMV_GET_VISION_RESULT_DONE.Set = false;
						smProductEvent->RSEQ_RBTMV_START_VISION.Set = true;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						nCase1 = 7;
						break;

					case 7:
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
						if (smProductEvent->GMAIN_RBTMV_GET_VISION_RESULT_DONE.Set == true)
						{
							m_cLogger->WriteLog("PNP2 Calibration: BTM vision Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 5;
						}
						//else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
						//{
						//	m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP2 Calibration: BTM vision Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						//	nCase1 = 6;
						//}
						break;

					case 8:
						smProductProduction->PickAndPlace2ThetaAxisMovePosition = smProductTeachPoint->PickAndPlace2ThetaAxisStandbyPosition + ((signed long)nCurrentDegree * 1000);
						smProductEvent->PickAndPlace2ThetaAxisMotorMoveDone.Set = false;
						smProductEvent->StartPickAndPlace2ThetaAxisMotorMove.Set = true;
						nCase1 = 9;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						break;

					case 9:
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
						if (smProductEvent->PickAndPlace2ThetaAxisMotorMoveDone.Set == true)
						{
							m_cLogger->WriteLog("PNP2 Calibration: THETA move Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 10;
							nCurrentDegree++;
						}
						else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
						{
							m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP2 Calibration: THETA move Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 8;
						}
						break;

					case 10:
						smProductEvent->GMAIN_RTHD_BOTTOM_VISION_GET_RC_DONE.Set = false;
						smProductEvent->RTHD_GMAIN_SEND_BOTTOM_VISION_RC_START.Set = true;
						nCase1 = 11;
						RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
						break;

					case 11:
						RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
						lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
						if (smProductEvent->GMAIN_RTHD_BOTTOM_VISION_GET_RC_DONE.Set == true)
						{
							m_cLogger->WriteLog("PNP2 Calibration: Send RC Done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 6;
						}
						else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->VISION_TIMEOUT)
						{
							m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP2 Calibration: RC Timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
							nCase1 = 10;
						}
						break;

					default:
						nCase1 = 999;
						break;
					}
					RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
					lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
					if (smProductEvent->StopManualMode.Set == true)
					{
						m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP2 Calibration Stop %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						break;
					}
					if (nCase1 == 999)
					{
						m_cProductShareVariables->UpdateMessageToGUIAndLog("PNP2 Calibration Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
						break;
					}
					RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
				}
				break;
#pragma endregion

#pragma endregion
	default:
		break;
	}

	return nError;
}