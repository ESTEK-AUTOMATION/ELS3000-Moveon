#include "CProductMotorControl.h"
CRITICAL_SECTION csSendCommand;
CRITICAL_SECTION csAgitoSendCommand;
CRITICAL_SECTION csAgitoGetParamSendReceive;
CRITICAL_SECTION csAgitoGetParam;
CRITICAL_SECTION csKingStarSendCommand;
CRITICAL_SECTION csKingStarSendReadCommand;

CProductMotorControl::CProductMotorControl()
{
	InitializeCriticalSection(&csSendCommand);
	InitializeCriticalSection(&csAgitoSendCommand);
	InitializeCriticalSection(&csAgitoGetParamSendReceive);
	InitializeCriticalSection(&csAgitoGetParam);
	InitializeCriticalSection(&csKingStarSendCommand);
	InitializeCriticalSection(&csKingStarSendReadCommand);
}

CProductMotorControl::~CProductMotorControl()
{
	DeleteCriticalSection(&csSendCommand);
	DeleteCriticalSection(&csAgitoSendCommand);
	DeleteCriticalSection(&csAgitoGetParamSendReceive);
	DeleteCriticalSection(&csAgitoGetParam);
	DeleteCriticalSection(&csKingStarSendCommand);
	DeleteCriticalSection(&csKingStarSendReadCommand);
}

int RTFCNDCL CProductMotorControl::SetProductMotorControl(CProductMotorControl *productMotorControl)
{
	m_cProductMotorControl = productMotorControl;
	m_cProductMotorControl->SetPlatformMotorControl(productMotorControl);
	return 0;
}

int CProductMotorControl::SetClass(CMotionLibrary *motionLibrary)
{
	m_cMotion = motionLibrary;
	return 0;
}

int CProductMotorControl::LoadMotorSetting()
{
	strncpy_s(m_motorConfiguration[0].Controller, "Galil", sizeof(m_motorConfiguration[0].Controller));
	strncpy_s(m_motorConfiguration[0].ControllerDetails, "GalilController1;192.168.1.3;A", sizeof(m_motorConfiguration[0].ControllerDetails));
	m_motorConfiguration[0].Enable = true;
	m_motorConfiguration[0].Online = true;
	strncpy_s(m_motorConfiguration[0].Axis, "Pick And Place 1 Y Axis", sizeof(m_motorConfiguration[0].Axis));
	m_motorConfiguration[0].UnitInOnePulse = 1;//micron or degree
	strncpy_s(m_motorConfiguration[0].UnitName, "um", sizeof(m_motorConfiguration[0].UnitName));
	m_motorConfiguration[0].AxisInPositionToleranceInUnitPulse = 10;

	strncpy_s(m_motorConfiguration[1].Controller, "Galil", sizeof(m_motorConfiguration[1].Controller));
	strncpy_s(m_motorConfiguration[1].ControllerDetails, "GalilController1;192.168.1.3;B", sizeof(m_motorConfiguration[1].ControllerDetails));
	m_motorConfiguration[1].Enable = true;
	m_motorConfiguration[1].Online = true;
	strncpy_s(m_motorConfiguration[1].Axis, "Input Tray Table X Axis", sizeof(m_motorConfiguration[1].Axis));
	m_motorConfiguration[1].UnitInOnePulse = 1;//micron or degree
	strncpy_s(m_motorConfiguration[1].UnitName, "um", sizeof(m_motorConfiguration[1].UnitName));
	m_motorConfiguration[1].AxisInPositionToleranceInUnitPulse = 10;

	strncpy_s(m_motorConfiguration[2].Controller, "Galil", sizeof(m_motorConfiguration[2].Controller));
	strncpy_s(m_motorConfiguration[2].ControllerDetails, "GalilController1;192.168.1.3;C", sizeof(m_motorConfiguration[2].ControllerDetails));
	m_motorConfiguration[2].Enable = true;
	m_motorConfiguration[2].Online = true;
	strncpy_s(m_motorConfiguration[2].Axis, "Input Tray Table Y Axis", sizeof(m_motorConfiguration[2].Axis));
	m_motorConfiguration[2].UnitInOnePulse = 1;//micron or degree
	strncpy_s(m_motorConfiguration[2].UnitName, "um", sizeof(m_motorConfiguration[2].UnitName));
	m_motorConfiguration[2].AxisInPositionToleranceInUnitPulse = 10;

	strncpy_s(m_motorConfiguration[3].Controller, "Galil", sizeof(m_motorConfiguration[3].Controller));
	strncpy_s(m_motorConfiguration[3].ControllerDetails, "GalilController1;192.168.1.3;D", sizeof(m_motorConfiguration[3].ControllerDetails));
	m_motorConfiguration[3].Enable = true;
	m_motorConfiguration[3].Online = true;
	strncpy_s(m_motorConfiguration[3].Axis, "Input Tray Table Z Axis", sizeof(m_motorConfiguration[3].Axis));
	m_motorConfiguration[3].UnitInOnePulse = 0.5;//micron or degree
	strncpy_s(m_motorConfiguration[3].UnitName, "um", sizeof(m_motorConfiguration[3].UnitName));
	m_motorConfiguration[3].AxisInPositionToleranceInUnitPulse = 10;

	strncpy_s(m_motorConfiguration[4].Controller, "Galil", sizeof(m_motorConfiguration[4].Controller));
	strncpy_s(m_motorConfiguration[4].ControllerDetails, "GalilController2;192.168.1.4;A", sizeof(m_motorConfiguration[4].ControllerDetails));
	m_motorConfiguration[4].Enable = true;
	m_motorConfiguration[4].Online = true;
	strncpy_s(m_motorConfiguration[4].Axis, "Pick And Place 2 Y Axis", sizeof(m_motorConfiguration[4].Axis));
	m_motorConfiguration[4].UnitInOnePulse = 1;//micron or degree
	strncpy_s(m_motorConfiguration[4].UnitName, "um", sizeof(m_motorConfiguration[4].UnitName));
	m_motorConfiguration[4].AxisInPositionToleranceInUnitPulse = 10;

	strncpy_s(m_motorConfiguration[5].Controller, "Galil", sizeof(m_motorConfiguration[5].Controller));
	strncpy_s(m_motorConfiguration[5].ControllerDetails, "GalilController2;192.168.1.4;B", sizeof(m_motorConfiguration[5].ControllerDetails));
	m_motorConfiguration[5].Enable = true;
	m_motorConfiguration[5].Online = true;
	strncpy_s(m_motorConfiguration[5].Axis, "Output Tray Table X Axis", sizeof(m_motorConfiguration[5].Axis));
	m_motorConfiguration[5].UnitInOnePulse = 1;//micron or degree
	strncpy_s(m_motorConfiguration[5].UnitName, "um", sizeof(m_motorConfiguration[5].UnitName));
	m_motorConfiguration[5].AxisInPositionToleranceInUnitPulse = 10;

	strncpy_s(m_motorConfiguration[6].Controller, "Galil", sizeof(m_motorConfiguration[6].Controller));
	strncpy_s(m_motorConfiguration[6].ControllerDetails, "GalilController2;192.168.1.4;C", sizeof(m_motorConfiguration[6].ControllerDetails));
	m_motorConfiguration[6].Enable = true;
	m_motorConfiguration[6].Online = true;
	strncpy_s(m_motorConfiguration[6].Axis, "Output Tray Table Y Axis", sizeof(m_motorConfiguration[6].Axis));
	m_motorConfiguration[6].UnitInOnePulse = 1;//micron or degree
	strncpy_s(m_motorConfiguration[6].UnitName, "um", sizeof(m_motorConfiguration[6].UnitName));
	m_motorConfiguration[6].AxisInPositionToleranceInUnitPulse = 10;

	strncpy_s(m_motorConfiguration[7].Controller, "Galil", sizeof(m_motorConfiguration[7].Controller));
	strncpy_s(m_motorConfiguration[7].ControllerDetails, "GalilController2;192.168.1.4;D", sizeof(m_motorConfiguration[7].ControllerDetails));
	m_motorConfiguration[7].Enable = true;
	m_motorConfiguration[7].Online = true;
	strncpy_s(m_motorConfiguration[7].Axis, "Output Tray Table Z Axis", sizeof(m_motorConfiguration[7].Axis));
	m_motorConfiguration[7].UnitInOnePulse = 666.667/1000;//micron or degree
	strncpy_s(m_motorConfiguration[7].UnitName, "mDegree", sizeof(m_motorConfiguration[7].UnitName));
	m_motorConfiguration[7].AxisInPositionToleranceInUnitPulse = 10;


	strncpy_s(m_motorConfiguration[8].Controller, "Galil", sizeof(m_motorConfiguration[8].Controller));
	strncpy_s(m_motorConfiguration[8].ControllerDetails, "GalilController3;192.168.1.5;A", sizeof(m_motorConfiguration[8].ControllerDetails));
	m_motorConfiguration[8].Enable = true;
	m_motorConfiguration[8].Online = true;
	strncpy_s(m_motorConfiguration[8].Axis, "Input Vision Module", sizeof(m_motorConfiguration[8].Axis));
	m_motorConfiguration[8].UnitInOnePulse = 1;//micron or degree
	strncpy_s(m_motorConfiguration[8].UnitName, "um", sizeof(m_motorConfiguration[8].UnitName));
	m_motorConfiguration[8].AxisInPositionToleranceInUnitPulse = 10;

	strncpy_s(m_motorConfiguration[9].Controller, "Galil", sizeof(m_motorConfiguration[9].Controller));
	strncpy_s(m_motorConfiguration[9].ControllerDetails, "GalilController3;192.168.1.5;B", sizeof(m_motorConfiguration[9].ControllerDetails));
	m_motorConfiguration[9].Enable = true;
	m_motorConfiguration[9].Online = true;
	strncpy_s(m_motorConfiguration[9].Axis, "S1 Vision Module", sizeof(m_motorConfiguration[9].Axis));
	m_motorConfiguration[9].UnitInOnePulse = 1;//micron or degree
	strncpy_s(m_motorConfiguration[9].UnitName, "um", sizeof(m_motorConfiguration[9].UnitName));
	m_motorConfiguration[9].AxisInPositionToleranceInUnitPulse = 10;

	strncpy_s(m_motorConfiguration[10].Controller, "Galil", sizeof(m_motorConfiguration[10].Controller));
	strncpy_s(m_motorConfiguration[10].ControllerDetails, "GalilController3;192.168.1.5;C", sizeof(m_motorConfiguration[10].ControllerDetails));
	m_motorConfiguration[10].Enable = true;
	m_motorConfiguration[10].Online = true;
	strncpy_s(m_motorConfiguration[10].Axis, "S2 Vision Module", sizeof(m_motorConfiguration[10].Axis));
	m_motorConfiguration[10].UnitInOnePulse = 1;//micron or degree
	strncpy_s(m_motorConfiguration[10].UnitName, "um", sizeof(m_motorConfiguration[10].UnitName));
	m_motorConfiguration[10].AxisInPositionToleranceInUnitPulse = 10;

	strncpy_s(m_motorConfiguration[11].Controller, "Galil", sizeof(m_motorConfiguration[11].Controller));
	strncpy_s(m_motorConfiguration[11].ControllerDetails, "GalilController3;192.168.1.5;D", sizeof(m_motorConfiguration[11].ControllerDetails));
	m_motorConfiguration[11].Enable = true;
	m_motorConfiguration[11].Online = true;
	strncpy_s(m_motorConfiguration[11].Axis, "S3 Vision Module", sizeof(m_motorConfiguration[11].Axis));
	m_motorConfiguration[11].UnitInOnePulse = 1;//micron or degree
	strncpy_s(m_motorConfiguration[11].UnitName, "um", sizeof(m_motorConfiguration[11].UnitName));
	m_motorConfiguration[11].AxisInPositionToleranceInUnitPulse = 10;

	m_cMotion->Initialize(true, false, m_motorConfiguration, 12);

	return 0;
}

int CProductMotorControl::MotionController1Initialize(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableMotionController1 == false)
	{
		m_cLogger->WriteLog("Motion controller 1 is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Motion controller 1 initializing\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError += cMotion->Reset(m_motorConfiguration[0].Axis);
	nError += cMotion->Reset(m_motorConfiguration[1].Axis);
	nError += cMotion->Reset(m_motorConfiguration[2].Axis);
	nError += cMotion->Reset(m_motorConfiguration[3].Axis);
	nError += cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, "XQ#INIT,0");

	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	if (nError != 0)
	{
		m_cLogger->WriteLog("Motion controller 1 initialize error %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cLogger->WriteLog("Motion controller 1 initialize done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	return nError;
}

int CProductMotorControl::MotionController2Initialize(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableMotionController2 == false)
	{
		m_cLogger->WriteLog("Motion controller 2 is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Motion controller 2 initializing\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError += cMotion->Reset(m_motorConfiguration[4].Axis);
	nError += cMotion->Reset(m_motorConfiguration[5].Axis);
	nError += cMotion->Reset(m_motorConfiguration[6].Axis);
	nError += cMotion->Reset(m_motorConfiguration[7].Axis);
	nError += cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, "XQ#INIT,0");

	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	if (nError != 0)
	{
		m_cLogger->WriteLog("Motion controller 2 initialize error %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cLogger->WriteLog("Motion controller 2 initialize done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	return nError;
}

int CProductMotorControl::MotionController3Initialize(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableMotionController3 == false)
	{
		m_cLogger->WriteLog("Motion controller 3 is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Motion controller 3 initializing\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError += cMotion->Reset(m_motorConfiguration[8].Axis);
	nError += cMotion->Reset(m_motorConfiguration[9].Axis);
	nError += cMotion->Reset(m_motorConfiguration[10].Axis);
	nError += cMotion->Reset(m_motorConfiguration[11].Axis);

	nError += cMotion->SendCommand(m_motorConfiguration[8].ControllerDetails, "XQ#INIT,0");

	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	if (nError != 0)
	{
		m_cLogger->WriteLog("Motion controller 3 initialize error %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cLogger->WriteLog("Motion controller 3 initialize done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);

	}
	return nError;
}

int CProductMotorControl::MotionController4Initialize(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableMotionController4 == false)
	{
		m_cLogger->WriteLog("Motion controller 4 is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Motion controller 4 initializing\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError += cMotion->Reset(m_motorConfiguration[12].Axis);
	nError += cMotion->Reset(m_motorConfiguration[13].Axis);
	nError += cMotion->Reset(m_motorConfiguration[14].Axis);
	//nError += cMotion->Reset(m_motorConfiguration[15].Axis);
	nError += cMotion->SendCommand(m_motorConfiguration[12].ControllerDetails, "XQ#INIT,0");

	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	if (nError != 0)
	{
		m_cLogger->WriteLog("Motion controller 4 initialize error %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cLogger->WriteLog("Motion controller 4 initialize done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	return nError;
}

#pragma region FUJI
#pragma region PickAndPlace1YAxisMotor
int CProductMotorControl::PickAndPlace1YAxisMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsPickAndPlace1YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(40001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsPickAndPlace1YAxisMotorHome = false;
	nError = cMotion->MotorOff(m_motorConfiguration[0].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1YAxisMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsPickAndPlace1YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(40001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorOn(m_motorConfiguration[0].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor on error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1YAxisMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1YAxisMotor == false)
	{
		m_cLogger->WriteLog("Pick And Place 1 Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	//if(IsInputTableXAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(40001);
	//	m_cLogger->WriteLog("Input Table X Axis Motor not ready.\n");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cLogger->WriteLog("Pick And Place 1 Y Axis motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	//smProductModuleStatus->IsInputTableXAxisMotorHome = false;
	nError = cMotion->MotorStop(m_motorConfiguration[0].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 1 Y Axis motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 1 Y Axis motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}

	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->Reset(m_motorConfiguration[0].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 1 Y Axis motor reset done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 1 Y Axis motor reset error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1YAxisMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsPickAndPlace1YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(40001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace1YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(40010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not safe to move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis homing");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[0].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Pick And Place 1 Y Axis motor thread 0 %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	char command[80];

	nError = cMotion->SetControllerVariable(m_motorConfiguration[0].ControllerDetails, "vPP1YHM", (signed long)(((double)0) / m_motorConfiguration[0].UnitInOnePulse));
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during reset Pick And Place 1 Y Axis home offset %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	smProductModuleStatus->IsPickAndPlace1YAxisMoving = true;
	nError = cMotion->MotorHomeAsychronous(m_motorConfiguration[0].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Pick And Place 1 Y Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor home start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor home start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			smProductModuleStatus->IsPickAndPlace1YAxisMotorHome = true;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor home done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace1YAxisMoving = false;
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	if (smProductEvent->JobSlow.Set == true)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = cMotion->SetControllerVariable(m_motorConfiguration[0].ControllerDetails, "vSLOW", (signed long)1);
		if (nError == 0)
		{
			return 0;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during set all MC1 slow on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
	}
	else
	{
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1YAxisMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1YAxisMotor == false)
	{
		m_cLogger->WriteLog("Pick And Place 1 Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Pick And Place 1 Y Axis Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	//not sure
	nError = cMotion->SetControllerVariable(m_motorConfiguration[0].ControllerDetails, "vPP1YIP", (signed long)(((double)smProductTeachPoint->PickAndPlace1YAxisInputPosition) / m_motorConfiguration[0].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[0].ControllerDetails, "vPP1YS1", (signed long)(((double)smProductTeachPoint->PickAndPlace1YAxisAtS1AndBottomVisionPosition) / m_motorConfiguration[0].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[0].ControllerDetails, "vPP1YS3", (signed long)(((double)smProductTeachPoint->PickAndPlace1YAxisAtS2AndS3VisionPosition) / m_motorConfiguration[0].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[0].ControllerDetails, "vPP1YOP", (signed long)(((double)smProductTeachPoint->PickAndPlace1YAxisOutputPosition) / m_motorConfiguration[0].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[0].ControllerDetails, "vPP1YSBY", (signed long)(((double)smProductTeachPoint->PickAndPlace1YAxisStandbyPosition) / m_motorConfiguration[0].UnitInOnePulse));
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 1 Y Axis motor setting done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1YAxisMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorStop(m_motorConfiguration[0].Axis);
	//not sure
	sprintf_s(command, sizeof(command), "SPA=vSPA*(%u/100);ACA=(vACA*%u/100);DCA=vDCA*(%u/100);", speedPercent, accelerationPercent, accelerationPercent);
	nError = cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor setting error %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return -1;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1YAxisMotorMoveToInputPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace1YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}

	if (smProductModuleStatus->IsPickAndPlace1YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(40005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace1YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(40001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace1YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(40010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis move to input position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace1YAxisMoving = true;
	if (smProductEvent->PickAndPlace1YAxisMotorMoveCurve.Set == true)
	{
		nError += cMotion->SetControllerVariable(m_motorConfiguration[0].ControllerDetails, "vPP1YEND", (signed long)(((double)smProductTeachPoint->PickAndPlace1YAxisStandbyPosition) / m_motorConfiguration[0].UnitInOnePulse));
		nError += cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, "XQ#AMCV,0");
	}
	else
		nError += cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, "XQ#AMIP,0");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 1 Y Axis motor move to input position %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor move input position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor move input position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace1YAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1YAxisMotorMoveToInputPositionCurve(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace1YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}

	if (smProductModuleStatus->IsPickAndPlace1YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(40005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace1YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(40001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace1YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(40010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis move to input position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace1YAxisMoving = true;
	if (smProductEvent->PickAndPlace1YAxisMotorMoveCurve.Set == true)
	{
		nError += cMotion->SetControllerVariable(m_motorConfiguration[0].ControllerDetails, "vPP1YEND", (signed long)(((double)smProductTeachPoint->PickAndPlace1YAxisInputPosition) / m_motorConfiguration[0].UnitInOnePulse));
		nError += cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, "XQ#AMCV,0");
	}
	else
		nError += cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, "XQ#AMIP,0");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 1 Y Axis motor move to input position %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor move input position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor move input position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace1YAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1YAxisMotorMoveToS1Position(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace1YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace1YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(40005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace1YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(40001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace1YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(40010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor move to S1 position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace1YAxisMoving = true;
	nError += cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, "XQ#AMS1,0");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 1 Y Axis motor move to S1 position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor move S1 position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor move S1 position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace1YAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1YAxisMotorMoveToS3Position(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace1YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace1YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(40005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace1YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(40001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace1YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(40010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor move to S3 Vision position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace1YAxisMoving = true;
	nError += cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, "XQ#AMS3,0");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 1 Y Axis motor move to S1 position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor move S3 position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor move S3 position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace1YAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1YAxisMotorMoveToOutputPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace1YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace1YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(40005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace1YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(40001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace1YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(40010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor move to output position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace1YAxisMoving = true;
	if (smProductEvent->PickAndPlace1YAxisMotorMoveCurve.Set == true)
	{
		nError += cMotion->SetControllerVariable(m_motorConfiguration[0].ControllerDetails, "vPP1YEND", (signed long)(((double)smProductTeachPoint->PickAndPlace1YAxisStandbyPosition) / m_motorConfiguration[0].UnitInOnePulse));
		nError += cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, "XQ#AMCV,0");
	}
	else
		nError += cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, "XQ#AMOP,0");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 1 Y Axis motor move to output position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor move output position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor move output position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace1YAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1YAxisMotorMoveToOutputPositionCurve(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace1YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace1YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(40005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace1YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(40001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace1YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(40010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor move to output position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace1YAxisMoving = true;
	if (smProductEvent->PickAndPlace1YAxisMotorMoveCurve.Set == true)
	{
		nError += cMotion->SetControllerVariable(m_motorConfiguration[0].ControllerDetails, "vPP1YEND", (signed long)(((double)smProductTeachPoint->PickAndPlace1YAxisOutputPosition) / m_motorConfiguration[0].UnitInOnePulse));
		nError += cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, "XQ#AMCV,0");
	}
	else
		nError += cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, "XQ#AMOP,0");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 1 Y Axis motor move to output position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor move output position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor move output position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace1YAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1YAxisMotorMoveToStandbyPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace1YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace1YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(40005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace1YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(40001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace1YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(40010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor move to standby position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace1YAxisMoving = true;
	nError += cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, "XQ#AMSBY,0");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 1 Y Axis motor move to standby position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor move standby position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor move standby position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace1YAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1YAxisMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace1YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsPickAndPlace1YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(40001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsPickAndPlace1YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(40005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}//check
	if (IsPickAndPlace1YAxisMotorSafeToMoveRelative(movePos_um + smGeneral->nMotorEncoderPosition) == false)
	{
		m_cProductShareVariables->SetAlarm(40010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}//check
	if (movePos_um + smGeneral->nMotorEncoderPosition > smProductTeachPoint->PickAndPlace1YAxisForwardLimitPosition ||
		movePos_um + smGeneral->nMotorEncoderPosition < smProductTeachPoint->PickAndPlace1YAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 Y Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 1 Y Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[0].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Y Axis motor send command stop thread %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	/*RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}*/
	//not sure
	smProductModuleStatus->IsPickAndPlace1YAxisMoving = true;
	sprintf_s(command, sizeof(command), "PRA=%u;BGA;AMA;", (int)(((double)movePos_um) / m_motorConfiguration[0].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis move Relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		smProductModuleStatus->IsPickAndPlace1YAxisMoving = false;
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Y Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
//check
int CProductMotorControl::PickAndPlace1YAxisMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace1YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsPickAndPlace1YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(40001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsPickAndPlace1YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(40005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace1YAxisMotorSafeToMoveAbsolute(movePos_um) == false)
	{
		m_cProductShareVariables->SetAlarm(40010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductEvent->GMAIN_RTHD_TEACHING_VISION.Set == true)
	{
		if (smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.InputStation)
		{
			if (movePos_um > smProductTeachPoint->PickAndPlace1YAxisInputPosition + (signed long)2000 ||
				movePos_um < smProductTeachPoint->PickAndPlace1YAxisInputPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 1 Y Input Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
		else if (smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.BottomStation)
		{
			if (movePos_um > smProductTeachPoint->PickAndPlace1YAxisAtS1AndBottomVisionPosition + (signed long)2000 ||
				movePos_um < smProductTeachPoint->PickAndPlace1YAxisAtS1AndBottomVisionPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 1 Y Bottom Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
		else if (smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.S3Station)
		{
			if (movePos_um > smProductTeachPoint->PickAndPlace1YAxisAtS2AndS3VisionPosition + (signed long)2000 ||
				movePos_um < smProductTeachPoint->PickAndPlace1YAxisAtS2AndS3VisionPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 1 Y S3 Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
		else if (smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.OutputStation)
		{
			if (movePos_um > smProductTeachPoint->PickAndPlace1YAxisOutputPosition + (signed long)2000 ||
				movePos_um < smProductTeachPoint->PickAndPlace1YAxisOutputPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 1 Y Output Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
	}
	if (movePos_um > smProductTeachPoint->PickAndPlace1YAxisForwardLimitPosition ||
		movePos_um < smProductTeachPoint->PickAndPlace1YAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 Y Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 1 Y Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);


	nError = cMotion->Reset(m_motorConfiguration[0].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Pick And Place 1 Y Axis motor thread 0 %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	/*RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}*/
	//not sure
	smProductModuleStatus->IsPickAndPlace1YAxisMoving = true;
	sprintf_s(command, sizeof(command), "PAA=%u;BGA;AMA;", (int)(((double)movePos_um) / m_motorConfiguration[0].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		smProductModuleStatus->IsPickAndPlace1YAxisMoving = false;
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Y Axis move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
//check
int CProductMotorControl::PickAndPlace1YAxisMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	if (smProductCustomize->EnablePickAndPlace1YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsPickAndPlace1YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(40001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsPickAndPlace1YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(40005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (smProductProduction->PickAndPlace1YAxisMovePosition > smProductTeachPoint->PickAndPlace1YAxisForwardLimitPosition ||
		smProductProduction->PickAndPlace1YAxisMovePosition < smProductTeachPoint->PickAndPlace1YAxisReverseLimitPosition)
	{
		m_cLogger->WriteLog("Position is out of Pick And Place 1 Y Axis Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	if (smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.InputStation && smProductProduction->PickAndPlace1StationToMove != PickAndPlaceCurrentStation.BottomStation)
	{
		if (smProductProduction->PickAndPlace1YAxisMovePosition > smProductTeachPoint->PickAndPlace1YAxisInputPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace1YAxisMovePosition < smProductTeachPoint->PickAndPlace1YAxisInputPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 Y Input Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 1 Y Input Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if ((smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.BottomStation || smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.MovingFromInputStationToBottomStation)
		&& smProductProduction->PickAndPlace1StationToMove != PickAndPlaceCurrentStation.S3Station)
	{
		if (smProductProduction->PickAndPlace1YAxisMovePosition > smProductTeachPoint->PickAndPlace1YAxisAtS1AndBottomVisionPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace1YAxisMovePosition < smProductTeachPoint->PickAndPlace1YAxisAtS1AndBottomVisionPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 Y Bottom Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 1 Y Bottom Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if ((smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.S3Station || smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.MovingFromBottomStationToS3Station)
		 && smProductProduction->PickAndPlace1StationToMove != PickAndPlaceCurrentStation.OutputStation)
	{
		if (smProductProduction->PickAndPlace1YAxisMovePosition > smProductTeachPoint->PickAndPlace1YAxisAtS2AndS3VisionPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace1YAxisMovePosition < smProductTeachPoint->PickAndPlace1YAxisAtS2AndS3VisionPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 Y S3 Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 1 Y S3 Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if (smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.OutputStation && smProductProduction->PickAndPlace1StationToMove != PickAndPlaceCurrentStation.InputStation)
	{
		if (smProductProduction->PickAndPlace1YAxisMovePosition > smProductTeachPoint->PickAndPlace1YAxisOutputPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace1YAxisMovePosition < smProductTeachPoint->PickAndPlace1YAxisOutputPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 Y Output Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 1 Y Output Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	if (IsPickAndPlace1YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(40010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	char command[80];
	// not sure
	smProductModuleStatus->IsPickAndPlace1YAxisMoving = true;
	if (smProductEvent->PickAndPlace1YAxisMotorMoveCurve.Set == true)
	{
		nError += cMotion->SetControllerVariable(m_motorConfiguration[0].ControllerDetails, "vPP1YEND", (signed long)(((double)smProductTeachPoint->PickAndPlace1YAxisStandbyPosition) / m_motorConfiguration[0].UnitInOnePulse));
		nError += cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, "XQ#AMCV,0");
	}
	else
	{
		sprintf_s(command, sizeof(command), "vPP1YPos=%u;XQ#AMV,0", (signed long)(((double)smProductProduction->PickAndPlace1YAxisMovePosition) / m_motorConfiguration[0].UnitInOnePulse));
	}
	nError += cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, command);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Move Pick And Place 1 Y Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor wait movement start3 timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace1YAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1YAxisMotorMoveCurve(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	if (smProductCustomize->EnablePickAndPlace1YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsPickAndPlace1YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(40001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsPickAndPlace1YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(40005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (smProductProduction->PickAndPlace1YAxisMovePosition > smProductTeachPoint->PickAndPlace1YAxisForwardLimitPosition ||
		smProductProduction->PickAndPlace1YAxisMovePosition < smProductTeachPoint->PickAndPlace1YAxisReverseLimitPosition)
	{
		m_cLogger->WriteLog("Position is out of Pick And Place 1 Y Axis Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	if (smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.InputStation && smProductProduction->PickAndPlace1StationToMove != PickAndPlaceCurrentStation.BottomStation)
	{
		if (smProductProduction->PickAndPlace1YAxisMovePosition > smProductTeachPoint->PickAndPlace1YAxisInputPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace1YAxisMovePosition < smProductTeachPoint->PickAndPlace1YAxisInputPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 Y Input Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 1 Y Input Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if ((smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.BottomStation || smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.MovingFromInputStationToBottomStation)
		&& smProductProduction->PickAndPlace1StationToMove != PickAndPlaceCurrentStation.S3Station)
	{
		if (smProductProduction->PickAndPlace1YAxisMovePosition > smProductTeachPoint->PickAndPlace1YAxisAtS1AndBottomVisionPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace1YAxisMovePosition < smProductTeachPoint->PickAndPlace1YAxisAtS1AndBottomVisionPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 Y Bottom Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 1 Y Bottom Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if ((smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.S3Station || smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.MovingFromBottomStationToS3Station)
		&& smProductProduction->PickAndPlace1StationToMove != PickAndPlaceCurrentStation.OutputStation)
	{
		if (smProductProduction->PickAndPlace1YAxisMovePosition > smProductTeachPoint->PickAndPlace1YAxisAtS2AndS3VisionPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace1YAxisMovePosition < smProductTeachPoint->PickAndPlace1YAxisAtS2AndS3VisionPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 Y S3 Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 1 Y S3 Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if (smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.OutputStation && smProductProduction->PickAndPlace1StationToMove != PickAndPlaceCurrentStation.InputStation)
	{
		if (smProductProduction->PickAndPlace1YAxisMovePosition > smProductTeachPoint->PickAndPlace1YAxisOutputPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace1YAxisMovePosition < smProductTeachPoint->PickAndPlace1YAxisOutputPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 Y Output Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 1 Y Output Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	if (IsPickAndPlace1YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(40010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	char command[80];
	// not sure
	smProductModuleStatus->IsPickAndPlace1YAxisMoving = true;

		nError += cMotion->SetControllerVariable(m_motorConfiguration[0].ControllerDetails, "vPP1YEND", (signed long)(((double)smProductProduction->PickAndPlace1YAxisMovePosition) / m_motorConfiguration[0].UnitInOnePulse));
		nError += cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, "XQ#AMCV,0");

	nError += cMotion->SendCommand(m_motorConfiguration[0].ControllerDetails, command);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Move Pick And Place 1 Y Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor wait movement start3 timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis motor done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace1YAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(40002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}

//not sure
bool CProductMotorControl::IsPickAndPlace1YAxisMotorSafeToMove()
{
	signed long slSidewallLeftModuleMotorEncoder = 0;//ReadSidewallVisionLeftModuleMotorEncoder();
	signed long slSidewallRearModuleMotorEncoder = 0;//ReadSidewallVisionRearModuleMotorEncoder();
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis not homing yet");
		return false;
	}
	
	//if (smProductProduction->PickAndPlace1YAxisMovePosition - slSidewallLeftModuleMotorEncoder <-20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis will collide with Side wall vision left module");
	//	return false;
	//}
	//
	//if (smProductProduction->PickAndPlace1YAxisMovePosition - slSidewallRearModuleMotorEncoder < -20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis will collide with Side Wall Vision Rear Module");
	//	return false;
	//}
	
	return true;
}
//not sure
bool CProductMotorControl::IsPickAndPlace1YAxisMotorSafeToMoveRelative(signed long position)
{
	signed long slSidewallLeftModuleMotorEncoder = 0;// ReadSidewallVisionLeftModuleMotorEncoder();
	signed long slSidewallRearModuleMotorEncoder = 0;// ReadSidewallVisionRearModuleMotorEncoder();
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis not homing yet");
		return false;
	}
	
	//if (smProductProduction->PickAndPlace1YAxisMovePosition - slSidewallLeftModuleMotorEncoder < -20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis will collide with Side wall vision left module");
	//	return false;
	//}
	//
	//if (smProductProduction->PickAndPlace1YAxisMovePosition - slSidewallRearModuleMotorEncoder < -20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis will collide with Side Wall Vision Rear Module");
	//	return false;
	//}
	
	return true;
}
//not sure
bool CProductMotorControl::IsPickAndPlace1YAxisMotorSafeToMoveAbsolute(signed long position)
{
	signed long slSidewallLeftModuleMotorEncoder = 0;// ReadSidewallVisionLeftModuleMotorEncoder();
	signed long slSidewallRearModuleMotorEncoder = 0;// ReadSidewallVisionRearModuleMotorEncoder();
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis not homing yet");
		return false;
	}
	
	//if (smProductProduction->PickAndPlace1YAxisMovePosition - slSidewallLeftModuleMotorEncoder < -20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis will collide with Side wall vision left module");
	//	return false;
	//}
	//
	//if (smProductProduction->PickAndPlace1YAxisMovePosition - slSidewallRearModuleMotorEncoder < -20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis will collide with Side Wall Vision Rear Module");
	//	return false;
	//}
	
	return true;
}
signed long CProductMotorControl::ReadPickAndPlace1YAxisMotorEncoder()
{
	return m_cMotion->GetEncoderPosition(m_motorConfiguration[0].Axis);
}
#pragma endregion

#pragma region InputTrayTableXAxisMotor
int CProductMotorControl::InputTrayTableXAxisMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(41001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsInputTrayTableXAxisMotorHome = false;
	nError = cMotion->MotorOff(m_motorConfiguration[1].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableXAxisMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(41001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorOn(m_motorConfiguration[1].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor on error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableXAxisMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableXAxisMotor == false)
	{
		m_cLogger->WriteLog("Input Tray Table X Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	//if(IsInputTableYAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(41001);
	//	m_cLogger->WriteLog("Input Table Y Axis Motor not ready.\n");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cLogger->WriteLog("Input Tray Table X Axis motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	//smProductModuleStatus->IsInputTableYAxisMotorHome = false;
	nError = cMotion->MotorStop(m_motorConfiguration[1].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Tray Table X Axis motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Tray Table X Axis motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}

	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->Reset(m_motorConfiguration[1].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Tray Table X Axis motor reset done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Tray Table X Axis motor reset error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableXAxisMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(41001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableXAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}

	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis homing");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[1].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Input Tray Table X Axis motor thread 0 %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	nError = cMotion->SetControllerVariable(m_motorConfiguration[1].ControllerDetails, "vITTXHM", signed long(((double)0) / m_motorConfiguration[1].UnitInOnePulse));
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during reset Input Tray Table X Axis home offset %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	nError = cMotion->MotorHomeAsychronous(m_motorConfiguration[1].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Input Tray Table X Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor home start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor home start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == true)
		{
			smProductModuleStatus->IsInputTrayTableXAxisMotorHome = true;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor home done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	if (smProductEvent->JobSlow.Set == true)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = cMotion->SetControllerVariable(m_motorConfiguration[1].ControllerDetails, "vSLOW", (signed long)1);
		if (nError == 0)
		{
			return 0;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during set all MC1 slow on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
	}
	else
	{
		return 0;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableXAxisMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableXAxisMotor == false)
	{
		m_cLogger->WriteLog("Input Tray Table X Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Input Tray Table X Axis Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError += cMotion->SetControllerVariable(m_motorConfiguration[1].ControllerDetails, "vITTXLD", (signed long)(((double)smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerLoadPosition) / m_motorConfiguration[1].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[1].ControllerDetails, "vITTXUL", (signed long)(((double)smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerUnloadPosition) / m_motorConfiguration[1].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[1].ControllerDetails, "vITTXCN", (signed long)(((double)smProductTeachPoint->InputTrayTableXAxisAtInputTrayTableCenterPosition) / m_motorConfiguration[1].UnitInOnePulse));
	/*nError += cMotion->SetControllerVariable(m_motorConfiguration[1].ControllerDetails, "vITTXS2", (signed long)(((double)smProductTeachPoint->InputTrayTableXAxisAtInputS2CalibrationPosition) / m_motorConfiguration[1].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[1].ControllerDetails, "vITTXSW", (signed long)(((double)smProductTeachPoint->InputTrayTableXAxisAtInputSWVisionDotGridPosition) / m_motorConfiguration[1].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[1].ControllerDetails, "vITTXBTIV", (signed long)(((double)smProductTeachPoint->InputTrayTableXAxisAtInputBottomAndInputVisionDotGridPosition) / m_motorConfiguration[1].UnitInOnePulse));*/

	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Tray Table X Axis motor setting done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableXAxisMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorStop(m_motorConfiguration[1].Axis);
	// not sure
	sprintf_s(command, sizeof(command), "SPB=vSPB*(%u/100);ACB=vACB*(%u/100);DCB=vDCB*(%u/100);", speedPercent, accelerationPercent, accelerationPercent);
	nError = cMotion->SendCommand(m_motorConfiguration[1].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableXAxisMotorMoveLoad(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableInputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(41005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(41001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableXAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}

	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move to load position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[1].ControllerDetails, "XQ#BMLD,1");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Input Tray Table X Axis motor move to load position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move load position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move load position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::InputTrayTableXAxisMotorMoveUnload(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableInputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(41005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(41001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableXAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}

	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move to unload position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[1].ControllerDetails, "XQ#BMUL,1");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Input Tray Table X Axis motor move to unload position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move unload position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move unload position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::InputTrayTableXAxisMotorMoveCenter(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableInputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(41005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(41001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableXAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}

	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move to center position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[1].ControllerDetails, "XQ#BMCN,1");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Input Tray Table X Axis motor move to center position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move center position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move center position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}

int CProductMotorControl::InputTrayTableXAxisMotorMoveInputS2CalibrationPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableInputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(41005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(41001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableXAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}

	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move to input S2 Calibration position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[1].ControllerDetails, "XQ#BMS2,1");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Input Tray Table X Axis motor move to input S2 Calibration position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move input S2 Calibration position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move input S2 Calibration position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::InputTrayTableXAxisMotorMoveInputSWVisionDotGridPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableInputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(41005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(41001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableXAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}

	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move to input SW Vision Dot Grid position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[1].ControllerDetails, "XQ#BMSW,1");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Input Tray Table X Axis motor move to input SW Vision Dot Grid position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move input SW Vision Dot Grid position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move input SW Vision Dot Grid position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::InputTrayTableXAxisMotorMoveInputBottomAndInputVisionDotGridPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableInputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(41005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(41001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableXAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}

	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move to input bottom and input Vision Dot Grid position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[1].ControllerDetails, "XQ#BMBTIV,1");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Input Tray Table X Axis motor move to input bottom and input Vision Dot Grid position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move input bottom and input Vision Dot Grid position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor move input bottom and input Vision Dot Grid position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::InputTrayTableXAxisMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(41001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsInputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(41005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsInputTrayTableXAxisMotorSafeToMoveRelative(movePos_um + smGeneral->nMotorEncoderPosition) == false)
	{
		m_cProductShareVariables->SetAlarm(41010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um + smGeneral->nMotorEncoderPosition > smProductTeachPoint->InputTrayTableXAxisForwardLimitPosition ||
		movePos_um + smGeneral->nMotorEncoderPosition < smProductTeachPoint->InputTrayTableXAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Input Tray Table X Axis Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Input Tray Table X Axis Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[1].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table X Axis motor send command stop thread %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//not sure
	sprintf_s(command, sizeof(command), "PRB=%u;BGB;AMB;", (int)(((double)movePos_um) / ((double)m_motorConfiguration[1].UnitInOnePulse)));
	nError = cMotion->SendCommand(m_motorConfiguration[1].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis move relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table X Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableXAxisMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(41001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsInputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(41005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsInputTrayTableXAxisMotorSafeToMoveAbsolute(movePos_um) == false)
	{
		m_cProductShareVariables->SetAlarm(41010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um > smProductTeachPoint->InputTrayTableXAxisForwardLimitPosition ||
		movePos_um < smProductTeachPoint->InputTrayTableXAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Input Tray Table X Axis Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Input Tray Table X Axis Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[1].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Input Tray Table X Axis motor thread 0 %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//not sure
	sprintf_s(command, sizeof(command), "PAB=%u;BGB;AMB;", (int)(((double)movePos_um) / m_motorConfiguration[1].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[1].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table X Axis move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableXAxisMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;

	if (smProductCustomize->EnableInputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(41005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(41001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductProduction->InputTrayTableXAxisMovePosition > smProductTeachPoint->InputTrayTableXAxisForwardLimitPosition ||
		smProductProduction->InputTrayTableXAxisMovePosition < smProductTeachPoint->InputTrayTableXAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Input Tray Table X Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Input Tray Table X Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableXAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}

	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == true)
		{
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	char command[80];
	//not sure
	sprintf_s(command, sizeof(command), "vITTXPos=%u;XQ#BMV,1", (signed long)(((double)smProductProduction->InputTrayTableXAxisMovePosition) / m_motorConfiguration[1].UnitInOnePulse));
	nError += cMotion->SendCommand(m_motorConfiguration[1].ControllerDetails, command);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Input Tray Table X Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor wait movement start3 timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableXAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis motor done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(41002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
//not sure
bool CProductMotorControl::IsInputTrayTableXAxisMotorSafeToMove()
{
	signed long InputTrayTableZAxisMotorEncoder = ReadInputTrayTableZAxisMotorEncoder();
	//1.0.0.c Thor
	signed long ZAxisLimit = 0;
	//--
	if (smProductModuleStatus->IsInputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Not yet Home.\n");
		return false;
	}
	//1.0.0.c Thor
	if (smProductTeachPoint->InputTrayTableZAxisDownPosition > 0)
	{
		ZAxisLimit = smProductTeachPoint->InputTrayTableZAxisDownPosition;
	}
	else
	{
		ZAxisLimit = 0;
	}
	//if (InputTrayTableZAxisMotorEncoder != smProductTeachPoint->InputTrayTableZAxisDownPosition
	//	&& InputTrayTableZAxisMotorEncoder > smProductTeachPoint->InputTrayTableZAxisDownPosition + m_motorConfiguration[1].AxisInPositionToleranceInUnitPulse)
	if (InputTrayTableZAxisMotorEncoder != ZAxisLimit
		&& InputTrayTableZAxisMotorEncoder > ZAxisLimit + m_motorConfiguration[3].AxisInPositionToleranceInUnitPulse)
	//--
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Position %lf.\n",(double)InputTrayTableZAxisMotorEncoder);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis not at down Position.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace1ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace1ZAxisUpPosition
		//	&& ReadPickAndPlace1ZAxisMotorEncoder()<smProductTeachPoint->PickAndPlace1ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not Homing yet.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
		//	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not Homing yet.\n");
		return false;
	}

	return true;
}
//not sure
bool CProductMotorControl::IsInputTrayTableXAxisMotorSafeToMoveRelative(signed long position)
{
	signed long InputTrayTableZAxisMotorEncoder = ReadInputTrayTableZAxisMotorEncoder();
	signed long ZAxisLimit = 0;
	if (smProductModuleStatus->IsInputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Not yet Home.\n");
		return false;
	}
	//1.0.0.c Thor
	if (smProductTeachPoint->InputTrayTableZAxisDownPosition > 0)
	{
		ZAxisLimit = smProductTeachPoint->InputTrayTableZAxisDownPosition;
	}
	else
	{
		ZAxisLimit = 0;
	}
	//if (InputTrayTableZAxisMotorEncoder != smProductTeachPoint->InputTrayTableZAxisDownPosition
	//	&& InputTrayTableZAxisMotorEncoder > smProductTeachPoint->InputTrayTableZAxisDownPosition + m_motorConfiguration[1].AxisInPositionToleranceInUnitPulse)
	if (InputTrayTableZAxisMotorEncoder != ZAxisLimit
		&& InputTrayTableZAxisMotorEncoder > ZAxisLimit + m_motorConfiguration[3].AxisInPositionToleranceInUnitPulse)
	//--
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis not at down Position.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace1ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace1ZAxisUpPosition
		//	&& ReadPickAndPlace1ZAxisMotorEncoder()<smProductTeachPoint->PickAndPlace1ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not Homing yet.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
		//	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not Homing yet.\n");
		return false;
	}
	return true;
}
//not sure
bool CProductMotorControl::IsInputTrayTableXAxisMotorSafeToMoveAbsolute(signed long position)
{
	signed long InputTrayTableZAxisMotorEncoder = ReadInputTrayTableZAxisMotorEncoder();
	signed long ZAxisLimit = 0;
	if (smProductModuleStatus->IsInputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Not yet Home.\n");
		return false;
	}
	//1.0.0.c Thor
	if (smProductTeachPoint->InputTrayTableZAxisDownPosition > 0)
	{
		ZAxisLimit = smProductTeachPoint->InputTrayTableZAxisDownPosition;
	}
	else
	{
		ZAxisLimit = 0;
	}
	//if (InputTrayTableZAxisMotorEncoder != smProductTeachPoint->InputTrayTableZAxisDownPosition
	//	&& InputTrayTableZAxisMotorEncoder > smProductTeachPoint->InputTrayTableZAxisDownPosition + m_motorConfiguration[1].AxisInPositionToleranceInUnitPulse)
	if (InputTrayTableZAxisMotorEncoder != ZAxisLimit
		&& InputTrayTableZAxisMotorEncoder > ZAxisLimit + m_motorConfiguration[3].AxisInPositionToleranceInUnitPulse)
	//--
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis not at down Position.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace1ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace1ZAxisUpPosition
		//	&& ReadPickAndPlace1ZAxisMotorEncoder()<smProductTeachPoint->PickAndPlace1ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not Homing yet.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
		//	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not Homing yet.\n");
		return false;
	}
	return true;
}
signed long CProductMotorControl::ReadInputTrayTableXAxisMotorEncoder()
{
	int nError = 0;
	signed long slPosition;
	return m_cMotion->GetEncoderPosition(m_motorConfiguration[1].Axis);
}
#pragma endregion

#pragma region Input Tray Table Y Axis Motor

int CProductMotorControl::InputTrayTableYAxisMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(42001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsInputTrayTableYAxisMotorHome = false;
	nError = cMotion->MotorOff(m_motorConfiguration[2].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableYAxisMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(42001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorOn(m_motorConfiguration[2].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor on error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableYAxisMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableYAxisMotor == false)
	{
		m_cLogger->WriteLog("Input Tray Table Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Input Tray Table Y Axis motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	//smProductModuleStatus->IsInputTableThetaAxisMotorHome = false;
	nError = cMotion->MotorStop(m_motorConfiguration[2].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Tray Table Y Axis motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Tray Table Y Axis motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->Reset(m_motorConfiguration[2].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Tray Table Y Axis motor reset done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Tray Table Y Axis motor reset error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableYAxisMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(42001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableYAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}

	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis homing");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[2].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Input Tray Table Y Axis motor thread 0 %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	// check
	nError = cMotion->SetControllerVariable(m_motorConfiguration[2].ControllerDetails, "vITTYHM", (signed long)0);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during reset Input Tray Table Y Axis home offset %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	nError = cMotion->MotorHomeAsychronous(m_motorConfiguration[2].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Input Tray Table Y Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor home start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor home start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == true)
		{
			smProductModuleStatus->IsInputTrayTableYAxisMotorHome = true;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor home done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	if (smProductEvent->JobSlow.Set == true)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = cMotion->SetControllerVariable(m_motorConfiguration[2].ControllerDetails, "vSLOW", (signed long)1);
		if (nError == 0)
		{
			return 0;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during set all MC1 slow on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
	}
	else
	{
		return 0;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableYAxisMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableYAxisMotor == false)
	{
		m_cLogger->WriteLog("Input Tray Table Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Input Tray Table Y Axis Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError += cMotion->SetControllerVariable(m_motorConfiguration[2].ControllerDetails, "vITTYLD", (signed long)(((double)smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerLoadPosition) / m_motorConfiguration[2].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[2].ControllerDetails, "vITTYUL", (signed long)(((double)smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerUnloadPosition) / m_motorConfiguration[2].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[2].ControllerDetails, "vITTYCN", (signed long)(((double)(smProductTeachPoint->InputTrayTableYAxisAtInputTrayTableCenterPosition)) / m_motorConfiguration[2].UnitInOnePulse));
	/*nError += cMotion->SetControllerVariable(m_motorConfiguration[2].ControllerDetails, "vITTYDG", (signed long)(((double)(smProductTeachPoint->InputTrayTableYAxisAtInputS2SWAndBottomDotGridPosition)) / m_motorConfiguration[2].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[2].ControllerDetails, "vITTYIPV", (signed long)(((double)(smProductTeachPoint->InputTrayTableYAxisAtInputIPVCalibrationPosition)) / m_motorConfiguration[2].UnitInOnePulse));*/
	//nError += cMotion->SetControllerVariable(m_motorConfiguration[2].ControllerDetails, "vITTYPNP", (signed long)(((double)((smProductTeachPoint->InputTrayTableYAxisJigPlacementPosition + 185000) - ((smProductSetting->NoOfDeviceInRowOutput / 2) - 0.5)*smProductSetting->DeviceYPitchOutput)) / m_motorConfiguration[2].UnitInOnePulse));
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Tray Table Y Axis motor setting done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableYAxisMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorStop(m_motorConfiguration[2].Axis);
	//not sure
	sprintf_s(command, sizeof(command), "SPC=vSPC*(%u/100);ACC=vACC*(%u/100);DCC=vDCC*(%u/100);", speedPercent, accelerationPercent, accelerationPercent);
	nError = cMotion->SendCommand(m_motorConfiguration[2].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}

int CProductMotorControl::InputTrayTableYAxisMotorMoveLoad(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableInputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableYAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(42005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(42001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableYAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}

	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor move to load position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[2].ControllerDetails, "XQ#CMLD,2");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Input Tray Table Y Axis motor move to load position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor move load position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor move load position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::InputTrayTableYAxisMotorMoveUnload(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableInputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableYAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(42005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(42001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableYAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}

	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor move to unload position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[2].ControllerDetails, "XQ#CMUL,2");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Input Tray Table Y Axis motor move to unload position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor move unload position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor move unload position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::InputTrayTableYAxisMotorMoveCenter(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableInputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableYAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(42005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(42001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableYAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}

	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor move to center position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[2].ControllerDetails, "XQ#CMCN,2");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Input Tray Table Y Axis motor move to center position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor move center position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor move center position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::InputTrayTableYAxisMotorMoveInputS2SWAndBottomDotGridPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableInputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableYAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(42005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(42001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableYAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}

	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor move to Input S2, SW and bottom vision dot grid position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[2].ControllerDetails, "XQ#CMDG,2");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Input Tray Table Y Axis motor move to Input S2, SW and bottom vision dot grid position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor move Input S2, SW and bottom vision dot grid position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor move Input S2, SW and bottom vision dot grid position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::InputTrayTableYAxisMotorMoveInputIPVCalibrationPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableInputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableYAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(42005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(42001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableYAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}

	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor move to Input IPV calibration position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[2].ControllerDetails, "XQ#CMIPV,2");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Input Tray Table Y Axis motor move to Input IPV calibration position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor move Input IPV calibration position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor move Input IPV calibration position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::InputTrayTableYAxisMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(42001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsInputTrayTableYAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(42005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (movePos_um + smGeneral->nMotorEncoderPosition > smProductTeachPoint->InputTrayTableYAxisForwardLimitPosition ||
		movePos_um + smGeneral->nMotorEncoderPosition < smProductTeachPoint->InputTrayTableYAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Input Tray Table Y Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Input Tray Table Y Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	if (IsInputTrayTableYAxisMotorSafeToMoveRelative(movePos_um + smGeneral->nMotorEncoderPosition) == false)
	{
		m_cProductShareVariables->SetAlarm(42010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[2].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Y Axis motor send command stop thread %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//not sure
	sprintf_s(command, sizeof(command), "PRC=%u;BGC;AMC;", (int)((double)movePos_um / m_motorConfiguration[2].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[2].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis move relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Y Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableYAxisMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(42001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsInputTrayTableYAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(42005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsInputTrayTableYAxisMotorSafeToMoveAbsolute(movePos_um) == false)
	{
		m_cProductShareVariables->SetAlarm(42010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um > smProductTeachPoint->InputTrayTableYAxisForwardLimitPosition ||
		movePos_um < smProductTeachPoint->InputTrayTableYAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Input Tray Table Y Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Input Tray Table Y Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[2].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Input Tray Table Y Axis motor thread 0 %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//not sure
	sprintf_s(command, sizeof(command), "PAC=%u;BGC;AMC;", (int)((double)movePos_um / m_motorConfiguration[2].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[2].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Y Axis move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableYAxisMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	if (smProductCustomize->EnableInputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableYAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(42005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(42001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductProduction->InputTrayTableYAxisMovePosition > smProductTeachPoint->InputTrayTableYAxisForwardLimitPosition ||
		smProductProduction->InputTrayTableYAxisMovePosition < smProductTeachPoint->InputTrayTableYAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Input Tray Table Y Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Input Tray Table Y Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableYAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}

	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor move");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == true)
		{
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	char command[80];
	//not sure
	sprintf_s(command, sizeof(command), "vITTYPos=%u;XQ#CMV,2", (signed long)(((double)smProductProduction->InputTrayTableYAxisMovePosition) / m_motorConfiguration[2].UnitInOnePulse));
	nError += cMotion->SendCommand(m_motorConfiguration[2].ControllerDetails, command);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Move Input Tray Table Y Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor wait movement start3 timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableYAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis motor done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Y Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
//not sure
bool CProductMotorControl::IsInputTrayTableYAxisMotorSafeToMove()
{
	signed long InputTrayTableZAxisMotorEncoder = ReadInputTrayTableZAxisMotorEncoder();
	//1.0.0.0c Thor
	signed long ZAxisLimit = 0;
	if (smProductModuleStatus->IsInputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Not yet Home.\n");
		return false;
	}
	//1.0.0.c Thor
	if (smProductTeachPoint->InputTrayTableZAxisDownPosition > 0)
	{
		ZAxisLimit = smProductTeachPoint->InputTrayTableZAxisDownPosition;
	}
	else
	{
		ZAxisLimit = 0;
	}
	//if (InputTrayTableZAxisMotorEncoder != smProductTeachPoint->InputTrayTableZAxisDownPosition
	//	&&InputTrayTableZAxisMotorEncoder > smProductTeachPoint->InputTrayTableZAxisDownPosition + m_motorConfiguration[2].AxisInPositionToleranceInUnitPulse)
	if (InputTrayTableZAxisMotorEncoder != ZAxisLimit
		&&InputTrayTableZAxisMotorEncoder > ZAxisLimit + m_motorConfiguration[3].AxisInPositionToleranceInUnitPulse)
	//--
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis At Up Position.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace1ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace1ZAxisUpPosition
		//	&& ReadPickAndPlace1ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace1ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not Homing yet.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
		//	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not Homing yet.\n");
		return false;
	}
	return true;
}
//not sure
bool CProductMotorControl::IsInputTrayTableYAxisMotorSafeToMoveRelative(signed long position)
{
	signed long InputTrayTableZAxisMotorEncoder = ReadInputTrayTableZAxisMotorEncoder();
	signed long ZAxisLimit = 0;
	if (smProductModuleStatus->IsInputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Not yet Home.\n");
		return false;
	}
	//1.0.0.c Thor
	if (smProductTeachPoint->InputTrayTableZAxisDownPosition > 0)
	{
		ZAxisLimit = smProductTeachPoint->InputTrayTableZAxisDownPosition;
	}
	else
	{
		ZAxisLimit = 0;
	}
	//if (InputTrayTableZAxisMotorEncoder != smProductTeachPoint->InputTrayTableZAxisDownPosition
	//	&&InputTrayTableZAxisMotorEncoder > smProductTeachPoint->InputTrayTableZAxisDownPosition + m_motorConfiguration[2].AxisInPositionToleranceInUnitPulse)
	if (InputTrayTableZAxisMotorEncoder != ZAxisLimit
		&& InputTrayTableZAxisMotorEncoder > ZAxisLimit + m_motorConfiguration[3].AxisInPositionToleranceInUnitPulse)
		//--
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis At Up Position.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace1ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace1ZAxisUpPosition
		//	&& ReadPickAndPlace1ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace1ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not Homing yet.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
		//	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not Homing yet.\n");
		return false;
	}
	return true;
}
//not sure
bool CProductMotorControl::IsInputTrayTableYAxisMotorSafeToMoveAbsolute(signed long position)
{
	signed long InputTrayTableZAxisMotorEncoder = ReadInputTrayTableZAxisMotorEncoder();
	signed long ZAxisLimit = 0;
	if (smProductModuleStatus->IsInputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Not yet Home.\n");
		return false;
	}
	//1.0.0.c Thor
	if (smProductTeachPoint->InputTrayTableZAxisDownPosition > 0)
	{
		ZAxisLimit = smProductTeachPoint->InputTrayTableZAxisDownPosition;
	}
	else
	{
		ZAxisLimit = 0;
	}
	//if (InputTrayTableZAxisMotorEncoder != smProductTeachPoint->InputTrayTableZAxisDownPosition
	//	&&InputTrayTableZAxisMotorEncoder > smProductTeachPoint->InputTrayTableZAxisDownPosition + m_motorConfiguration[2].AxisInPositionToleranceInUnitPulse)
	if (InputTrayTableZAxisMotorEncoder != ZAxisLimit
		&& InputTrayTableZAxisMotorEncoder > ZAxisLimit + m_motorConfiguration[3].AxisInPositionToleranceInUnitPulse)
		//--
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis At Up Position.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace1ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace1ZAxisUpPosition
		//	&& ReadPickAndPlace1ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace1ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not Homing yet.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
		//	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not Homing yet.\n");
		return false;
	}
	return true;
}
signed long CProductMotorControl::ReadInputTrayTableYAxisMotorEncoder()
{
	int nError = 0;
	signed long slPosition;
	return m_cMotion->GetEncoderPosition(m_motorConfiguration[2].Axis);
}
#pragma endregion

#pragma region Input Tray Table Z Axis Motor
int CProductMotorControl::InputTrayTableZAxisMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(43001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsInputTrayTableZAxisMotorHome = false;
	nError = cMotion->MotorOff(m_motorConfiguration[3].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableZAxisMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(43001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorOn(m_motorConfiguration[3].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor on error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableZAxisMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableZAxisMotor == false)
	{
		m_cLogger->WriteLog("Input Tray Table Z Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Input Tray Table Z Axis motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->MotorStop(m_motorConfiguration[3].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Tray Table Z Axis motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Tray Table Z Axis motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->Reset(m_motorConfiguration[3].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Tray Table Z Axis motor reset done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Tray Table Z Axis motor reset error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableZAxisMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(43001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	//if (IsInputTrayTableZAxisMotorSafeToMove() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(43010);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not safe to move.");
	//	return m_cProductShareVariables->Error_MotorNotSafeToMove;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis homing");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[3].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Input Tray Table Z Axis motor thread 0 %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	nError = cMotion->SetControllerVariable(m_motorConfiguration[3].ControllerDetails, "vITTZHM", (signed long)0);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during reset Input Tray Table Z Axis home offset %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	nError = cMotion->MotorHomeAsychronous(m_motorConfiguration[3].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Input Tray Table Z Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableZAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor home start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(43004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor home start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableZAxisMotorInPosition() == true)
		{
			smProductModuleStatus->IsInputTrayTableZAxisMotorHome = true;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor home done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(43004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	if (smProductEvent->JobSlow.Set == true)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = cMotion->SetControllerVariable(m_motorConfiguration[3].ControllerDetails, "vSLOW", (signed long)1);
		if (nError == 0)
		{
			return 0;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during set all MC1 slow on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
	}
	else
	{
		return 0;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableZAxisMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableZAxisMotor == false)
	{
		m_cLogger->WriteLog("Input Tray Table Z Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Input Tray Table Z Axis Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError += cMotion->SetControllerVariable(m_motorConfiguration[3].ControllerDetails, "vITTZDW", (signed long)(((double)smProductTeachPoint->InputTrayTableZAxisDownPosition) / m_motorConfiguration[3].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[3].ControllerDetails, "vITTZLD", (signed long)(((double)smProductTeachPoint->InputTrayTableZAxisAtInputTrayStackerLoadingPosition) / m_motorConfiguration[3].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[3].ControllerDetails, "vITTZSG", (signed long)(((double)smProductTeachPoint->InputTrayTableZAxisAtInputTrayStackerSingulationPosition) / m_motorConfiguration[3].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[3].ControllerDetails, "vITTZUL", (signed long)(((double)smProductTeachPoint->InputTrayTableZAxisAtInputTrayStackerUnloadingPosition) / m_motorConfiguration[3].UnitInOnePulse));
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Tray Table Z Axis motor setting done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableZAxisMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorStop(m_motorConfiguration[3].Axis);
	//not sure
	sprintf_s(command, sizeof(command), "SPD=vSPD*(%u/100);ACD=vACD*(%u/100);DCD=vDCD*(%u/100);", speedPercent, accelerationPercent, accelerationPercent);
	nError = cMotion->SendCommand(m_motorConfiguration[3].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableZAxisMotorMoveDown(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableInputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(43005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(43001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableZAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(43010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor move down");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableZAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[3].ControllerDetails, "XQ#DMDW,3");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Input Tray Table Z Axis motor move down %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableZAxisMotorInPosition() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor move down start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(43003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableZAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor move down done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(43002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::InputTrayTableZAxisMotorMoveLoad(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableInputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(43005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(43001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableZAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(43010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor move load");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableZAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[3].ControllerDetails, "XQ#DMLD,3");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Input Tray Table Z Axis motor move load %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableZAxisMotorInPosition() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor move load start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(43003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableZAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor move load done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(43002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::InputTrayTableZAxisMotorMoveSingulation(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableInputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(43005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(43001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableZAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(43010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}

	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor move singulation");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableZAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[3].ControllerDetails, "XQ#DMSG,3");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Input Tray Table Z Axis motor move to singulation position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableZAxisMotorInPosition() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor move to singulation position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(43003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableZAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor move to singulation position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(43002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::InputTrayTableZAxisMotorMoveUnload(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableInputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(43005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(43001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableZAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(43010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor move unload");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableZAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[3].ControllerDetails, "XQ#DMUL,3");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Input Tray Table Z Axis motor move unload %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableZAxisMotorInPosition() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor move unload start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(43003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableZAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor move unload done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(43002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::InputTrayTableZAxisMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(43001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsInputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(43005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (movePos_um + smGeneral->nMotorEncoderPosition > smProductTeachPoint->InputTrayTableZAxisForwardLimitPosition ||
		movePos_um + smGeneral->nMotorEncoderPosition < smProductTeachPoint->InputTrayTableZAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Input Tray Table Z Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Input Tray Table Z Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	if (IsInputTrayTableZAxisMotorSafeToMoveRelative(movePos_um + smGeneral->nMotorEncoderPosition) == false)
	{
		m_cProductShareVariables->SetAlarm(43010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[3].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Z Axis motor send command stop thread %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//not sure
	sprintf_s(command, sizeof(command), "PRD=%u;BGD;AMD;", (int)((double)movePos_um / m_motorConfiguration[3].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[3].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis move relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Z Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableZAxisMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(43001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsInputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(43005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}

	if (movePos_um > smProductTeachPoint->InputTrayTableZAxisForwardLimitPosition ||
		movePos_um < smProductTeachPoint->InputTrayTableZAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Input Tray Table Z Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Input Tray Table Z Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	if (IsInputTrayTableZAxisMotorSafeToMoveAbsolute(movePos_um) == false)
	{
		m_cProductShareVariables->SetAlarm(43010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[3].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Input Tray Table Z Axis motor thread 0 %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//not sure
	sprintf_s(command, sizeof(command), "PAD=%u;BGD;AMD;", (int)((double)movePos_um / m_motorConfiguration[3].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[3].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(30001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Tray Table Z Axis move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputTrayTableZAxisMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	if (smProductCustomize->EnableInputTrayTableZAxisMotor == false)
	{

		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(43005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(43001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductProduction->InputTrayTableZAxisMovePosition > smProductTeachPoint->InputTrayTableZAxisForwardLimitPosition ||
		smProductProduction->InputTrayTableZAxisMovePosition < smProductTeachPoint->InputTrayTableZAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Input Tray Table Z Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cLogger->WriteLog("Position is out of Input Tray Table Z Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsInputTrayTableZAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(43010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableZAxisMotorInPosition() == true)
		{
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	char command[80];
	//check again
	sprintf_s(command, sizeof(command), "vITTZPos=%u;XQ#DMV,3", (signed long)(((double)smProductProduction->InputTrayTableZAxisMovePosition) / m_motorConfiguration[3].UnitInOnePulse));
	nError += cMotion->SendCommand(m_motorConfiguration[3].ControllerDetails, command);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(30001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Input Tray Table Z Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableZAxisMotorInPosition() == false)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(43003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor wait movement start3 timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputTrayTableZAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis motor done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(43002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table Z Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
//not sure
bool CProductMotorControl::IsInputTrayTableZAxisMotorSafeToMove()
{
	signed long InputTrayTableXAxisMotorEncoder = ReadInputTrayTableXAxisMotorEncoder();
	signed long InputTrayTableYAxisMotorEncoder = ReadInputTrayTableYAxisMotorEncoder();
	if (InputTrayTableXAxisMotorEncoder <= (smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerLoadPosition + 40)
		&& InputTrayTableXAxisMotorEncoder >= (smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerLoadPosition - 40)
		&& InputTrayTableYAxisMotorEncoder <= (smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerLoadPosition + 40)
		&& InputTrayTableYAxisMotorEncoder >= (smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerLoadPosition - 40))
	{

	}
	else if (InputTrayTableXAxisMotorEncoder <= (smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerUnloadPosition + 40)
		&& InputTrayTableXAxisMotorEncoder >= (smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerUnloadPosition - 40)
		&& InputTrayTableYAxisMotorEncoder <= (smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerUnloadPosition + 40)
		&& InputTrayTableYAxisMotorEncoder >= (smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerUnloadPosition - 40))
	{

	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("InputTrayTableXAxisMotorEncoder=%lf.",(double)InputTrayTableXAxisMotorEncoder);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("InputTrayTableYAxisMotorEncoder=%lf.", (double)InputTrayTableYAxisMotorEncoder);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerLoadPosition + 20=%lf.", (double)smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerLoadPosition + 20);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerLoadPosition + 20=%lf.", (double)smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerLoadPosition + 20);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerUnloadPosition + 20=%lf.", (double)smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerUnloadPosition + 20);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerUnloadPosition + 20=%lf.", (double)smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerUnloadPosition + 20);

		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Y Axis Motor not at stacker position");
		return false;
	}
	return true;
}
//not sure
bool CProductMotorControl::IsInputTrayTableZAxisMotorSafeToMoveRelative(signed long position)
{
	signed long InputTrayTableXAxisMotorEncoder = ReadInputTrayTableXAxisMotorEncoder();
	signed long InputTrayTableYAxisMotorEncoder = ReadInputTrayTableYAxisMotorEncoder();
	if (InputTrayTableXAxisMotorEncoder <= (smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerLoadPosition + 25)
		&& InputTrayTableXAxisMotorEncoder >= (smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerLoadPosition - 25)
		&& InputTrayTableYAxisMotorEncoder <= (smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerLoadPosition + 25)
		&& InputTrayTableYAxisMotorEncoder >= (smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerLoadPosition - 25))
	{

	}
	else if (InputTrayTableXAxisMotorEncoder <= (smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerUnloadPosition + 25)
		&& InputTrayTableXAxisMotorEncoder >= (smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerUnloadPosition - 25)
		&& InputTrayTableYAxisMotorEncoder <= (smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerUnloadPosition + 25)
		&& InputTrayTableYAxisMotorEncoder >= (smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerUnloadPosition - 25))
	{

	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("InputTrayTableXAxisMotorEncoder=%lf.", (double)InputTrayTableXAxisMotorEncoder);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("InputTrayTableYAxisMotorEncoder=%lf.", (double)InputTrayTableYAxisMotorEncoder);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerLoadPosition + 20=%lf.", (double)smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerLoadPosition + 20);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerLoadPosition + 20=%lf.", (double)smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerLoadPosition + 20);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerUnloadPosition + 20=%lf.", (double)smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerUnloadPosition + 20);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerUnloadPosition + 20=%lf.", (double)smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerUnloadPosition + 20);

		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Y Axis Motor not at stacker position");
		return false;
	}
	return true;
}
//not sure
bool CProductMotorControl::IsInputTrayTableZAxisMotorSafeToMoveAbsolute(signed long position)
{
	signed long InputTrayTableXAxisMotorEncoder = ReadInputTrayTableXAxisMotorEncoder();
	signed long InputTrayTableYAxisMotorEncoder = ReadInputTrayTableYAxisMotorEncoder();
	if (InputTrayTableXAxisMotorEncoder <= (smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerLoadPosition + 25)
		&& InputTrayTableXAxisMotorEncoder >= (smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerLoadPosition - 25)
		&& InputTrayTableYAxisMotorEncoder <= (smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerLoadPosition + 25)
		&& InputTrayTableYAxisMotorEncoder >= (smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerLoadPosition - 25))
	{

	}
	else if (InputTrayTableXAxisMotorEncoder <= (smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerUnloadPosition + 25)
		&& InputTrayTableXAxisMotorEncoder >= (smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerUnloadPosition - 25)
		&& InputTrayTableYAxisMotorEncoder <= (smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerUnloadPosition + 25)
		&& InputTrayTableYAxisMotorEncoder >= (smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerUnloadPosition - 25))
	{

	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("InputTrayTableXAxisMotorEncoder=%lf.", (double)InputTrayTableXAxisMotorEncoder);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("InputTrayTableYAxisMotorEncoder=%lf.", (double)InputTrayTableYAxisMotorEncoder);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerLoadPosition + 20=%lf.", (double)smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerLoadPosition + 20);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerLoadPosition + 20=%lf.", (double)smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerLoadPosition + 20);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerUnloadPosition + 20=%lf.", (double)smProductTeachPoint->InputTrayTableXAxisAtInputTrayStackerUnloadPosition + 20);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerUnloadPosition + 20=%lf.", (double)smProductTeachPoint->InputTrayTableYAxisAtInputTrayStackerUnloadPosition + 20);

		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Tray Table X Y Axis Motor not at stacker position");
		return false;
	}
	return true;
}
signed long CProductMotorControl::ReadInputTrayTableZAxisMotorEncoder()
{
	int nError = 0;
	signed long slPosition;
	return m_cMotion->GetEncoderPosition(m_motorConfiguration[3].Axis);
}

#pragma endregion

#pragma region Pick And Place 2 Y Axis
int CProductMotorControl::PickAndPlace2YAxisMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsPickAndPlace2YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(44001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsPickAndPlace2YAxisMotorHome = false;
	nError = cMotion->MotorOff(m_motorConfiguration[4].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2YAxisMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsPickAndPlace2YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(44001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorOn(m_motorConfiguration[4].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor on error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2YAxisMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2YAxisMotor == false)
	{
		m_cLogger->WriteLog("Pick And Place 2 Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Pick And Place 2 Y Axis motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->MotorStop(m_motorConfiguration[4].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 Y Axis motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 Y Axis motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->Reset(m_motorConfiguration[4].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 Y Axis motor reset done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 Y Axis motor reset error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2YAxisMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsPickAndPlace2YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(44001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace2YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(44010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not safe to move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis homing");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[4].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Pick And Place 2 Y Axis motor thread 0 %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//check again
	nError = cMotion->SetControllerVariable(m_motorConfiguration[4].ControllerDetails, "vPP2YHM", (signed long)0);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during reset Pick And Place 2 Y Axis home offset %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	smProductModuleStatus->IsPickAndPlace2YAxisMoving = true;
	nError = cMotion->MotorHomeAsychronous(m_motorConfiguration[4].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Pick And Place 2 Y Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor home start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor home start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			smProductModuleStatus->IsPickAndPlace2YAxisMotorHome = true;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor Home Done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace2YAxisMoving = false;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	if (smProductEvent->JobSlow.Set == true)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = cMotion->SetControllerVariable(m_motorConfiguration[4].ControllerDetails, "vSLOW", (signed long)1);
		if (nError == 0)
		{
			return 0;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during set all MC2 slow on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
	}
	else
	{
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2YAxisMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2YAxisMotor == false)
	{
		m_cLogger->WriteLog("Pick And Place 2 Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Pick And Place 2 Y Axis Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError += cMotion->SetControllerVariable(m_motorConfiguration[4].ControllerDetails, "vPP2YIP", (signed long)(((double)smProductTeachPoint->PickAndPlace2YAxisInputPosition) / m_motorConfiguration[4].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[4].ControllerDetails, "vPP2YS1", (signed long)(((double)smProductTeachPoint->PickAndPlace2YAxisAtS1AndBottomVisionPosition) / m_motorConfiguration[4].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[4].ControllerDetails, "vPP2YS3", (signed long)(((double)smProductTeachPoint->PickAndPlace2YAxisAtS2AndS3VisionPosition) / m_motorConfiguration[4].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[4].ControllerDetails, "vPP2YOP", (signed long)(((double)smProductTeachPoint->PickAndPlace2YAxisOutputPosition) / m_motorConfiguration[4].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[4].ControllerDetails, "vPP2YSBY", (signed long)(((double)smProductTeachPoint->PickAndPlace2YAxisStandbyPosition) / m_motorConfiguration[4].UnitInOnePulse));
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 Y Axis motor setting done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2YAxisMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorStop(m_motorConfiguration[4].Axis);
	//not sure
	sprintf_s(command, sizeof(command), "SPA=vSPA*(%u/100);ACA=vACA*(%u/100);DCA=vDCA*(%u/100);", speedPercent, accelerationPercent, accelerationPercent);
	nError = cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2YAxisMotorMoveToInputPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace2YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}

	if (smProductModuleStatus->IsPickAndPlace2YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(44005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace2YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(44001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace2YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(44010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis move to input position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace2YAxisMoving = true;
	if (smProductEvent->PickAndPlace2YAxisMotorMoveCurve.Set == true)
	{
		nError += cMotion->SetControllerVariable(m_motorConfiguration[4].ControllerDetails, "vPP2YEND", (signed long)(((double)smProductTeachPoint->PickAndPlace2YAxisStandbyPosition) / m_motorConfiguration[4].UnitInOnePulse));
		nError += cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, "XQ#AMCV,0");
	}
	else
		nError += cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, "XQ#AMIP,0");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 2 Y Axis motor move to input position %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor move input position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor move input position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace2YAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2YAxisMotorMoveToInputPositionCurve(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace2YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}

	if (smProductModuleStatus->IsPickAndPlace2YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(44005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace2YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(44001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace2YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(44010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis move to input position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace2YAxisMoving = true;
	if (smProductEvent->PickAndPlace2YAxisMotorMoveCurve.Set == true)
	{
		nError += cMotion->SetControllerVariable(m_motorConfiguration[4].ControllerDetails, "vPP2YEND", (signed long)(((double)smProductTeachPoint->PickAndPlace2YAxisInputPosition) / m_motorConfiguration[4].UnitInOnePulse));
		nError += cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, "XQ#AMCV,0");
	}
	else
		nError += cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, "XQ#AMIP,0");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 2 Y Axis motor move to input position %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor move input position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor move input position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace2YAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2YAxisMotorMoveToS1Position(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace2YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace2YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(44005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace2YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(44001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace2YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(44010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor move to S1 position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace2YAxisMoving = true;
	nError += cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, "XQ#AMS1,0");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 2 Y Axis motor move to S1 position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor move S1 position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor move S1 position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace2YAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2YAxisMotorMoveToS3Position(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace2YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace2YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(44005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace2YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(44001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace2YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(44010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor move to S3 Vision position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace2YAxisMoving = true;
	nError += cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, "XQ#AMS3,0");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 2 Y Axis motor move to S1 position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor move S3 position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor move S3 position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace2YAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2YAxisMotorMoveToOutputPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace2YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace2YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(44005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace2YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(44001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace2YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(44010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor move to output position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace2YAxisMoving = true;
	if (smProductEvent->PickAndPlace2YAxisMotorMoveCurve.Set == true)
	{
		nError += cMotion->SetControllerVariable(m_motorConfiguration[4].ControllerDetails, "vPP2YEND", (signed long)(((double)smProductTeachPoint->PickAndPlace2YAxisStandbyPosition) / m_motorConfiguration[4].UnitInOnePulse));
		nError += cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, "XQ#AMCV,0");
	}
	else
		nError += cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, "XQ#AMOP,0");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 2 Y Axis motor move to output position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor move output position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor move output position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace2YAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2YAxisMotorMoveToOutputPositionCurve(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace2YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace2YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(44005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace2YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(44001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace2YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(44010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor move to output position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace2YAxisMoving = true;
	if (smProductEvent->PickAndPlace2YAxisMotorMoveCurve.Set == true)
	{
		nError += cMotion->SetControllerVariable(m_motorConfiguration[4].ControllerDetails, "vPP2YEND", (signed long)(((double)smProductTeachPoint->PickAndPlace2YAxisOutputPosition) / m_motorConfiguration[4].UnitInOnePulse));
		nError += cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, "XQ#AMCV,0");
	}
	else
		nError += cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, "XQ#AMOP,0");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 2 Y Axis motor move to output position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor move output position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor move output position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace2YAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2YAxisMotorMoveToStandbyPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace2YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace2YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(44005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace2YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(44001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace2YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(44010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor move to standby position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace2YAxisMoving = true;
	nError += cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, "XQ#AMSBY,0");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 2 Y Axis motor move to standby position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor move standby position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor move standby position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace2YAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2YAxisMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsPickAndPlace2YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(44001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsPickAndPlace2YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(44005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace2YAxisMotorSafeToMoveRelative(movePos_um + smGeneral->nMotorEncoderPosition) == false)
	{
		m_cProductShareVariables->SetAlarm(44010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um + smGeneral->nMotorEncoderPosition > smProductTeachPoint->PickAndPlace2YAxisForwardLimitPosition ||
		movePos_um + smGeneral->nMotorEncoderPosition < smProductTeachPoint->PickAndPlace2YAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place Y2 Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place Y2 Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Y2 Axis move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[4].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place Y2 Axis motor send command stop thread %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//not sure
	smProductModuleStatus->IsPickAndPlace2YAxisMoving = true;
	sprintf_s(command, sizeof(command), "PRA=%u;BGA;AMA;", (int)((double)movePos_um / m_motorConfiguration[4].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis move relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		smProductModuleStatus->IsPickAndPlace2YAxisMoving = false;
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Y Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2YAxisMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsPickAndPlace2YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(44001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsPickAndPlace2YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(44005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace2YAxisMotorSafeToMoveAbsolute(movePos_um) == false)
	{
		m_cProductShareVariables->SetAlarm(44010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductEvent->GMAIN_RTHD_TEACHING_VISION.Set == true)
	{
		if (smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.InputStation)
		{
			if (movePos_um > smProductTeachPoint->PickAndPlace2XAxisInputPosition + (signed long)2000 ||
				movePos_um < smProductTeachPoint->PickAndPlace2XAxisInputPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 2 X Input Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
		else if (smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.BottomStation)
		{
			if (movePos_um > smProductTeachPoint->PickAndPlace2XAxisAtS1AndBottomVisionPosition + (signed long)2000 ||
				movePos_um < smProductTeachPoint->PickAndPlace2XAxisAtS1AndBottomVisionPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 2 X Bottom Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
		else if (smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.S3Station)
		{
			if (movePos_um > smProductTeachPoint->PickAndPlace2XAxisAtS2AndS3VisionPosition + (signed long)2000 ||
				movePos_um < smProductTeachPoint->PickAndPlace2XAxisAtS2AndS3VisionPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 2 X S3 Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
		else if (smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.OutputStation)
		{
			if (movePos_um > smProductTeachPoint->PickAndPlace2XAxisOutputPosition + (signed long)2000 ||
				movePos_um < smProductTeachPoint->PickAndPlace2XAxisOutputPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 2 X Output Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
	}
	if (movePos_um > smProductTeachPoint->PickAndPlace2YAxisForwardLimitPosition ||
		movePos_um < smProductTeachPoint->PickAndPlace2YAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 Y Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 2 Y Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[4].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Pick And Place 2 Y Axis motor thread 0 %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//not sure
	smProductModuleStatus->IsPickAndPlace2YAxisMoving = true;
	sprintf_s(command, sizeof(command), "PAA=%u;BGA;AMA;", (int)((double)movePos_um / m_motorConfiguration[4].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		smProductModuleStatus->IsPickAndPlace2YAxisMoving = false;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;

	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Y Axis move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2YAxisMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	if (smProductCustomize->EnablePickAndPlace2YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace2YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(44005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace2YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(44001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace2YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(44010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not Safe To Move.\n");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductProduction->PickAndPlace2YAxisMovePosition > smProductTeachPoint->PickAndPlace2YAxisForwardLimitPosition ||
		smProductProduction->PickAndPlace2YAxisMovePosition < smProductTeachPoint->PickAndPlace2YAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 Y Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cLogger->WriteLog("Position is out of Pick And Place 2 Y Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	if (smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.InputStation && smProductProduction->PickAndPlace2StationToMove != PickAndPlaceCurrentStation.BottomStation)
	{
		if (smProductProduction->PickAndPlace2YAxisMovePosition > smProductTeachPoint->PickAndPlace2YAxisInputPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace2YAxisMovePosition < smProductTeachPoint->PickAndPlace2YAxisInputPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 Y Input Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 2 Y Input Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if ((smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.BottomStation || smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.MovingFromInputStationToBottomStation)
		&& smProductProduction->PickAndPlace2StationToMove != PickAndPlaceCurrentStation.S3Station)
	{
		if (smProductProduction->PickAndPlace2YAxisMovePosition > smProductTeachPoint->PickAndPlace2YAxisAtS1AndBottomVisionPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace2YAxisMovePosition < smProductTeachPoint->PickAndPlace2YAxisAtS1AndBottomVisionPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 Y Bottom Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 2 Y Bottom Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if ((smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.S3Station || smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.MovingFromBottomStationToS3Station)
		&& smProductProduction->PickAndPlace2StationToMove != PickAndPlaceCurrentStation.OutputStation)
	{
		if (smProductProduction->PickAndPlace2YAxisMovePosition > smProductTeachPoint->PickAndPlace2YAxisAtS2AndS3VisionPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace2YAxisMovePosition < smProductTeachPoint->PickAndPlace2YAxisAtS2AndS3VisionPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 Y S3 Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 2 Y S3 Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if (smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.OutputStation && smProductProduction->PickAndPlace2StationToMove != PickAndPlaceCurrentStation.InputStation)
	{
		if (smProductProduction->PickAndPlace2YAxisMovePosition > smProductTeachPoint->PickAndPlace2YAxisOutputPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace2YAxisMovePosition < smProductTeachPoint->PickAndPlace2YAxisOutputPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 Y Output Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 2 Y Output Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}

	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	char command[80];
	smProductModuleStatus->IsPickAndPlace2YAxisMoving = true;
	if (smProductEvent->PickAndPlace2YAxisMotorMoveCurve.Set == true)
	{
		nError += cMotion->SetControllerVariable(m_motorConfiguration[4].ControllerDetails, "vPP2YEND", (signed long)(((double)smProductTeachPoint->PickAndPlace2YAxisStandbyPosition) / m_motorConfiguration[4].UnitInOnePulse));
		nError += cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, "XQ#AMCV,0");
	}
	else
	{
		sprintf_s(command, sizeof(command), "vPP2YPos=%u;XQ#AMV,0", (signed long)(((double)smProductProduction->PickAndPlace2YAxisMovePosition) / m_motorConfiguration[4].UnitInOnePulse));
	}
	nError += cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, command);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Pick And Place 2 Y Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor wait movement start3 timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			smProductModuleStatus->IsPickAndPlace2YAxisMoving = false;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2YAxisMotorMoveCurve(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	if (smProductCustomize->EnablePickAndPlace2YAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace2YAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(44005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace2YAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(44001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace2YAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(44010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor not Safe To Move.\n");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductProduction->PickAndPlace2YAxisMovePosition > smProductTeachPoint->PickAndPlace2YAxisForwardLimitPosition ||
		smProductProduction->PickAndPlace2YAxisMovePosition < smProductTeachPoint->PickAndPlace2YAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 Y Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cLogger->WriteLog("Position is out of Pick And Place 2 Y Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	if (smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.InputStation && smProductProduction->PickAndPlace2StationToMove != PickAndPlaceCurrentStation.BottomStation)
	{
		if (smProductProduction->PickAndPlace2YAxisMovePosition > smProductTeachPoint->PickAndPlace2YAxisInputPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace2YAxisMovePosition < smProductTeachPoint->PickAndPlace2YAxisInputPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 Y Input Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 2 Y Input Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if ((smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.BottomStation || smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.MovingFromInputStationToBottomStation)
		&& smProductProduction->PickAndPlace2StationToMove != PickAndPlaceCurrentStation.S3Station)
	{
		if (smProductProduction->PickAndPlace2YAxisMovePosition > smProductTeachPoint->PickAndPlace2YAxisAtS1AndBottomVisionPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace2YAxisMovePosition < smProductTeachPoint->PickAndPlace2YAxisAtS1AndBottomVisionPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 Y Bottom Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 2 Y Bottom Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if ((smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.S3Station || smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.MovingFromBottomStationToS3Station)
		&& smProductProduction->PickAndPlace2StationToMove != PickAndPlaceCurrentStation.OutputStation)
	{
		if (smProductProduction->PickAndPlace2YAxisMovePosition > smProductTeachPoint->PickAndPlace2YAxisAtS2AndS3VisionPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace2YAxisMovePosition < smProductTeachPoint->PickAndPlace2YAxisAtS2AndS3VisionPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 Y S3 Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 2 Y S3 Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if (smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.OutputStation && smProductProduction->PickAndPlace2StationToMove != PickAndPlaceCurrentStation.InputStation)
	{
		if (smProductProduction->PickAndPlace2YAxisMovePosition > smProductTeachPoint->PickAndPlace2YAxisOutputPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace2YAxisMovePosition < smProductTeachPoint->PickAndPlace2YAxisOutputPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 Y Output Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 2 Y Output Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}

	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	char command[80];
	smProductModuleStatus->IsPickAndPlace2YAxisMoving = true;
	if (smProductEvent->PickAndPlace2YAxisMotorMoveCurve.Set == true)
	{
		nError += cMotion->SetControllerVariable(m_motorConfiguration[4].ControllerDetails, "vPP2YEND", (signed long)(((double)smProductProduction->PickAndPlace2YAxisMovePosition) / m_motorConfiguration[4].UnitInOnePulse));
		nError += cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, "XQ#AMCV,0");
	}
	else
	{
		sprintf_s(command, sizeof(command), "vPP2YPos=%u;XQ#AMV,0", (signed long)(((double)smProductProduction->PickAndPlace2YAxisMovePosition) / m_motorConfiguration[4].UnitInOnePulse));
	}
	nError += cMotion->SendCommand(m_motorConfiguration[4].ControllerDetails, command);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Pick And Place 2 Y Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor wait movement start3 timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2YAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			smProductModuleStatus->IsPickAndPlace2YAxisMoving = false;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis motor done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(44002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
//not sure
bool CProductMotorControl::IsPickAndPlace2YAxisMotorSafeToMove()
{
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis not homing yet");
		return false;
	}
	////if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
	////	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
	////{
	////	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis not at up position");
	////	return false;
	////}
	//if (smProductProduction->PickAndPlace2YAxisMovePosition + ReadSidewallVisionFrontModuleMotorEncoder() > 20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis will collide with Side wall vision front module");
	//	return false;
	//}
	////if (smProductProduction->PickAndPlace2YAxisMovePosition + smProductProduction->SidewallVisionFrontModuleMovePosition > 20000)
	////{
	////	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis will collide with Side wall vision front module");
	////	return false;
	////}
	//if (smProductProduction->PickAndPlace2YAxisMovePosition + ReadSidewallVisionRightModuleMotorEncoder() > 20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis will collide with Side Wall Vision right Module");
	//	return false;
	//}
	////if (smProductProduction->PickAndPlace2YAxisMovePosition + smProductProduction->SidewallVisionRightModuleMovePosition > 20000)
	////{
	////	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis will collide with Side wall vision right module");
	////	return false;
	////}
	return true;
}
//not sure
bool CProductMotorControl::IsPickAndPlace2YAxisMotorSafeToMoveRelative(signed long position)
{
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis not homing yet");
		return false;
	}
	////if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
	////	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
	////{
	////	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis not at up position");
	////	return false;
	////}
	//if (position + ReadSidewallVisionFrontModuleMotorEncoder() > 20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis will collide with Side wall vision front module");
	//	return false;
	//}
	////if (position + smProductProduction->SidewallVisionFrontModuleMovePosition > 20000)
	////{
	////	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis will collide with Side wall vision front module");
	////	return false;
	////}
	//if (position + ReadSidewallVisionRightModuleMotorEncoder() > 20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis will collide with Side Wall Vision right Module");
	//	return false;
	//}
	////if (position + smProductProduction->SidewallVisionRightModuleMovePosition > 20000)
	////{
	////	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis will collide with Side wall vision right module");
	////	return false;
	////}
	return true;
}
//not sure
bool CProductMotorControl::IsPickAndPlace2YAxisMotorSafeToMoveAbsolute(signed long position)
{
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis not homing yet");
		return false;
	}
	////if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
	////	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
	////{
	////	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis not at up position");
	////	return false;
	////}
	//if (position + ReadSidewallVisionFrontModuleMotorEncoder() > 20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis will collide with Side wall vision front module");
	//	return false;
	//}
	////if (position + smProductProduction->SidewallVisionFrontModuleMovePosition > 20000)
	////{
	////	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis will collide with Side wall vision front module");
	////	return false;
	////}
	//if (position + ReadSidewallVisionRightModuleMotorEncoder() > 20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis will collide with Side Wall Vision right Module");
	//	return false;
	//}
	////if (position + smProductProduction->SidewallVisionRightModuleMovePosition > 20000)
	////{
	////	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis will collide with Side wall vision right module");
	////	return false;
	////}
	return true;
}
signed long CProductMotorControl::ReadPickAndPlace2YAxisMotorEncoder()
{
	int nError = 0;
	signed long slPosition;
	return m_cMotion->GetEncoderPosition(m_motorConfiguration[4].Axis);
}
#pragma endregion

#pragma region Output Tray Table X Axis Motor
int CProductMotorControl::OutputTrayTableXAxisMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsOutputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(45001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsOutputTrayTableXAxisMotorHome = false;
	nError = cMotion->MotorOff(m_motorConfiguration[5].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableXAxisMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsOutputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(45001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorOn(m_motorConfiguration[5].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor on error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableXAxisMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == false)
	{
		m_cLogger->WriteLog("Output Tray Table X Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Output Tray Table X Axis motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->MotorStop(m_motorConfiguration[5].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Output Tray Table X Axis motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Output Tray Table X Axis motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->Reset(m_motorConfiguration[5].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Output Tray Table X Axis motor reset done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Output Tray Table X Axis motor reset error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableXAxisMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsOutputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(45001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsOutputTrayTableXAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(45010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis homing");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[5].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Output Tray Table X Axis motor thread 0 %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	nError = cMotion->SetControllerVariable(m_motorConfiguration[5].ControllerDetails, "vOTTXHM", (signed long)0);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during reset Output Tray Table X Axis home offset %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	nError = cMotion->MotorHomeAsychronous(m_motorConfiguration[5].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Output Tray Table X Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor home start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(45004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor home start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == true)
		{
			smProductModuleStatus->IsOutputTrayTableXAxisMotorHome = true;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor home done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(45004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	if (smProductEvent->JobSlow.Set == true)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = cMotion->SetControllerVariable(m_motorConfiguration[5].ControllerDetails, "vSLOW", (signed long)1);
		if (nError == 0)
		{
			return 0;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during set all MC2 slow on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
	}
	else
	{
		return 0;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableXAxisMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == false)
	{
		m_cLogger->WriteLog("Output Tray Table X Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Output Tray Table X Axis Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError += cMotion->SetControllerVariable(m_motorConfiguration[5].ControllerDetails, "vOTTXLD", (signed long)(((double)smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayStackerLoadPosition) / m_motorConfiguration[5].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[5].ControllerDetails, "vOTTXUL", (signed long)(((double)smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayStackerUnloadPosition) / m_motorConfiguration[5].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[5].ControllerDetails, "vOTTXCN", (signed long)(((double)smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayTableCenterPosition) / m_motorConfiguration[5].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[5].ControllerDetails, "vOTTXMN", (signed long)(((double)smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayTableManualLoadUnloadPosition) / m_motorConfiguration[5].UnitInOnePulse));
	/*nError += cMotion->SetControllerVariable(m_motorConfiguration[5].ControllerDetails, "vOTTXRJ1", (signed long)(((double)smProductTeachPoint->OutputTrayTableXAxisAtRejectTray1CenterPosition) / m_motorConfiguration[5].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[5].ControllerDetails, "vOTTXRJ2", (signed long)(((double)smProductTeachPoint->OutputTrayTableXAxisAtRejectTray2CenterPosition) / m_motorConfiguration[5].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[5].ControllerDetails, "vOTTXRJ3", (signed long)(((double)smProductTeachPoint->OutputTrayTableXAxisAtRejectTray3CenterPosition) / m_motorConfiguration[5].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[5].ControllerDetails, "vOTTXRJ4", (signed long)(((double)smProductTeachPoint->OutputTrayTableXAxisAtRejectTray4CenterPosition) / m_motorConfiguration[5].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[5].ControllerDetails, "vOTTXRJ5", (signed long)(((double)smProductTeachPoint->OutputTrayTableXAxisAtRejectTray5CenterPosition) / m_motorConfiguration[5].UnitInOnePulse));
	//nError += cMotion->SetControllerVariable(m_motorConfiguration[5].ControllerDetails, "vOTTXOPVCB", (signed long)(((double)smProductTeachPoint->OutputTrayTableXAxisAtOutputOPVCalibrationPosition) / m_motorConfiguration[5].UnitInOnePulse));*/

	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Output Tray Table X Axis motor setting done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableXAxisMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorStop(m_motorConfiguration[5].Axis);
	//not sure
	sprintf_s(command, sizeof(command), "SPB=vSPB*(%u/100);ACB=vACB*(%u/100);DCB=vDCB*(%u/100);", speedPercent, accelerationPercent, accelerationPercent);
	nError = cMotion->SendCommand(m_motorConfiguration[5].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableXAxisMotorMoveLoad(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(45005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(45001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsOutputTrayTableXAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(45010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move to load position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[5].ControllerDetails, "XQ#BMLD,1");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Output Tray Table X Axis motor move to load position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move load position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(45003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move load position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(45002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableXAxisMotorMoveUnload(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(45005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(45001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsOutputTrayTableXAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(45010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move to unload position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[5].ControllerDetails, "XQ#BMUL,1");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Output Tray Table X Axis motor move to unload position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move unload position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(45003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move unload position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(45002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableXAxisMotorMoveCenter(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(45005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(45001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsOutputTrayTableXAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(45010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move to center position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[5].ControllerDetails, "XQ#BMCN,1");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Output Tray Table X Axis motor move to center position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move center position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(45003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move center position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(45002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableXAxisMotorMoveRejectTrayCenter(CMotionLibrary *cMotion, int TrayNo)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(45005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(45001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsOutputTrayTableXAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(45010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move to reject tray %d center position", TrayNo);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	sprintf_s(command, sizeof(command), "XQ#BMRJ%d,1", TrayNo);
	nError += cMotion->SendCommand(m_motorConfiguration[5].ControllerDetails, command);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Output Tray Table X Axis motor move to reject tray %d center position %u", TrayNo, nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move to reject tray %d center position start %ums.", TrayNo, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(45003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move to reject tray %d center position done %ums.", TrayNo, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(45002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableXAxisMotorMoveManualLoadUnload(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(45005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(45001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsOutputTrayTableXAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(45010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move to manual load unload position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[5].ControllerDetails, "XQ#BMMN,1");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Output Tray Table X Axis motor move to manual load unload position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move manual load unload position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(45003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move manual load unload position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(45002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableXAxisMotorMoveOutputOPVCalibrationPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(45005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(45001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsOutputTrayTableXAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(45010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move to Output OPV Calibration position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[5].ControllerDetails, "XQ#BMOPVCB,1");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Output Tray Table X Axis motor move to Output OPV Calibration position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move Output OPV Calibration position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(45003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor move Output OPV Calibration position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(45002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableXAxisMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsOutputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(45001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsOutputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(45005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsOutputTrayTableXAxisMotorSafeToMoveRelative(movePos_um + smGeneral->nMotorEncoderPosition) == false)
	{
		m_cProductShareVariables->SetAlarm(45010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um + smGeneral->nMotorEncoderPosition > smProductTeachPoint->OutputTrayTableXAxisForwardLimitPosition ||
		movePos_um + smGeneral->nMotorEncoderPosition < smProductTeachPoint->OutputTrayTableXAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Output Tray Table X Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Output Tray Table X Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[5].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table X Axis motor send command stop thread %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//not sure
	sprintf_s(command, sizeof(command), "PRB=%u;BGB;AMB;", (int)((double)movePos_um / m_motorConfiguration[5].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[5].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis move relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table X Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableXAxisMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsOutputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(45001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsOutputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(45005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsOutputTrayTableXAxisMotorSafeToMoveAbsolute(movePos_um) == false)
	{
		m_cProductShareVariables->SetAlarm(45010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um > smProductTeachPoint->OutputTrayTableXAxisForwardLimitPosition ||
		movePos_um < smProductTeachPoint->OutputTrayTableXAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Output Tray Table X Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Output Tray Table X Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[5].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Output Tray Table X Axis motor thread 0 %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//not sure
	sprintf_s(command, sizeof(command), "PAB=%u;BGB;AMB;", (int)((double)movePos_um / m_motorConfiguration[5].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[5].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table X Axis move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableXAxisMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	if (smProductCustomize->EnableOutputTrayTableXAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableXAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(45005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableXAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(45001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	/*if (IsOutputTrayTableXAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(45010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}*/
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsOutputTrayTableXAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(45010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}
	}
	if (smProductProduction->OutputTrayTableXAxisMovePosition > smProductTeachPoint->OutputTrayTableXAxisForwardLimitPosition ||
		smProductProduction->OutputTrayTableXAxisMovePosition < smProductTeachPoint->OutputTrayTableXAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Output Tray Table X Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cLogger->WriteLog("Position is out of Output Tray Table X Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == true)
		{
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	char command[80];
	//not sure
	sprintf_s(command, sizeof(command), "vOTTXPos=%u;XQ#BMV,1", (signed long)(((double)smProductProduction->OutputTrayTableXAxisMovePosition) / m_motorConfiguration[5].UnitInOnePulse));
	nError += cMotion->SendCommand(m_motorConfiguration[5].ControllerDetails, command);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Output Tray Table X Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(45003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor wait movement start3 timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis motor done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(45002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
//not sure
bool CProductMotorControl::IsOutputTrayTableXAxisMotorSafeToMove()
{
	signed long OutputTrayTableZAxisMotorEncoder = ReadOutputTrayTableZAxisMotorEncoder();
	signed long ZAxisLimit = 0;
	if (smProductModuleStatus->IsOutputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis not yet homing.");
		return false;
	}
	//1.0.0.c Thor
	if (smProductTeachPoint->OutputTrayTableZAxisDownPosition > 0)
	{
		ZAxisLimit = smProductTeachPoint->OutputTrayTableZAxisDownPosition;
	}
	else
	{
		ZAxisLimit = 0;
	}
	//if (OutputTrayTableZAxisMotorEncoder != smProductTeachPoint->OutputTrayTableZAxisDownPosition
	//	&& OutputTrayTableZAxisMotorEncoder > smProductTeachPoint->OutputTrayTableZAxisDownPosition + m_motorConfiguration[6].AxisInPositionToleranceInUnitPulse)
	if (OutputTrayTableZAxisMotorEncoder != ZAxisLimit
		&& OutputTrayTableZAxisMotorEncoder > ZAxisLimit + m_motorConfiguration[7].AxisInPositionToleranceInUnitPulse)
		//--
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis At Above Safety Position.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace1ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace1ZAxisUpPosition
		//	&& ReadPickAndPlace1ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace1ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not Homing yet.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
		//	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not Homing yet.\n");
		return false;
	}
	return true;
}
//not sure
bool CProductMotorControl::IsOutputTrayTableXAxisMotorSafeToMoveRelative(signed long position)
{
	signed long OutputTrayTableZAxisMotorEncoder = ReadOutputTrayTableZAxisMotorEncoder();
	signed long ZAxisLimit = 0;
	if (smProductModuleStatus->IsOutputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis not yet homing.");
		return false;
	}
	//1.0.0.c Thor
	if (smProductTeachPoint->OutputTrayTableZAxisDownPosition > 0)
	{
		ZAxisLimit = smProductTeachPoint->OutputTrayTableZAxisDownPosition;
	}
	else
	{
		ZAxisLimit = 0;
	}
	//if (OutputTrayTableZAxisMotorEncoder != smProductTeachPoint->OutputTrayTableZAxisDownPosition
	//	&& OutputTrayTableZAxisMotorEncoder > smProductTeachPoint->OutputTrayTableZAxisDownPosition + m_motorConfiguration[6].AxisInPositionToleranceInUnitPulse)
	if (OutputTrayTableZAxisMotorEncoder != ZAxisLimit
		&& OutputTrayTableZAxisMotorEncoder > ZAxisLimit + m_motorConfiguration[7].AxisInPositionToleranceInUnitPulse)
		//--
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis At Above Safety Position.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace1ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace1ZAxisUpPosition
		//	&& ReadPickAndPlace1ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace1ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not Homing yet.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
		//	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not Homing yet.\n");
		return false;
	}
	return true;
}
//not sure
bool CProductMotorControl::IsOutputTrayTableXAxisMotorSafeToMoveAbsolute(signed long position)
{
	signed long OutputTrayTableZAxisMotorEncoder = ReadOutputTrayTableZAxisMotorEncoder();
	signed long ZAxisLimit = 0;
	if (smProductModuleStatus->IsOutputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis not yet homing.");
		return false;
	}
	//1.0.0.c Thor
	if (smProductTeachPoint->OutputTrayTableZAxisDownPosition > 0)
	{
		ZAxisLimit = smProductTeachPoint->OutputTrayTableZAxisDownPosition;
	}
	else
	{
		ZAxisLimit = 0;
	}
	//if (OutputTrayTableZAxisMotorEncoder != smProductTeachPoint->OutputTrayTableZAxisDownPosition
	//	&& OutputTrayTableZAxisMotorEncoder > smProductTeachPoint->OutputTrayTableZAxisDownPosition + m_motorConfiguration[6].AxisInPositionToleranceInUnitPulse)
	if (OutputTrayTableZAxisMotorEncoder != ZAxisLimit
		&& OutputTrayTableZAxisMotorEncoder > ZAxisLimit + m_motorConfiguration[7].AxisInPositionToleranceInUnitPulse)
		//--
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis At Above Safety Position.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace1ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace1ZAxisUpPosition
		//	&& ReadPickAndPlace1ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace1ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not Homing yet.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
		//	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not Homing yet.\n");
		return false;
	}
	return true;
}
signed long CProductMotorControl::ReadOutputTrayTableXAxisMotorEncoder()
{
	int nError = 0;
	signed long slPosition;
	return m_cMotion->GetEncoderPosition(m_motorConfiguration[5].Axis);
}
#pragma endregion

#pragma region Output Tray Table Y Axis
int CProductMotorControl::OutputTrayTableYAxisMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsOutputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(46001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsOutputTrayTableYAxisMotorHome = false;
	nError = cMotion->MotorOff(m_motorConfiguration[6].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableYAxisMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsOutputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(46001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorOn(m_motorConfiguration[6].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor on error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableYAxisMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == false)
	{
		m_cLogger->WriteLog("Output Tray Table Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Output Tray Table Y Axis motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->MotorStop(m_motorConfiguration[6].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Output Tray Table Y Axis motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Output Tray Table Y Axis motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->Reset(m_motorConfiguration[6].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Output Tray Table Y Axis motor reset done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Output Tray Table Y Axis motor reset error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableYAxisMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsOutputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(46001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsOutputTrayTableYAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(46010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not safe to move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis homing");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[6].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Output Tray Table Y Axis motor thread 0 %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//check
	nError = cMotion->SetControllerVariable(m_motorConfiguration[6].ControllerDetails, "vOTTYHM", (signed long)0);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during reset Output Tray Table Y Axis home offset %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	nError = cMotion->MotorHomeAsychronous(m_motorConfiguration[6].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Output Tray Table Y Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor home start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(46004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor home start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == true)
		{
			smProductModuleStatus->IsOutputTrayTableYAxisMotorHome = true;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor home done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(46004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	if (smProductEvent->JobSlow.Set == true)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = cMotion->SetControllerVariable(m_motorConfiguration[6].ControllerDetails, "vSLOW", (signed long)1);
		if (nError == 0)
		{
			return 0;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during set all MC2 slow on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
	}
	else
	{
		return 0;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableYAxisMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == false)
	{
		m_cLogger->WriteLog("Output Tray Table Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Output Tray Table Y Axis Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError += cMotion->SetControllerVariable(m_motorConfiguration[6].ControllerDetails, "vOTTYLD", (signed long)(((double)smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayStackerLoadPosition) / m_motorConfiguration[6].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[6].ControllerDetails, "vOTTYUL", (signed long)(((double)smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayStackerUnloadPosition) / m_motorConfiguration[6].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[6].ControllerDetails, "vOTTYCN", (signed long)(((double)smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayTableCenterPosition) / m_motorConfiguration[6].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[6].ControllerDetails, "vOTTYMN", (signed long)(((double)smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayTableManualLoadUnloadPosition) / m_motorConfiguration[6].UnitInOnePulse));
	/*nError += cMotion->SetControllerVariable(m_motorConfiguration[6].ControllerDetails, "vOTTYRJ1", (signed long)(((double)smProductTeachPoint->OutputTrayTableYAxisAtRejectTray1CenterPosition) / m_motorConfiguration[6].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[6].ControllerDetails, "vOTTYRJ2", (signed long)(((double)smProductTeachPoint->OutputTrayTableYAxisAtRejectTray2CenterPosition) / m_motorConfiguration[6].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[6].ControllerDetails, "vOTTYRJ3", (signed long)(((double)smProductTeachPoint->OutputTrayTableYAxisAtRejectTray3CenterPosition) / m_motorConfiguration[6].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[6].ControllerDetails, "vOTTYRJ4", (signed long)(((double)smProductTeachPoint->OutputTrayTableYAxisAtRejectTray4CenterPosition) / m_motorConfiguration[6].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[6].ControllerDetails, "vOTTYRJ5", (signed long)(((double)smProductTeachPoint->OutputTrayTableYAxisAtRejectTray5CenterPosition) / m_motorConfiguration[6].UnitInOnePulse));*/
	//nError += cMotion->SetControllerVariable(m_motorConfiguration[6].ControllerDetails, "vOTTYOPVCB", (signed long)(((double)smProductTeachPoint->OutputTrayTableYAxisAtOutputOPVCalibrationPosition) / m_motorConfiguration[6].UnitInOnePulse));
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Output Tray Table Y Axis motor setting done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableYAxisMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorStop(m_motorConfiguration[6].Axis);
	//not sure
	sprintf_s(command, sizeof(command), "SPC=vSPC*(%u/100);ACC=vACC*(%u/100);DCC=vDCC*(%u/100);", speedPercent, accelerationPercent, accelerationPercent);
	nError = cMotion->SendCommand(m_motorConfiguration[6].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableYAxisMotorMoveLoad(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableYAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(46005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(46001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsOutputTrayTableYAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(46010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move to load position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[6].ControllerDetails, "XQ#CMLD,2");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Output Tray Table Y Axis motor move to load position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move load position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(46003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move load position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(46002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableYAxisMotorMoveUnload(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableYAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(46005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(46001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsOutputTrayTableYAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(46010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move to unload position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[6].ControllerDetails, "XQ#CMUL,2");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Output Tray Table Y Axis motor move to unload position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableXAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move unload position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(46003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move unload position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(46002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableYAxisMotorMoveCenter(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableYAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(46005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(46001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsOutputTrayTableYAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(46010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move to center position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[6].ControllerDetails, "XQ#CMCN,2");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Output Tray Table Y Axis motor move to center position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move center position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(46003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move center position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(46002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableYAxisMotorMoveRejectTrayCenter(CMotionLibrary *cMotion, int TrayNo)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableYAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(46005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(46001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsOutputTrayTableYAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(46010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move to reject tray %d center position", TrayNo);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	sprintf_s(command, sizeof(command), "XQ#CMRJ%d,2", TrayNo);
	nError += cMotion->SendCommand(m_motorConfiguration[6].ControllerDetails, command);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Output Tray Table Y Axis motor move to reject tray %d center position %u", TrayNo, nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move reject tray %d center position start %ums.", TrayNo, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(46003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move reject tray %d center position done %ums.", TrayNo, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(46002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableYAxisMotorMoveManualLoadUnload(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableYAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(46005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(46001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsOutputTrayTableYAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(46010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move to manual load unload position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[6].ControllerDetails, "XQ#CMMN,2");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Output Tray Table Y Axis motor move to manual load unload position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move to manual load unload position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(46003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move to manual load unload position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(46002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableYAxisMotorMoveOutputOPVCalibrationPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableYAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(46005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(46001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsOutputTrayTableYAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(46010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move to output OPV calibration position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[6].ControllerDetails, "XQ#CMOPVCB,2");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Output Tray Table Y Axis motor move to output OPV calibration position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move to output OPV calibration position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(46003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor move to output OPV calibration position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(46002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableYAxisMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsOutputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(46001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsOutputTrayTableYAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(46005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsOutputTrayTableYAxisMotorSafeToMoveRelative(movePos_um + smGeneral->nMotorEncoderPosition) == false)
	{
		m_cProductShareVariables->SetAlarm(46010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um + smGeneral->nMotorEncoderPosition > smProductTeachPoint->OutputTrayTableYAxisForwardLimitPosition ||
		movePos_um + smGeneral->nMotorEncoderPosition < smProductTeachPoint->OutputTrayTableYAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Output Tray Table Y Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Output Tray Table Y Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[6].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Y Axis motor send command stop thread %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//not sure
	sprintf_s(command, sizeof(command), "PRC=%u;BGC;AMC;", (int)((double)movePos_um / m_motorConfiguration[6].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[6].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis move relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Y Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableYAxisMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsOutputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(46001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsOutputTrayTableYAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(46005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsOutputTrayTableYAxisMotorSafeToMoveAbsolute(movePos_um) == false)
	{
		m_cProductShareVariables->SetAlarm(46010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um > smProductTeachPoint->OutputTrayTableYAxisForwardLimitPosition ||
		movePos_um < smProductTeachPoint->OutputTrayTableYAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Output Tray Table Y Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Output Tray Table Y Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[6].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Output Tray Table Y Axis motor thread 0 %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//not sure
	sprintf_s(command, sizeof(command), "PAC=%u;BGC;AMC;", (int)((double)movePos_um / m_motorConfiguration[6].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[6].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Y Axis move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableYAxisMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	if (smProductCustomize->EnableOutputTrayTableYAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableYAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(46005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableYAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(46001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductProduction->OutputTrayTableYAxisMovePosition > smProductTeachPoint->OutputTrayTableYAxisForwardLimitPosition ||
		smProductProduction->OutputTrayTableYAxisMovePosition < smProductTeachPoint->OutputTrayTableYAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Output Tray Table Y Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cLogger->WriteLog("Position is out of Output Tray Table Y Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	/*if (IsOutputTrayTableYAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(46010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}*/
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsOutputTrayTableXAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(46010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == true)
		{
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	char command[80];
	//not sure
	sprintf_s(command, sizeof(command), "vOTTYPos=%u;XQ#CMV,2", (signed long)(((double)smProductProduction->OutputTrayTableYAxisMovePosition) / m_motorConfiguration[6].UnitInOnePulse));
	nError += cMotion->SendCommand(m_motorConfiguration[6].ControllerDetails, command);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during move Output Tray Table Y Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(46003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor wait movement start3 timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableYAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis motor done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(46002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Y Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
//not sure
bool CProductMotorControl::IsOutputTrayTableYAxisMotorSafeToMove()
{
	signed long OutputTrayTableZAxisMotorEncoder = ReadOutputTrayTableZAxisMotorEncoder();
	signed long ZAxisLimit = 0;
	if (smProductModuleStatus->IsOutputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis not yet homing.");
		return false;
	}
	//1.0.0.c Thor
	if (smProductTeachPoint->OutputTrayTableZAxisDownPosition > 0)
	{
		ZAxisLimit = smProductTeachPoint->OutputTrayTableZAxisDownPosition;
	}
	else
	{
		ZAxisLimit = 0;
	}
	//if (OutputTrayTableZAxisMotorEncoder != smProductTeachPoint->OutputTrayTableZAxisDownPosition
	//	&& OutputTrayTableZAxisMotorEncoder > smProductTeachPoint->OutputTrayTableZAxisDownPosition + m_motorConfiguration[6].AxisInPositionToleranceInUnitPulse)
	if (OutputTrayTableZAxisMotorEncoder != ZAxisLimit
		&& OutputTrayTableZAxisMotorEncoder > ZAxisLimit + m_motorConfiguration[7].AxisInPositionToleranceInUnitPulse)
	//--
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis At Above Safety Position.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace1ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace1ZAxisUpPosition
		//	&& ReadPickAndPlace1ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace1ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not Homing yet.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
		//	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not Homing yet.\n");
		return false;
	}
	return true;
}
//not sure
bool CProductMotorControl::IsOutputTrayTableYAxisMotorSafeToMoveRelative(signed long position)
{
	signed long OutputTrayTableZAxisMotorEncoder = ReadOutputTrayTableZAxisMotorEncoder();
	signed long ZAxisLimit = 0;
	if (smProductModuleStatus->IsOutputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis not yet homing.");
		return false;
	}
	//1.0.0.c Thor
	if (smProductTeachPoint->OutputTrayTableZAxisDownPosition > 0)
	{
		ZAxisLimit = smProductTeachPoint->OutputTrayTableZAxisDownPosition;
	}
	else
	{
		ZAxisLimit = 0;
	}
	//if (OutputTrayTableZAxisMotorEncoder != smProductTeachPoint->OutputTrayTableZAxisDownPosition
	//	&& OutputTrayTableZAxisMotorEncoder > smProductTeachPoint->OutputTrayTableZAxisDownPosition + m_motorConfiguration[6].AxisInPositionToleranceInUnitPulse)
	if (OutputTrayTableZAxisMotorEncoder != ZAxisLimit
		&& OutputTrayTableZAxisMotorEncoder > ZAxisLimit + m_motorConfiguration[7].AxisInPositionToleranceInUnitPulse)
		//--
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis At Above Safety Position.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace1ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace1ZAxisUpPosition
		//	&& ReadPickAndPlace1ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace1ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not Homing yet.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
		//	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not Homing yet.\n");
		return false;
	}
	return true;
}
//not sure
bool CProductMotorControl::IsOutputTrayTableYAxisMotorSafeToMoveAbsolute(signed long position)
{
	signed long OutputTrayTableZAxisMotorEncoder = ReadOutputTrayTableZAxisMotorEncoder();
	signed long ZAxisLimit = 0;
	if (smProductModuleStatus->IsOutputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis not yet homing.");
		return false;
	}
	//1.0.0.c Thor
	if (smProductTeachPoint->OutputTrayTableZAxisDownPosition > 0)
	{
		ZAxisLimit = smProductTeachPoint->OutputTrayTableZAxisDownPosition;
	}
	else
	{
		ZAxisLimit = 0;
	}
	//if (OutputTrayTableZAxisMotorEncoder != smProductTeachPoint->OutputTrayTableZAxisDownPosition
	//	&& OutputTrayTableZAxisMotorEncoder > smProductTeachPoint->OutputTrayTableZAxisDownPosition + m_motorConfiguration[6].AxisInPositionToleranceInUnitPulse)
	if (OutputTrayTableZAxisMotorEncoder != ZAxisLimit
		&& OutputTrayTableZAxisMotorEncoder > ZAxisLimit + m_motorConfiguration[7].AxisInPositionToleranceInUnitPulse)
		//--
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis At Above Safety Position.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace1ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace1ZAxisUpPosition
		//	&& ReadPickAndPlace1ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace1ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 1 Z Axis Not Homing yet.\n");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == true)
	{
		//if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
		//	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not At Up Position.\n");
		//	return false;
		//}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog(" Pick And Place 2 Z Axis Not Homing yet.\n");
		return false;
	}
	return true;
}
signed long CProductMotorControl::ReadOutputTrayTableYAxisMotorEncoder()
{
	int nError = 0;
	signed long slPosition;
	return m_cMotion->GetEncoderPosition(m_motorConfiguration[6].Axis);
}
#pragma endregion 

#pragma region Output Tray Table Z Axis
int CProductMotorControl::OutputTrayTableZAxisMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsOutputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(47001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsOutputTrayTableZAxisMotorHome = false;
	nError = cMotion->MotorOff(m_motorConfiguration[7].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableZAxisMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsOutputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(47001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorOn(m_motorConfiguration[7].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor on error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableZAxisMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableZAxisMotor == false)
	{
		m_cLogger->WriteLog("Output Tray Table Z Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}

	m_cLogger->WriteLog("Output Tray Table Z Axis motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->MotorStop(m_motorConfiguration[7].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Output Tray Table Z Axis motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Output Tray Table Z Axis motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->Reset(m_motorConfiguration[7].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Output Tray Table Z Axis motor reset done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Output Tray Table Z Axis motor reset error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableZAxisMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsOutputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(47001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	//if (IsOutputTrayTableZAxisMotorSafeToMove() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(47010);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not safe to move.");
	//	return m_cProductShareVariables->Error_MotorNotSafeToMove;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis homing");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[7].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Output Tray Table Z Axis motor thread 0 %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	nError = cMotion->SetControllerVariable(m_motorConfiguration[7].ControllerDetails, "vOTTZHM", (signed long)0);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during reset Output Tray Table Z Axis home offset %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	nError = cMotion->MotorHomeAsychronous(m_motorConfiguration[7].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Output Tray Table Z Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableZAxisMotorInPosition() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor home start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(47004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor home start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableZAxisMotorInPosition() == true)
		{
			smProductModuleStatus->IsOutputTrayTableZAxisMotorHome = true;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor home done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(47004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	if (smProductEvent->JobSlow.Set == true)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = cMotion->SetControllerVariable(m_motorConfiguration[7].ControllerDetails, "vSLOW", (signed long)1);
		if (nError == 0)
		{
			return 0;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during set all MC2 slow on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
	}
	else
	{
		return 0;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableZAxisMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableZAxisMotor == false)
	{
		m_cLogger->WriteLog("Output Tray Table Z Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Output Tray Table Z Axis Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError += cMotion->SetControllerVariable(m_motorConfiguration[7].ControllerDetails, "vOTTZDW", (signed long)(((double)smProductTeachPoint->OutputTrayTableZAxisDownPosition) / m_motorConfiguration[7].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[7].ControllerDetails, "vOTTZLD", (signed long)(((double)smProductTeachPoint->OutputTrayTableZAxisAtOutputTrayStackerLoadingPosition) / m_motorConfiguration[7].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[7].ControllerDetails, "vOTTZSG", (signed long)(((double)smProductTeachPoint->OutputTrayTableZAxisAtOutputTrayStackerSingulationPosition) / m_motorConfiguration[7].UnitInOnePulse));
	nError += cMotion->SetControllerVariable(m_motorConfiguration[7].ControllerDetails, "vOTTZUL", (signed long)(((double)smProductTeachPoint->OutputTrayTableZAxisAtOutputTrayStackerUnloadingPosition) / m_motorConfiguration[7].UnitInOnePulse));
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Output Tray Table Z Axis motor setting done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableZAxisMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorStop(m_motorConfiguration[7].Axis);
	//check
	sprintf_s(command, sizeof(command), "SPD=vSPD*(%u/100);ACD=vACD*(%u/100);DCD=vDCD*(%u/100);", speedPercent, accelerationPercent, accelerationPercent);
	nError = cMotion->SendCommand(m_motorConfiguration[7].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableZAxisMotorMoveDown(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableOutputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(47005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(47001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsOutputTrayTableZAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(47010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor move down");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableZAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	nError += cMotion->SendCommand(m_motorConfiguration[7].ControllerDetails, "XQ#DMDW,3");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Output Tray Table Z Axis motor move down %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableZAxisMotorInPosition() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor move down start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(47003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableZAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor move down done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(47002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableZAxisMotorMoveLoad(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableOutputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(47005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(47001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	//if (IsOutputTrayTableZAxisMotorSafeToMove() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(47010);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not Safe To Move.");
	//	return m_cProductShareVariables->Error_MotorNotSafeToMove;
	//}


	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsOutputTrayTableZAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(47010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor move load");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableZAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[7].ControllerDetails, "XQ#DMLD,3");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Output Tray Table Z Axis motor move load %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableZAxisMotorInPosition() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor move load start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(47003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableZAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor move load done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(47002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableZAxisMotorMoveSingulation(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableOutputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(47005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(47001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
CB:
	if (IsOutputTrayTableZAxisMotorSafeToMove() == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->COMMAND_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(47010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not Safe To Move.");
			return m_cProductShareVariables->Error_MotorNotSafeToMove;
		}
		else
		{
			goto CB;
		}
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor move singulation");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableZAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[7].ControllerDetails, "XQ#DMSG,3");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Output Tray Table Z Axis motor move to singulation position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableZAxisMotorInPosition() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor move to singulation position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(47003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableZAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor move to singulation position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(47002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableZAxisMotorMoveUnload(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableOutputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsOutputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(47005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not homing yet");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(47001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor is not ready");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsOutputTrayTableZAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(47010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor move unload");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableZAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[7].ControllerDetails, "XQ#DMUL,3");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Output Tray Table Z Axis motor move unload %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableZAxisMotorInPosition() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor move unload start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(47003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableZAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor move unload done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(47002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableZAxisMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsOutputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(47001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsOutputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(47005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsOutputTrayTableZAxisMotorSafeToMoveRelative(movePos_um + smGeneral->nMotorEncoderPosition) == false)
	{
		m_cProductShareVariables->SetAlarm(47010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um + smGeneral->nMotorEncoderPosition > smProductTeachPoint->OutputTrayTableZAxisForwardLimitPosition ||
		movePos_um + smGeneral->nMotorEncoderPosition < smProductTeachPoint->OutputTrayTableZAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Output Tray Table Z Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Output Tray Table Z Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[7].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Z Axis motor send command stop thread %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//not sure
	sprintf_s(command, sizeof(command), "PRD=%u;BGD;AMD;", (int)((double)movePos_um / m_motorConfiguration[7].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[7].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis move relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Z Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableZAxisMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableOutputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsOutputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(47001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsOutputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(47005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsOutputTrayTableZAxisMotorSafeToMoveAbsolute(movePos_um) == false)
	{
		m_cProductShareVariables->SetAlarm(47010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um > smProductTeachPoint->OutputTrayTableZAxisForwardLimitPosition ||
		movePos_um < smProductTeachPoint->OutputTrayTableZAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Output Tray Table Z Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Output Tray Table Z Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[7].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Output Tray Table Z Axis motor thread 0 %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//check
	sprintf_s(command, sizeof(command), "PAD=%u;BGD;AMD;", (int)((double)movePos_um / m_motorConfiguration[7].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[7].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(31001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Output Tray Table Z Axis move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::OutputTrayTableZAxisMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	if (smProductCustomize->EnableOutputTrayTableZAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}

	if (smProductModuleStatus->IsOutputTrayTableZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(47005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsOutputTrayTableZAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(47001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsOutputTrayTableZAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(47010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductProduction->OutputTrayTableZAxisMovePosition > smProductTeachPoint->OutputTrayTableZAxisForwardLimitPosition ||
		smProductProduction->OutputTrayTableZAxisMovePosition < smProductTeachPoint->OutputTrayTableZAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Output Tray Table Z Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cLogger->WriteLog("Position is out of Output Tray Table Z Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableZAxisMotorInPosition() == true)
		{
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	char command[80];
	//not sure
	sprintf_s(command, sizeof(command), "vOTTZPos=%u;XQ#DMV,3", (signed long)(((double)smProductProduction->OutputTrayTableZAxisMovePosition) / m_motorConfiguration[7].UnitInOnePulse));
	nError += cMotion->SendCommand(m_motorConfiguration[7].ControllerDetails, command);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(31001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Output Tray Table Z Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableZAxisMotorInPosition() == false)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(47003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor wait movement start3 timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsOutputTrayTableZAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis motor done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(47002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table Z Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
//not sure
bool CProductMotorControl::IsOutputTrayTableZAxisMotorSafeToMove()
{
	signed long OutputTrayTableXAxisMotorEncoder = ReadOutputTrayTableXAxisMotorEncoder();
	signed long OutputTrayTableYAxisMotorEncoder = ReadOutputTrayTableYAxisMotorEncoder();
	if (OutputTrayTableXAxisMotorEncoder <= (smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayStackerLoadPosition + 40)
		&& OutputTrayTableXAxisMotorEncoder >= (smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayStackerLoadPosition - 40)
		&& OutputTrayTableYAxisMotorEncoder <= (smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayStackerLoadPosition + 40)
		&& OutputTrayTableYAxisMotorEncoder >= (smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayStackerLoadPosition - 40))
	{

	}
	else if (OutputTrayTableXAxisMotorEncoder <= (smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayStackerUnloadPosition + 40)
		&& OutputTrayTableXAxisMotorEncoder >= (smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayStackerUnloadPosition - 40)
		&& OutputTrayTableYAxisMotorEncoder <= (smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayStackerUnloadPosition + 40)
		&& OutputTrayTableYAxisMotorEncoder >= (smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayStackerUnloadPosition - 40))
	{

	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Y Axis Motor not at stacker position");
		return false;
	}
	return true;
}
//not sure
bool CProductMotorControl::IsOutputTrayTableZAxisMotorSafeToMoveRelative(signed long position)
{
	signed long OutputTrayTableXAxisMotorEncoder = ReadOutputTrayTableXAxisMotorEncoder();
	signed long OutputTrayTableYAxisMotorEncoder = ReadOutputTrayTableYAxisMotorEncoder();
	if (OutputTrayTableXAxisMotorEncoder <= (smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayStackerLoadPosition + 25)
		&& OutputTrayTableXAxisMotorEncoder >= (smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayStackerLoadPosition - 25)
		&& OutputTrayTableYAxisMotorEncoder <= (smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayStackerLoadPosition + 25)
		&& OutputTrayTableYAxisMotorEncoder >= (smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayStackerLoadPosition - 25))
	{

	}
	else if (OutputTrayTableXAxisMotorEncoder <= (smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayStackerUnloadPosition + 25)
		&& OutputTrayTableXAxisMotorEncoder >= (smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayStackerUnloadPosition - 25)
		&& OutputTrayTableYAxisMotorEncoder <= (smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayStackerUnloadPosition + 25)
		&& OutputTrayTableYAxisMotorEncoder >= (smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayStackerUnloadPosition - 25))
	{

	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Y Axis Motor not at stacker position");
		return false;
	}
	return true;
}
//not sure
bool CProductMotorControl::IsOutputTrayTableZAxisMotorSafeToMoveAbsolute(signed long position)
{
	signed long OutputTrayTableXAxisMotorEncoder = ReadOutputTrayTableXAxisMotorEncoder();
	signed long OutputTrayTableYAxisMotorEncoder = ReadOutputTrayTableYAxisMotorEncoder();
	if (OutputTrayTableXAxisMotorEncoder <= (smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayStackerLoadPosition + 25)
		&& OutputTrayTableXAxisMotorEncoder >= (smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayStackerLoadPosition - 25)
		&& OutputTrayTableYAxisMotorEncoder <= (smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayStackerLoadPosition + 25)
		&& OutputTrayTableYAxisMotorEncoder >= (smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayStackerLoadPosition - 25))
	{

	}
	else if (OutputTrayTableXAxisMotorEncoder <= (smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayStackerUnloadPosition + 25)
		&& OutputTrayTableXAxisMotorEncoder >= (smProductTeachPoint->OutputTrayTableXAxisAtOutputTrayStackerUnloadPosition - 25)
		&& OutputTrayTableYAxisMotorEncoder <= (smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayStackerUnloadPosition + 25)
		&& OutputTrayTableYAxisMotorEncoder >= (smProductTeachPoint->OutputTrayTableYAxisAtOutputTrayStackerUnloadPosition - 25))
	{

	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Output Tray Table X Y Axis Motor not at stacker position");
		return false;
	}
	return true;
}
signed long CProductMotorControl::ReadOutputTrayTableZAxisMotorEncoder()
{
	int nError = 0;
	signed long slPosition;
	return m_cMotion->GetEncoderPosition(m_motorConfiguration[7].Axis);
}
#pragma endregion

#pragma region Input Vision Module
int CProductMotorControl::InputVisionModuleMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputVisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputVisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(48001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsInputVisionMotorHome = false;
	nError = cMotion->MotorOff(m_motorConfiguration[8].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputVisionModuleMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputVisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputVisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(48001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorOn(m_motorConfiguration[8].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor on error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputVisionModuleMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputVisionMotor == false)
	{
		m_cLogger->WriteLog("Input Vision Module motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Input Vision Module motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->MotorStop(m_motorConfiguration[8].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Vision Module motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Vision Module motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->Reset(m_motorConfiguration[8].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Vision Module motor reset done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Vision Module motor reset error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputVisionModuleMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputVisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputVisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(48001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsInputVisionModuleMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(48010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor not safe to move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module homing");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[8].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Input Vision Module motor thread 0 %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	nError = cMotion->SetControllerVariable(m_motorConfiguration[8].ControllerDetails, "vIPVHM", (signed long)0);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during reset Input Vision Module home offset %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	nError = cMotion->MotorHomeAsychronous(m_motorConfiguration[8].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Input Vision Modules motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsInputVisionModuleMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor home start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(48004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor home start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsInputVisionModuleMotorInPosition() == true)
		{
			smProductModuleStatus->IsInputVisionMotorHome = true;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor home done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(48004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	if (smProductEvent->JobSlow.Set == true)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = cMotion->SetControllerVariable(m_motorConfiguration[8].ControllerDetails, "vSLOW", (signed long)1);
		if (nError == 0)
		{
			return 0;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during set all MC3 slow on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
	}
	else
	{
		return 0;
	}
	return -1;
}
int CProductMotorControl::InputVisionModuleMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputVisionMotor == false)
	{
		m_cLogger->WriteLog("Input Vision Module motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Input Vision Module Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError += cMotion->SetControllerVariable(m_motorConfiguration[8].ControllerDetails, "vIPVFP", (signed long)(((double)smProductTeachPoint->InputVisionZAxisAtInputVisionFocusPosition) / m_motorConfiguration[8].UnitInOnePulse));

	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Input Vision Module motor setting done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::InputVisionModuleMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputVisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorStop(m_motorConfiguration[8].Axis);
	//NOT SURE
	sprintf_s(command, sizeof(command), "SPA=vSPA*(%u/100);ACA=vACA*(%u/100);DCA=vDCA*(%u/100);", speedPercent, accelerationPercent, accelerationPercent);
	nError = cMotion->SendCommand(m_motorConfiguration[8].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::InputVisionModuleMotorMoveFocusPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableInputVisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputVisionMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(48005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor not homing yet\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputVisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(48001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor is not ready\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsInputVisionModuleMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(48010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor not Safe To Move.\n");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor move to Input Vision focus position\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputVisionModuleMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[8].ControllerDetails, "XQ#AMFP,0");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Input Vision Module motor move to Input Vision focus position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputVisionModuleMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor move to Input Vision focus position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(48003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputVisionModuleMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor move to Input Vision focus position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(48002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;

}
int CProductMotorControl::InputVisionModuleMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputVisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputVisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(48001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsInputVisionMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(48005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsInputVisionModuleMotorSafeToMoveRelative(movePos_um + smGeneral->nMotorEncoderPosition) == false)
	{
		m_cProductShareVariables->SetAlarm(48010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um + smGeneral->nMotorEncoderPosition > smProductTeachPoint->InputVisionZAxisForwardLimitPosition ||
		movePos_um + smGeneral->nMotorEncoderPosition < smProductTeachPoint->InputVisionZAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Input Vision Module Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Input Vision Module Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[8].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Vision Module motor send command stop thread %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//NOT SURE
	sprintf_s(command, sizeof(command), "PRA=%u;BGA;AMA;", (int)((double)movePos_um / m_motorConfiguration[8].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[8].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module move relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Vision Module send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputVisionModuleMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableInputVisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsInputVisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(48001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsInputVisionMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(48005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsInputVisionModuleMotorSafeToMoveAbsolute(movePos_um) == false)
	{
		m_cProductShareVariables->SetAlarm(48010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductEvent->GMAIN_RTHD_TEACHING_VISION.Set == true)
	{
		if (movePos_um > smProductTeachPoint->InputVisionZAxisAtInputVisionFocusPosition + (signed long)2000 ||
			movePos_um < smProductTeachPoint->InputVisionZAxisAtInputVisionFocusPosition - (signed long)2000)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Input Vision Module Motor Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	if (movePos_um > smProductTeachPoint->InputVisionZAxisForwardLimitPosition ||
		movePos_um < smProductTeachPoint->InputVisionZAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Input Vision Module Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Input Vision Module Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[8].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Input Vision Module motor thread 0 %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//NOT SURE
	sprintf_s(command, sizeof(command), "PAA=%u;BGA;AMA;", (int)((double)movePos_um / m_motorConfiguration[8].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[8].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Input Vision Module move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::InputVisionModuleMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	if (smProductCustomize->EnableInputVisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsInputVisionMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(48005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsInputVisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(48001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsInputVisionModuleMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(48010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductProduction->InputVisionModuleMovePosition > smProductTeachPoint->InputVisionZAxisForwardLimitPosition ||
		smProductProduction->InputVisionModuleMovePosition < smProductTeachPoint->InputVisionZAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Input Vision Module Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cLogger->WriteLog("Position is out of Input Vision Module Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputVisionModuleMotorInPosition() == true)
		{
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	char command[80];
	sprintf_s(command, sizeof(command), "vIPVPos=%u;XQ#AMV,0", (signed long)(((double)smProductProduction->InputVisionModuleMovePosition) / m_motorConfiguration[8].UnitInOnePulse));
	nError += cMotion->SendCommand(m_motorConfiguration[8].ControllerDetails, command);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Input Vision Module motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputVisionModuleMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(48003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor wait movement start3 timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsInputVisionModuleMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module motor done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(48002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Input Vision Module wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
//NOT SURE
bool CProductMotorControl::IsInputVisionModuleMotorSafeToMove()
{

	return true;
}
//NOT SURE
bool CProductMotorControl::IsInputVisionModuleMotorSafeToMoveRelative(signed long position)
{

	return true;
}
//NOT SURE
bool CProductMotorControl::IsInputVisionModuleMotorSafeToMoveAbsolute(signed long position)
{

	return true;
}
signed long CProductMotorControl::ReadInputVisionModuleMotorEncoder()
{
	int nError = 0;
	signed long slPosition;
	return m_cMotion->GetEncoderPosition(m_motorConfiguration[8].Axis);
}
#pragma endregion

#pragma region S2 Vision Module
int CProductMotorControl::S2VisionModuleMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS2VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsS2VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(49001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsS2VisionMotorHome = false;
	nError = cMotion->MotorOff(m_motorConfiguration[10].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::S2VisionModuleMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS2VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsS2VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(49001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorOn(m_motorConfiguration[10].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor on error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::S2VisionModuleMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS2VisionMotor == false)
	{
		m_cLogger->WriteLog("S2 Vision Module motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("S2 Vision Module motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->MotorStop(m_motorConfiguration[10].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("S2 Vision Module motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("S2 Vision Module motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->Reset(m_motorConfiguration[10].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("S2 Vision Module motor reset done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("S2 Vision Module motor reset error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::S2VisionModuleMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS2VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsS2VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(49001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsS2VisionModuleMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(49010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor not safe to move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module homing");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[10].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop S2 Vision Module motor thread 0 %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	nError = cMotion->SetControllerVariable(m_motorConfiguration[10].ControllerDetails, "vS2VHM", (signed long)0);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during reset S2 Vision Module home offset %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	nError = cMotion->MotorHomeAsychronous(m_motorConfiguration[10].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home S2 Vision Module motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsS2VisionModuleMotorInPosition() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor home start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(49004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor home start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsS2VisionModuleMotorInPosition() == true)
		{
			smProductModuleStatus->IsS2VisionMotorHome = true;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor home done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(49004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	if (smProductEvent->JobSlow.Set == true)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = cMotion->SetControllerVariable(m_motorConfiguration[10].ControllerDetails, "vSLOW", (signed long)1);
		if (nError == 0)
		{
			return 0;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during set all MC3 slow on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
	}
	else
	{
		return 0;
	}
	return -1;
}
int CProductMotorControl::S2VisionModuleMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS2VisionMotor == false)
	{
		m_cLogger->WriteLog("S2 Vision Module motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("S2 Vision Module Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError += cMotion->SetControllerVariable(m_motorConfiguration[10].ControllerDetails, "vS2VFP", (signed long)(((double)smProductTeachPoint->S2VisionFocusPosition) / m_motorConfiguration[10].UnitInOnePulse));

	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("S2 Vision Module motor setting done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::S2VisionModuleMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS2VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorStop(m_motorConfiguration[10].Axis);
	//CHECK
	sprintf_s(command, sizeof(command), "SPC=vSPC*(%u/100);ACC=vACC*(%u/100);DCC=vDCC*(%u/100);", speedPercent, accelerationPercent, accelerationPercent);
	nError = cMotion->SendCommand(m_motorConfiguration[10].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::S2VisionModuleMotorMoveFocusPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableS2VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsS2VisionMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(49005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor not homing yet\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsS2VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(49001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor is not ready\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsS2VisionModuleMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(49010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor not Safe To Move.\n");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor move to S2 Vision focus position\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS2VisionModuleMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[10].ControllerDetails, "XQ#CMFP,2");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during S2 Vision Module motor move to S2 Vision focus position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS2VisionModuleMotorInPosition() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor move to S2 Vision focus position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(49003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS2VisionModuleMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor move to S2 Vision focus position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(49002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;

}
int CProductMotorControl::S2VisionModuleMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS2VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsS2VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(49001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsS2VisionMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(49005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsS2VisionModuleMotorSafeToMoveRelative(movePos_um + smGeneral->nMotorEncoderPosition) == false)
	{
		m_cProductShareVariables->SetAlarm(49010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um + smGeneral->nMotorEncoderPosition > smProductTeachPoint->S2VisionForwardLimitPosition ||
		movePos_um + smGeneral->nMotorEncoderPosition < smProductTeachPoint->S2VisionReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of S2 Vision Module Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of S2 Vision Module Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[10].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S2 Vision Module motor send command stop thread %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//CHECK
	sprintf_s(command, sizeof(command), "PRC=%u;BGC;AMC;", (int)((double)movePos_um / m_motorConfiguration[10].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[10].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module move relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S2 Vision Module send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::S2VisionModuleMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS2VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsS2VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(49001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsS2VisionMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(49005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsS2VisionModuleMotorSafeToMoveAbsolute(movePos_um) == false)
	{
		m_cProductShareVariables->SetAlarm(49010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductEvent->GMAIN_RTHD_TEACHING_VISION.Set == true)
	{
		if (movePos_um > smProductTeachPoint->S2VisionFocusPosition + (signed long)2000 ||
			movePos_um < smProductTeachPoint->S2VisionFocusPosition - (signed long)2000)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of S2 Vision Module Motor Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	if (movePos_um > smProductTeachPoint->S2VisionForwardLimitPosition ||
		movePos_um < smProductTeachPoint->S2VisionReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of S2 Vision Module Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of S2 Vision Module Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[10].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop S2 Vision Module motor thread 0 %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	// CHECK
	sprintf_s(command, sizeof(command), "PAC=%u;BGC;AMC;", (int)((double)movePos_um / m_motorConfiguration[10].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[10].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S2 Vision Module move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::S2VisionModuleMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	if (smProductCustomize->EnableS2VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsS2VisionMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(49005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsS2VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(49001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsS2VisionModuleMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(49010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductProduction->S2VisionModuleMovePosition > smProductTeachPoint->S2VisionForwardLimitPosition ||
		smProductProduction->S2VisionModuleMovePosition < smProductTeachPoint->S2VisionReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of S2 Vision Module Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cLogger->WriteLog("Position is out of S2 Vision Module Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS2VisionModuleMotorInPosition() == true)
		{
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	char command[80];
	sprintf_s(command, sizeof(command), "vS2VPos=%u;XQ#CMV,2", (signed long)(((double)smProductProduction->S2VisionModuleMovePosition) / m_motorConfiguration[10].UnitInOnePulse));
	nError += cMotion->SendCommand(m_motorConfiguration[10].ControllerDetails, command);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home S2 Vision Module motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS2VisionModuleMotorInPosition() == false)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(49003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor wait movement start3 timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS2VisionModuleMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module motor done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(49002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S2 Vision Module wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
//NOT SURE
bool CProductMotorControl::IsS2VisionModuleMotorSafeToMove()
{

	return true;
}
//NOT SURE
bool CProductMotorControl::IsS2VisionModuleMotorSafeToMoveRelative(signed long position)
{

	return true;
}
//NOT SURE
bool CProductMotorControl::IsS2VisionModuleMotorSafeToMoveAbsolute(signed long position)
{

	return true;
}
signed long CProductMotorControl::ReadS2VisionModuleMotorEncoder()
{
	int nError = 0;
	signed long slPosition;
	return m_cMotion->GetEncoderPosition(m_motorConfiguration[10].Axis);
}
#pragma endregion

#pragma region S1 Vision Module
int CProductMotorControl::S1VisionModuleMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS1VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsS1VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(50001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsS1VisionMotorHome = false;
	nError = cMotion->MotorOff(m_motorConfiguration[9].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::S1VisionModuleMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS1VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsS1VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(50001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorOn(m_motorConfiguration[9].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor on error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::S1VisionModuleMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS1VisionMotor == false)
	{
		m_cLogger->WriteLog("S1 Vision Module motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("S1 Vision Module motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->MotorStop(m_motorConfiguration[9].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("S1 Vision Module motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("S1 Vision Module motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->Reset(m_motorConfiguration[9].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("S1 Vision Module motor reset done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("S1 Vision Module motor reset error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::S1VisionModuleMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS1VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsS1VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(50001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsS1VisionModuleMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(50010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor not safe to move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module homing");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[9].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop S1 Vision Module motor thread 0 %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	nError = cMotion->SetControllerVariable(m_motorConfiguration[9].ControllerDetails, "vS1VHM", (signed long)0);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during reset S1 Vision Module home offset %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	nError = cMotion->MotorHomeAsychronous(m_motorConfiguration[9].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home S1 Vision Module motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsS1VisionModuleMotorInPosition() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor home start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(50004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor home start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsS1VisionModuleMotorInPosition() == true)
		{
			smProductModuleStatus->IsS1VisionMotorHome = true;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor home done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(50004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	if (smProductEvent->JobSlow.Set == true)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = cMotion->SetControllerVariable(m_motorConfiguration[9].ControllerDetails, "vSLOW", (signed long)1);
		if (nError == 0)
		{
			return 0;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during set all MC3 slow on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
	}
	else
	{
		return 0;
	}
	return -1;
}
int CProductMotorControl::S1VisionModuleMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS1VisionMotor == false)
	{
		m_cLogger->WriteLog("S1 Vision Module motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("S1 Vision Module Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError += cMotion->SetControllerVariable(m_motorConfiguration[9].ControllerDetails, "vS1VFP", (signed long)(((double)smProductTeachPoint->S1VisionFocusPosition) / m_motorConfiguration[9].UnitInOnePulse));

	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("S1 Vision Module motor setting done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::S1VisionModuleMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS1VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorStop(m_motorConfiguration[9].Axis);
	//CHECK
	sprintf_s(command, sizeof(command), "SPB=vSPB*(%u/100);ACB=vACB*(%u/100);DCB=vDCB*(%u/100);", speedPercent, accelerationPercent, accelerationPercent);
	nError = cMotion->SendCommand(m_motorConfiguration[9].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::S1VisionModuleMotorMoveFocusPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableS1VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsS1VisionMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(50005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor not homing yet\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsS1VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(50001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor is not ready\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsS1VisionModuleMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(50010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor not Safe To Move.\n");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor move to S1 Vision focus position\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS1VisionModuleMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[9].ControllerDetails, "XQ#BMFP,1");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during S1 Vision Module motor move to S1 Vision focus position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS1VisionModuleMotorInPosition() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor move to S1 Vision focus position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(50003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS1VisionModuleMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor move to S1 Vision focus position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(50002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;

}
int CProductMotorControl::S1VisionModuleMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS1VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsS1VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(50001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsS1VisionMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(50005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsS1VisionModuleMotorSafeToMoveRelative(movePos_um + smGeneral->nMotorEncoderPosition) == false)
	{
		m_cProductShareVariables->SetAlarm(50010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um + smGeneral->nMotorEncoderPosition > smProductTeachPoint->S1VisionForwardLimitPosition ||
		movePos_um + smGeneral->nMotorEncoderPosition < smProductTeachPoint->S1VisionReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of S1 Vision Module Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of S1 Vision Module Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[9].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S1 Vision Module motor send command stop thread %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//CHECK
	sprintf_s(command, sizeof(command), "PRB=%u;BGB;AMB;", (int)((double)movePos_um / m_motorConfiguration[9].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[9].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module move relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S1 Vision Module send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::S1VisionModuleMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS1VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsS1VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(50001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsS1VisionMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(50005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsS1VisionModuleMotorSafeToMoveAbsolute(movePos_um) == false)
	{
		m_cProductShareVariables->SetAlarm(50010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductEvent->GMAIN_RTHD_TEACHING_VISION.Set == true)
	{
		if (movePos_um > smProductTeachPoint->S1VisionFocusPosition + (signed long)2000 ||
			movePos_um < smProductTeachPoint->S1VisionFocusPosition - (signed long)2000)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of S1 Vision Module Motor Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	if (movePos_um > smProductTeachPoint->S1VisionForwardLimitPosition ||
		movePos_um < smProductTeachPoint->S1VisionReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of S1 Vision Module Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of S1 Vision Module Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[9].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop S1 Vision Module motor thread 0 %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	// CHECK
	sprintf_s(command, sizeof(command), "PAB=%u;BGB;AMB;", (int)((double)movePos_um / m_motorConfiguration[9].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[9].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(32001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S1 Vision Module move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::S1VisionModuleMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	if (smProductCustomize->EnableS1VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsS1VisionMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(50005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsS1VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(50001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsS1VisionModuleMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(50010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductProduction->S1VisionModuleMovePosition > smProductTeachPoint->S1VisionForwardLimitPosition ||
		smProductProduction->S1VisionModuleMovePosition < smProductTeachPoint->S1VisionReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of S1 Vision Module Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cLogger->WriteLog("Position is out of S1 Vision Module Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS1VisionModuleMotorInPosition() == true)
		{
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	char command[80];
	sprintf_s(command, sizeof(command), "vS1VPos=%u;XQ#BMV,1", (signed long)(((double)smProductProduction->S1VisionModuleMovePosition) / m_motorConfiguration[9].UnitInOnePulse));
	nError += cMotion->SendCommand(m_motorConfiguration[9].ControllerDetails, command);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(32001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home S1 Vision Module motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS1VisionModuleMotorInPosition() == false)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(50003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor wait movement start3 timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS1VisionModuleMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module motor done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(50002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S1 Vision Module wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
//NOT SURE
bool CProductMotorControl::IsS1VisionModuleMotorSafeToMove()
{

	return true;
}
//NOT SURE
bool CProductMotorControl::IsS1VisionModuleMotorSafeToMoveRelative(signed long position)
{

	return true;
}
//NOT SURE
bool CProductMotorControl::IsS1VisionModuleMotorSafeToMoveAbsolute(signed long position)
{

	return true;
}
signed long CProductMotorControl::ReadS1VisionModuleMotorEncoder()
{
	int nError = 0;
	signed long slPosition;
	return m_cMotion->GetEncoderPosition(m_motorConfiguration[9].Axis);
}
#pragma endregion

#pragma region S3 Vision Module
int CProductMotorControl::S3VisionModuleMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS3VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsS3VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(54001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsS3VisionMotorHome = false;
	nError = cMotion->MotorOff(m_motorConfiguration[11].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(54001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::S3VisionModuleMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS3VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsS3VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(54001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorOn(m_motorConfiguration[11].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(33001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor on error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::S3VisionModuleMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS3VisionMotor == false)
	{
		m_cLogger->WriteLog("S3 Vision Module motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	//if(IsInputTableXAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(40001);
	//	m_cLogger->WriteLog("Input Table X Axis Motor not ready.\n");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cLogger->WriteLog("S3 Vision Module motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	//smProductModuleStatus->IsInputTableXAxisMotorHome = false;
	nError = cMotion->MotorStop(m_motorConfiguration[11].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("S3 Vision Module motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cProductShareVariables->SetAlarm(33001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("S3 Vision Module motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}

	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = cMotion->Reset(m_motorConfiguration[11].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("S3 Vision Module motor reset done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(33001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("S3 Vision Module motor reset error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::S3VisionModuleMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS3VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsS3VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(54001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsS3VisionModuleMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(54010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module Motor not safe to move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module homing");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[11].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(33001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop S3 Vision Module motor thread 0 %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	char command[80];

	nError = cMotion->SetControllerVariable(m_motorConfiguration[11].ControllerDetails, "vS3VHM", (signed long)(((double)0) / m_motorConfiguration[11].UnitInOnePulse));
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(33001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during reset S3 Vision Module home offset %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	nError = cMotion->MotorHomeAsychronous(m_motorConfiguration[11].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(33001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home S3 Vision Module motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsS3VisionModuleMotorInPosition() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor home start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(54004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor home start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsS3VisionModuleMotorInPosition() == true)
		{
			smProductModuleStatus->IsS3VisionMotorHome = true;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor home done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(54004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	if (smProductEvent->JobSlow.Set == true)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		nError = cMotion->SetControllerVariable(m_motorConfiguration[11].ControllerDetails, "vSLOW", (signed long)1);
		if (nError == 0)
		{
			return 0;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during set all MC4 slow on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return nError;
		}
	}
	else
	{
		return 0;
	}
	return -1;
}
int CProductMotorControl::S3VisionModuleMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS3VisionMotor == false)
	{
		m_cLogger->WriteLog("S3 Vision Module motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("S3 Vision Module Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->SetControllerVariable(m_motorConfiguration[11].ControllerDetails, "vS3VFP", (signed long)(((double)smProductTeachPoint->S3VisionFocusPosition) / m_motorConfiguration[11].UnitInOnePulse));

	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("S3 Vision Module motor setting done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::S3VisionModuleMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS3VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->MotorStop(m_motorConfiguration[11].Axis);
	sprintf_s(command, sizeof(command), "SPD=vSPD*(%u/100);ACD=(vACD*%u/100);DCD=vDCD*(%u/100);", speedPercent, accelerationPercent, accelerationPercent);
	nError = cMotion->SendCommand(m_motorConfiguration[11].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::S3VisionModuleMotorMoveFocusPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnableS3VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsS3VisionMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(54005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module Motor not homing yet\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsS3VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(54001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor is not ready\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsS3VisionModuleMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(54010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Motor not Safe To Move.\n");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Motor move to reference focus position\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS3VisionModuleMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	nError += cMotion->SendCommand(m_motorConfiguration[11].ControllerDetails, "XQ#DMFP,3");
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(33001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during S3 Vision Module motor move to reference focus position %u", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS3VisionModuleMotorInPosition() == false)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module Motor move to reference focus position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(54003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS3VisionModuleMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module Motor move to reference focus position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(54002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;

}
int CProductMotorControl::S3VisionModuleMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS3VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsS3VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(54001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsS3VisionMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(54005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsS3VisionModuleMotorSafeToMoveRelative(movePos_um + smGeneral->nMotorEncoderPosition) == false)
	{
		m_cProductShareVariables->SetAlarm(54010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um + smGeneral->nMotorEncoderPosition > smProductTeachPoint->S3VisionForwardLimitPosition ||
		movePos_um + smGeneral->nMotorEncoderPosition < smProductTeachPoint->S3VisionReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of S3 Vision Module Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of S3 Vision Module Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = cMotion->Reset(m_motorConfiguration[11].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(33001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S3 Vision Module motor send command stop thread %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	sprintf_s(command, sizeof(command), "PRD=%u;BGD;AMD;", (int)(((double)movePos_um) / m_motorConfiguration[11].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[11].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module move Relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(33001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S3 Vision Module send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::S3VisionModuleMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnableS3VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsS3VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(54001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsS3VisionMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(54005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsS3VisionModuleMotorSafeToMoveAbsolute(movePos_um) == false)
	{
		m_cProductShareVariables->SetAlarm(54010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductEvent->GMAIN_RTHD_TEACHING_VISION.Set == true)
	{
		if (movePos_um > smProductTeachPoint->S3VisionFocusPosition + (signed long)2000 ||
			movePos_um < smProductTeachPoint->S3VisionFocusPosition - (signed long)2000)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of S3 Vision Module Motor Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	if (movePos_um > smProductTeachPoint->S3VisionForwardLimitPosition ||
		movePos_um < smProductTeachPoint->S3VisionReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of S3 Vision Module Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of S3 Vision Module Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);


	nError = cMotion->Reset(m_motorConfiguration[11].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(33001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop S3 Vision Module motor thread 0 %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	sprintf_s(command, sizeof(command), "PAD=%u;BGD;AMD;", (int)(((double)movePos_um) / m_motorConfiguration[11].UnitInOnePulse));
	nError = cMotion->SendCommand(m_motorConfiguration[11].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(33001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error S3 Vision Module move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::S3VisionModuleMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	if (smProductCustomize->EnableS3VisionMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsS3VisionMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(54005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsS3VisionModuleMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(54001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductProduction->S3VisionModuleMovePosition > smProductTeachPoint->S3VisionForwardLimitPosition ||
		smProductProduction->S3VisionModuleMovePosition < smProductTeachPoint->S3VisionReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of S3 Vision Module Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of S3 Vision Module Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	if (IsS3VisionModuleMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(54010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS3VisionModuleMotorInPosition() == true)
		{
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	char command[80];
	sprintf_s(command, sizeof(command), "vS3VPos=%u;XQ#DMV,4", (signed long)(((double)smProductProduction->S3VisionModuleMovePosition) / m_motorConfiguration[11].UnitInOnePulse));
	nError += cMotion->SendCommand(m_motorConfiguration[11].ControllerDetails, command);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(33001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Move S3 Vision Module motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS3VisionModuleMotorInPosition() == false)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(54003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor wait movement start3 timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsS3VisionModuleMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module motor done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(54002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("S3 Vision Module wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
//check
bool CProductMotorControl::IsS3VisionModuleMotorSafeToMove()
{

	return true;
}
//check
bool CProductMotorControl::IsS3VisionModuleMotorSafeToMoveRelative(signed long position)
{

	return true;
}
bool CProductMotorControl::IsS3VisionModuleMotorSafeToMoveAbsolute(signed long position)
{

	return true;
}
signed long CProductMotorControl::ReadS3VisionModuleMotorEncoder()
{
	int nError = 0;
	signed long slPosition;
	return m_cMotion->GetEncoderPosition(m_motorConfiguration[11].Axis);
}
#pragma endregion
#pragma endregion

#pragma region Pick And Place 1 X Axis
int CProductMotorControl::PickAndPlace1XAxisMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnablePickAndPlace1XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (m_cProductIOControl->IsPickAndPlace1XAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(55001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsPickAndPlace1XAxisMotorHome = false;
	nError = m_cProductMotorControl->AgitoServoOn(0, 0, 0);
	RtSleepFt(&m_cProductShareVariables->m_lnPeriod_10ms);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(34001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1XAxisMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnablePickAndPlace1XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (m_cProductIOControl->IsPickAndPlace1XAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(55001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = m_cProductMotorControl->AgitoServoOn(0, 0, 1);
	RtSleepFt(&m_cProductShareVariables->m_lnPeriod_10ms);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(34001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor on error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1XAxisMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnablePickAndPlace1XAxisMotor == false)
	{
		m_cLogger->WriteLog("Pick And Place 1 X Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsPickAndPlace1XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(55001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cLogger->WriteLog("Pick And Place 1 X Axis motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = m_cProductMotorControl->AgitoStopMotor(0, 0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 1 X Axis motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cProductShareVariables->SetAlarm(34001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 1 X Axis motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	//nError = cMotion->Reset(m_motorConfiguration[13].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 1 X Axis motor reset done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(34001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 1 X Axis motor reset error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1XAxisMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	smProductModuleStatus->IsPickAndPlace1XAxisMotorHome = false;
	if (smProductCustomize->EnablePickAndPlace1XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (m_cProductIOControl->IsPickAndPlace1XAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(55001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	if (IsPickAndPlace1XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(55010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis homing");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsPickAndPlace1XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotionMode(0,0, 1);
	nError += m_cProductMotorControl->AgitoHomeMotor(0, 0);
	//Sleep(5);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cLogger->WriteLog("Error during home Pick And Place 1 X Axis motor %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor home start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(55004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor home start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == true)
		{
			smProductModuleStatus->IsPickAndPlace1XAxisMotorHome = true;
			smProductModuleStatus->IsPickAndPlace1XAxisMoving = false;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor home done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(55004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1XAxisMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnablePickAndPlace1XAxisMotor == false)
	{
		m_cLogger->WriteLog("Pick And Place 1 X Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Pick And Place 1 X Axis Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 1 X Axis motor setting done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1XAxisMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnablePickAndPlace1XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError += m_cProductMotorControl->AgitoStopMotor(0, 0);

	nError += m_cProductMotorControl->AgitoMotorSpeed(0,0, 10000 * (speedPercent / 100), 500,
		25000 * (accelerationPercent / 100), 25000 * (accelerationPercent / 100));
	//nError += m_cProductMotorControl->AgitoMotorSpeed(0,0, (speedPercent / 100));
	//nError += m_cProductMotorControl->AgitoMotorAcceleration(0,0, (accelerationPercent / 100));
	//nError += m_cProductMotorControl->AgitoMotorDeceleration(0,0 (accelerationPercent / 100));
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1XAxisMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;

	if (smProductCustomize->EnablePickAndPlace1XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace1XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(55005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace1XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(55001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace1XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(55010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductProduction->PickAndPlace1XAxisMovePosition > smProductTeachPoint->PickAndPlace1XAxisForwardLimitPosition ||
		smProductProduction->PickAndPlace1XAxisMovePosition < smProductTeachPoint->PickAndPlace1XAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 X Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cLogger->WriteLog("Position is out of Pick And Place 1 X Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	if (smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.InputStation && smProductProduction->PickAndPlace1StationToMove != PickAndPlaceCurrentStation.BottomStation)
	{
		if (smProductProduction->PickAndPlace1StationToMove == PickAndPlaceCurrentStation.OutputStation)
		{
			if (smProductProduction->PickAndPlace1XAxisMovePosition > smProductTeachPoint->PickAndPlace1XAxisOutputPosition + (signed long)2000 ||
				smProductProduction->PickAndPlace1XAxisMovePosition < smProductTeachPoint->PickAndPlace1XAxisOutputPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 1 X Output Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
		else if (smProductProduction->PickAndPlace1XAxisMovePosition > smProductTeachPoint->PickAndPlace1XAxisInputPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace1XAxisMovePosition < smProductTeachPoint->PickAndPlace1XAxisInputPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 X Input Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 1 X Input Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if ((smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.BottomStation || smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.MovingFromInputStationToBottomStation)
		&& smProductProduction->PickAndPlace1StationToMove != PickAndPlaceCurrentStation.S3Station)
	{
		if (smProductProduction->PickAndPlace1XAxisMovePosition > smProductTeachPoint->PickAndPlace1XAxisAtS1AndBottomVisionPosition + (signed long)2000||
			smProductProduction->PickAndPlace1XAxisMovePosition < smProductTeachPoint->PickAndPlace1XAxisAtS1AndBottomVisionPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 X Bottom Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 1 X Bottom Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if ((smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.S3Station || smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.MovingFromBottomStationToS3Station)
			&& smProductProduction->PickAndPlace1StationToMove != PickAndPlaceCurrentStation.OutputStation)
	{
		if (smProductProduction->PickAndPlace1XAxisMovePosition > smProductTeachPoint->PickAndPlace1XAxisAtS2AndS3VisionPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace1XAxisMovePosition < smProductTeachPoint->PickAndPlace1XAxisAtS2AndS3VisionPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 X S3 Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 1 X S3 Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if (smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.OutputStation && smProductProduction->PickAndPlace1StationToMove != PickAndPlaceCurrentStation.InputStation)
	{
		if (smProductProduction->PickAndPlace1XAxisMovePosition > smProductTeachPoint->PickAndPlace1XAxisOutputPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace1XAxisMovePosition < smProductTeachPoint->PickAndPlace1XAxisOutputPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 X Output Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 1 X Output Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == true)
		{
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	smProductModuleStatus->IsPickAndPlace1XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotorRelative(0, 0, long(0));
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoMotorAbsolute(0, 0, smProductProduction->PickAndPlace1XAxisMovePosition);
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoStartMotor(0, 0);
	//Sleep(10);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during move Pick And Place 1 X Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(55003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor wait movement start3 timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace1XAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(55002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1XAxisMotorMoveToInputPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;

	if (smProductCustomize->EnablePickAndPlace1XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}

	if (smProductModuleStatus->IsPickAndPlace1XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(55005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace1XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(55001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace1XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(55010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis move to input position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace1XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotorRelative(0,0, long(0));
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoMotorAbsolute(0, 0, smProductTeachPoint->PickAndPlace1XAxisInputPosition);
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoStartMotor(0, 0);
	//Sleep(10);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 1 X Axis motor move to input position %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor move input position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(55003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor move input position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace1XAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(55002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1XAxisMotorMoveToS1Position(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;

	if (smProductCustomize->EnablePickAndPlace1XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}

	if (smProductModuleStatus->IsPickAndPlace1XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(55005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace1XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(55001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace1XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(55010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis move to S1 position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace1XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotorRelative(0,0, long(0));
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoMotorAbsolute(0, 0, smProductTeachPoint->PickAndPlace1XAxisAtS1AndBottomVisionPosition);
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoStartMotor(0, 0);
	//Sleep(10);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 1 X Axis motor move to S1 position %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor move S1 position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(55003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor move S1 position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace1XAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(55002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1XAxisMotorMoveToS3Position(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;

	if (smProductCustomize->EnablePickAndPlace1XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}

	if (smProductModuleStatus->IsPickAndPlace1XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(55005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace1XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(55001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace1XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(55010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis move to S3 position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace1XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotorRelative(0,0, long(0));
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoMotorAbsolute(0, 0, smProductTeachPoint->PickAndPlace1XAxisAtS2AndS3VisionPosition);
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoStartMotor(0, 0);
	//Sleep(10);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 1 X Axis motor move to S3 Vision position %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor move S3 Vision position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(55003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor move S3 Vision position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace1XAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(55002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1XAxisMotorMoveToOutputPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;

	if (smProductCustomize->EnablePickAndPlace1XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}

	if (smProductModuleStatus->IsPickAndPlace1XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(55005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace1XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(55001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace1XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(55010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis move to output position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace1XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotorRelative(0, 0,long(0));
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoMotorAbsolute(0, 0, smProductTeachPoint->PickAndPlace1XAxisOutputPosition);
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoStartMotor(0, 0);
	//Sleep(10);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 1 X Axis motor move to output position %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor move output position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(55003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor move output position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace1XAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(55002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1XAxisMotorMoveToParkingPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;

	if (smProductCustomize->EnablePickAndPlace1XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}

	if (smProductModuleStatus->IsPickAndPlace1XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(55005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace1XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(55001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace1XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(55010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis move to parking position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace1XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotorRelative(0,0, long(0));
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoMotorAbsolute(0, 0, smProductTeachPoint->PickAndPlace1XAxisParkingPosition);
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoStartMotor(0, 0);
	//Sleep(10);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 1 X Axis motor move to parking position %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor move parking position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(55003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor move parking position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace1XAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(55002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1XAxisMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnablePickAndPlace1XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsPickAndPlace1XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(55001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsPickAndPlace1XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(55005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace1XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(55010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um + smGeneral->nMotorEncoderPosition > smProductTeachPoint->PickAndPlace1XAxisForwardLimitPosition ||
		movePos_um + smGeneral->nMotorEncoderPosition < smProductTeachPoint->PickAndPlace1XAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 X Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 1 X Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	smProductModuleStatus->IsPickAndPlace1XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotorRelative(0,0, movePos_um);
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoStartMotor(0, 0);
	//Sleep(10);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis move relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		smProductModuleStatus->IsPickAndPlace1XAxisMoving = false;
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(34001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 X Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1XAxisMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnablePickAndPlace1XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsPickAndPlace1XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(55001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsPickAndPlace1XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(55005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (smProductEvent->GMAIN_RTHD_TEACHING_VISION.Set == true)
	{
		if (smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.InputStation)
		{
			if (movePos_um > smProductTeachPoint->PickAndPlace1XAxisInputPosition + (signed long)2000 ||
				movePos_um < smProductTeachPoint->PickAndPlace1XAxisInputPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 1 X Input Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
		else if (smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.BottomStation)
		{
			if (movePos_um > smProductTeachPoint->PickAndPlace1XAxisAtS1AndBottomVisionPosition + (signed long)2000 ||
				movePos_um < smProductTeachPoint->PickAndPlace1XAxisAtS1AndBottomVisionPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 1 X Bottom Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
		else if (smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.S3Station)
		{
			if (movePos_um > smProductTeachPoint->PickAndPlace1XAxisAtS2AndS3VisionPosition + (signed long)2000 ||
				movePos_um < smProductTeachPoint->PickAndPlace1XAxisAtS2AndS3VisionPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 1 X S3 Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
		else if (smProductProduction->PickAndPlace1CurrentStation == PickAndPlaceCurrentStation.OutputStation)
		{
			if (movePos_um > smProductTeachPoint->PickAndPlace1XAxisOutputPosition + (signed long)2000 ||
				movePos_um < smProductTeachPoint->PickAndPlace1XAxisOutputPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 1 X Output Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
	}
	if (IsPickAndPlace1XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(55010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um > smProductTeachPoint->PickAndPlace1XAxisForwardLimitPosition ||
		movePos_um < smProductTeachPoint->PickAndPlace1XAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 X Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 1 X Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	smProductModuleStatus->IsPickAndPlace1XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotorRelative(0,0, long(0));
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoMotorAbsolute(0, 0, movePos_um);
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoStartMotor(0, 0);
	//Sleep(10);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		smProductModuleStatus->IsPickAndPlace1XAxisMoving = false;
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(34001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 X Axis move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1XAxisMotorSetStartEndPoint(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	/*//if (smProductModuleStatus->IsPickAndPlaceXAxisMotorHome == false)
	//{
	//	m_cProductShareVariables->SetAlarm(53005);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place X Axis motor not homing yet.");
	//	return m_cProductShareVariables->Error_MotorNotHomed;
	//}
	//if (m_cProductIOControl->IsPickAndPlaceModuleXAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(53001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place X Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place X Axis motor Set Start End Point");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	int nStartIndex = 0;
	int nUnitPresent = 0;
	//for (int i = 0; i < 6; i++)
	//{
	//	//if (smProductProduction->PickUpHeadStationResult[i].UnitPresent == 1)
	//	//{
	//		if (nStartIndex == 0)
	//		{
	//			nStartIndex++;
	//		}
	//		nUnitPresent = nUnitPresent + 2;
	//	//}
	//}
	nError = m_cProductMotorControl->AgitoPositionEventTriggerEventStartIndex(0, nStartIndex);
	//Sleep(5);
	nError = m_cProductMotorControl->AgitoPositionEventTriggerEventEndIndex(0, nNoOfTriggerPoint);
	//Sleep(5);
	//nError = m_cProductMotorControl->AgitoPositionEventTriggerEnable(0);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Set Pick And Place X Axis motor Start End Point %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}*/
	return 0;
}
int CProductMotorControl::PickAndPlace1XAxisMotorEnablePositionTrigger(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;


	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor Enable Trigger");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = m_cProductMotorControl->AgitoPositionEventTriggerEnable(0,0);
	//Sleep(5);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Enable Pick And Place 1 X Axis motor Position Trigger %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return 0;
}
int CProductMotorControl::PickAndPlace1XAxisMotorDisablePositionTrigger(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;

	if (smProductModuleStatus->IsPickAndPlace1XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(55005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace1XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(55001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 X Axis DisableTrigger");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = m_cProductMotorControl->AgitoPositionEventTriggerDisable(0,0);
	//Sleep(5);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Enable Pick And Place 1 X Axis motor Position Trigger %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return 0;
}
bool CProductMotorControl::IsPickAndPlace1XAxisMotorSafeToMove()
{
	signed long PickAndPlace1YAxisMotorEncoder = ReadPickAndPlace1YAxisMotorEncoder();
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis not homing yet");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace1YAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis not homing yet");
		return false;
	}
	////if (ReadPickAndPlace1ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace1ZAxisUpPosition
	////	&& ReadPickAndPlace1ZAxisMotorEncoder()< smProductTeachPoint->PickAndPlace1ZAxisUpPosition)
	////{
	////	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis not at up position");
	////	return false;
	////}
	//if (PickAndPlace1YAxisMotorEncoder - ReadSidewallVisionLeftModuleMotorEncoder() < -20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 may collide with side wall vision left module.\n");
	//	return false;
	//}
	//if (PickAndPlace1YAxisMotorEncoder - ReadSidewallVisionRearModuleMotorEncoder() < -20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 may collide with side wall vision rear module.\n");
	//	return false;
	//}
	return true;
}
bool CProductMotorControl::IsPickAndPlace1XAxisMotorSafeToMoveRelative(signed long position)
{
	signed long PickAndPlace1YAxisMotorEncoder = ReadPickAndPlace1YAxisMotorEncoder();
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis not homing yet");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace1YAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis not homing yet");
		return false;
	}
	//if (ReadPickAndPlace1ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace1ZAxisUpPosition
	//	&& ReadPickAndPlace1ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace1ZAxisUpPosition)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis not at up position");
	//	return false;
	//}
	//if (PickAndPlace1YAxisMotorEncoder - ReadSidewallVisionLeftModuleMotorEncoder() < -20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 may collide with side wall vision left module.\n");
	//	return false;
	//}
	//if (PickAndPlace1YAxisMotorEncoder - ReadSidewallVisionRearModuleMotorEncoder() < -20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 may collide with side wall vision rear module.\n");
	//	return false;
	//}
	return true;
}
bool CProductMotorControl::IsPickAndPlace1XAxisMotorSafeToMoveAbsolute(signed long position)
{
	signed long PickAndPlace1YAxisMotorEncoder = ReadPickAndPlace1YAxisMotorEncoder();
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis not homing yet");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace1YAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Y Axis not homing yet");
		return false;
	}
	//if (ReadPickAndPlace1ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace1ZAxisUpPosition
	//	&& ReadPickAndPlace1ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace1ZAxisUpPosition)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis not at up position");
	//	return false;
	//}
	//if (PickAndPlace1YAxisMotorEncoder - ReadSidewallVisionLeftModuleMotorEncoder() < -20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 may collide with side wall vision left module.\n");
	//	return false;
	//}
	//if (PickAndPlace1YAxisMotorEncoder - ReadSidewallVisionRearModuleMotorEncoder() < -20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 may collide with side wall vision rear module.\n");
	//	return false;
	//}
	return true;
}
signed long CProductMotorControl::ReadPickAndPlace1XAxisMotorEncoder()
{
	int nError = 0;
	signed long slPosition;
	return ReadAgitoMotorPosition(0, 0, 0);
	//return m_cMotion->GetEncoderPosition(m_motorConfiguration[13].Axis);
}
#pragma endregion

#pragma region Pick And Place 2 X Axis
int CProductMotorControl::PickAndPlace2XAxisMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnablePickAndPlace2XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (m_cProductIOControl->IsPickAndPlace2XAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(56001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsPickAndPlace2XAxisMotorHome = false;
	nError = m_cProductMotorControl->AgitoServoOn(1, 0, 0);
	RtSleepFt(&m_cProductShareVariables->m_lnPeriod_10ms);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(34001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2XAxisMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnablePickAndPlace2XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (m_cProductIOControl->IsPickAndPlace2XAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(56001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = m_cProductMotorControl->AgitoServoOn(1, 0, 1);
	RtSleepFt(&m_cProductShareVariables->m_lnPeriod_10ms);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(34001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor on error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2XAxisMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnablePickAndPlace2XAxisMotor == false)
	{
		m_cLogger->WriteLog("Pick And Place 2 X Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (m_cProductIOControl->IsPickAndPlace2XAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(56001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cLogger->WriteLog("Pick And Place 2 X Axis motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = m_cProductMotorControl->AgitoStopMotor(1, 0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 X Axis motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cProductShareVariables->SetAlarm(34001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 X Axis motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	//nError = cMotion->Reset(m_motorConfiguration[13].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 X Axis motor reset done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(34001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 X Axis motor reset error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2XAxisMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	smProductModuleStatus->IsPickAndPlace2XAxisMotorHome = false;

	if (smProductCustomize->EnablePickAndPlace2XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (m_cProductIOControl->IsPickAndPlace2XAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(56001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	if (IsPickAndPlace2XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(56010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis homing");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsPickAndPlace2XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotionMode(1,0, 1);
	nError += m_cProductMotorControl->AgitoHomeMotor(1, 0);
	//Sleep(5);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cLogger->WriteLog("Error during home Pick And Place 2 X Axis motor %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount>20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor home start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(56004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor home start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == true)
		{
			smProductModuleStatus->IsPickAndPlace2XAxisMotorHome = true;
			smProductModuleStatus->IsPickAndPlace2XAxisMoving = false;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor home done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(56004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	if (smProductEvent->JobSlow.Set == true)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		//nError = cMotion->SetControllerVariable(m_motorConfiguration[13].ControllerDetails, "vSLOW", (signed long)1);
		if (nError == 0)
		{
			return 0;
		}
		else if (nError != 0)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during set all MC5 slow on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		}
	}
	else
	{
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2XAxisMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnablePickAndPlace2XAxisMotor == false)
	{
		m_cLogger->WriteLog("Pick And Place 2 X Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Pick And Place 2 X Axis Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 X Axis motor setting done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2XAxisMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnablePickAndPlace2XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError += m_cProductMotorControl->AgitoStopMotor(1, 0);
	nError += m_cProductMotorControl->AgitoMotorSpeed1(1,0, 10000 * (speedPercent / 100), 500,
		25000 * (accelerationPercent / 100), 25000 * (accelerationPercent / 100));
	//nError += m_cProductMotorControl->AgitoMotorSpeed(1,0, (speedPercent / 100));
	//nError += m_cProductMotorControl->AgitoMotorAcceleration(1, 0,(accelerationPercent / 100));
	//nError += m_cProductMotorControl->AgitoMotorDeceleration(1,0, (accelerationPercent / 100));
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2XAxisMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;

	if (smProductCustomize->EnablePickAndPlace2XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}

	if (smProductModuleStatus->IsPickAndPlace2XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(55005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace2XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(55001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace2XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(55010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductProduction->PickAndPlace2XAxisMovePosition > smProductTeachPoint->PickAndPlace2XAxisForwardLimitPosition ||
		smProductProduction->PickAndPlace2XAxisMovePosition < smProductTeachPoint->PickAndPlace2XAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 X Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cLogger->WriteLog("Position is out of Pick And Place 2 X Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	if (smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.InputStation && smProductProduction->PickAndPlace2StationToMove != PickAndPlaceCurrentStation.BottomStation)
	{
		if (smProductProduction->PickAndPlace2StationToMove == PickAndPlaceCurrentStation.OutputStation)
		{
			if (smProductProduction->PickAndPlace2XAxisMovePosition > smProductTeachPoint->PickAndPlace2XAxisOutputPosition + (signed long)2000 ||
				smProductProduction->PickAndPlace2XAxisMovePosition < smProductTeachPoint->PickAndPlace2XAxisOutputPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 2 X Output Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
		else if (smProductProduction->PickAndPlace2XAxisMovePosition > smProductTeachPoint->PickAndPlace2XAxisInputPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace2XAxisMovePosition < smProductTeachPoint->PickAndPlace2XAxisInputPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 X Input Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 2 X Input Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if ((smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.BottomStation || smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.MovingFromInputStationToBottomStation)
			&& smProductProduction->PickAndPlace2StationToMove != PickAndPlaceCurrentStation.S3Station)
	{
		if (smProductProduction->PickAndPlace2XAxisMovePosition > smProductTeachPoint->PickAndPlace2XAxisAtS1AndBottomVisionPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace2XAxisMovePosition < smProductTeachPoint->PickAndPlace2XAxisAtS1AndBottomVisionPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 X Bottom Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 2 X Bottom Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if ((smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.S3Station || smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.MovingFromBottomStationToS3Station)
		&& smProductProduction->PickAndPlace2StationToMove != PickAndPlaceCurrentStation.OutputStation)
	{
		if (smProductProduction->PickAndPlace2XAxisMovePosition > smProductTeachPoint->PickAndPlace2XAxisAtS2AndS3VisionPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace2XAxisMovePosition < smProductTeachPoint->PickAndPlace2XAxisAtS2AndS3VisionPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 X S3 Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 2 X S3 Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	else if (smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.OutputStation && smProductProduction->PickAndPlace2StationToMove != PickAndPlaceCurrentStation.InputStation)
	{
		if (smProductProduction->PickAndPlace2XAxisMovePosition > smProductTeachPoint->PickAndPlace2XAxisOutputPosition + (signed long)2000 ||
			smProductProduction->PickAndPlace2XAxisMovePosition < smProductTeachPoint->PickAndPlace2XAxisOutputPosition - (signed long)2000)
		{
			sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 X Output Station Limit\n");
			m_cProductShareVariables->triggerUpdateMessage();
			m_cLogger->WriteLog("Position is out of Pick And Place 2 X Output Station Limit\n");
			return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == true)
		{
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace2XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotorRelative1(1, 0,long(0));
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoMotorAbsolute1(1, 0, smProductProduction->PickAndPlace2XAxisMovePosition);
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoStartMotor1(1, 0);
	//Sleep(10);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during move Pick And Place 2 X Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart3);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(55003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart3.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor wait movement start3 timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace2XAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(56002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2XAxisMotorMoveToInputPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;

	if (smProductCustomize->EnablePickAndPlace2XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}

	if (smProductModuleStatus->IsPickAndPlace2XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(56005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace2XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(56001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace2XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(56010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis move to input position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace2XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotorRelative(1,0, long(0));
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoMotorAbsolute(1, 0, smProductTeachPoint->PickAndPlace2XAxisInputPosition);
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoStartMotor(1, 0);
	//Sleep(10);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 2 X Axis motor move to input position %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor move input position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(56003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor move input position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace2XAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(56002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2XAxisMotorMoveToS1Position(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;

	if (smProductCustomize->EnablePickAndPlace2XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}

	if (smProductModuleStatus->IsPickAndPlace2XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(56005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace2XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(56001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace2XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(56010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis move to S1 position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace2XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotorRelative(1, 0,long(0));
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoMotorAbsolute(1, 0, smProductTeachPoint->PickAndPlace2XAxisAtS1AndBottomVisionPosition);
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoStartMotor(1, 0);
	//Sleep(10);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 2 X Axis motor move to S1 position %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor move S1 position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(56003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor move S1 position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace2XAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(56002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2XAxisMotorMoveToS3Position(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;

	if (smProductCustomize->EnablePickAndPlace2XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}

	if (smProductModuleStatus->IsPickAndPlace2XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(56005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace2XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(56001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace2XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(56010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis move to S3 position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace2XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotorRelative(1,0, long(0));
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoMotorAbsolute(1, 0, smProductTeachPoint->PickAndPlace2XAxisAtS2AndS3VisionPosition);
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoStartMotor(1, 0);
	//Sleep(10);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 2 X Axis motor move to S3 Vision position %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor move S3 Vision position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(56003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor move S3 Vision position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace2XAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(56002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2XAxisMotorMoveToOutputPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;

	if (smProductCustomize->EnablePickAndPlace2XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}

	if (smProductModuleStatus->IsPickAndPlace2XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(56005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace2XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(56001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace2XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(56010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis move to output position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace2XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotorRelative(1,0, long(0));
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoMotorAbsolute(1, 0, smProductTeachPoint->PickAndPlace2XAxisOutputPosition);
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoStartMotor(1, 0);
	//Sleep(10);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 2 X Axis motor move to output position %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor move output position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(56003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor move output position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace2XAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(56002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2XAxisMotorMoveToParkingPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;

	if (smProductCustomize->EnablePickAndPlace2XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor is disabled");
		return m_cProductShareVariables->Error_Disable;
	}

	if (smProductModuleStatus->IsPickAndPlace2XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(56005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (m_cProductIOControl->IsPickAndPlace2XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(56001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not ready.");
		return m_cProductShareVariables->Error_Motor;
	}
	if (IsPickAndPlace2XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(56010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis move to Parking position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace1XAxisMotorInPosition() == true)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor ready %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor is busy %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotorBusy;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	smProductModuleStatus->IsPickAndPlace2XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotorRelative(1,0, long(0));
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoMotorAbsolute(1, 0, smProductTeachPoint->PickAndPlace2XAxisParkingPosition);
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoStartMotor(1, 0);
	//Sleep(10);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Pick And Place 2 X Axis motor move to Parking position %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == false || lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 20)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor move Parking position start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(56003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor wait movement start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionStartTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		if (m_cProductIOControl->IsPickAndPlace2XAxisMotorInPosition() == true)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor move Parking position done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			smProductModuleStatus->IsPickAndPlace2XAxisMoving = false;
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(56002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis wait movement complete timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2XAxisMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnablePickAndPlace2XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsPickAndPlace2XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(56001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsPickAndPlace2XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(56005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace2XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(56010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um + smGeneral->nMotorEncoderPosition > smProductTeachPoint->PickAndPlace2XAxisForwardLimitPosition ||
		movePos_um + smGeneral->nMotorEncoderPosition < smProductTeachPoint->PickAndPlace2XAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 X Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 2 X Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	smProductModuleStatus->IsPickAndPlace2XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotorRelative(1,0, movePos_um);
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoStartMotor(1, 0);
	//Sleep(10);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis move relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		smProductModuleStatus->IsPickAndPlace2XAxisMoving = false;
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(34001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 X Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2XAxisMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;

	if (smProductCustomize->EnablePickAndPlace2XAxisMotor == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor is disabled\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (m_cProductIOControl->IsPickAndPlace2XAxisMotorReady() == false)
	{
		m_cProductShareVariables->SetAlarm(56001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not ready.\n");
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductModuleStatus->IsPickAndPlace2XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(56005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace2XAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(56010);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not Safe To Move.");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductEvent->GMAIN_RTHD_TEACHING_VISION.Set == true)
	{
		if (smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.InputStation)
		{
			if (movePos_um > smProductTeachPoint->PickAndPlace2YAxisInputPosition + (signed long)2000 ||
				movePos_um < smProductTeachPoint->PickAndPlace2YAxisInputPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 2 Y Input Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
		else if (smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.BottomStation)
		{
			if (movePos_um > smProductTeachPoint->PickAndPlace2XAxisAtS1AndBottomVisionPosition + (signed long)2000 ||
				movePos_um < smProductTeachPoint->PickAndPlace2XAxisAtS1AndBottomVisionPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 2 Y Bottom Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
		else if (smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.S3Station)
		{
			if (movePos_um > smProductTeachPoint->PickAndPlace2XAxisAtS2AndS3VisionPosition + (signed long)2000 ||
				movePos_um < smProductTeachPoint->PickAndPlace2XAxisAtS2AndS3VisionPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 2 Y S3 Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
		else if (smProductProduction->PickAndPlace2CurrentStation == PickAndPlaceCurrentStation.OutputStation)
		{
			if (movePos_um > smProductTeachPoint->PickAndPlace2YAxisOutputPosition + (signed long)2000 ||
				movePos_um < smProductTeachPoint->PickAndPlace2YAxisOutputPosition - (signed long)2000)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 2 Y Output Station Limit\n");
				return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
			}
		}
	}
	if (movePos_um > smProductTeachPoint->PickAndPlace2XAxisForwardLimitPosition ||
		movePos_um < smProductTeachPoint->PickAndPlace2XAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 X Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 2 X Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	smProductModuleStatus->IsPickAndPlace2XAxisMoving = true;
	nError += m_cProductMotorControl->AgitoMotorRelative(1,0, long(0));
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoMotorAbsolute(1, 0, movePos_um);
	//Sleep(5);
	nError += m_cProductMotorControl->AgitoStartMotor(1, 0);
	//Sleep(10);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		smProductModuleStatus->IsPickAndPlace2XAxisMoving = false;
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(34001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 X Axis move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2XAxisMotorSetStartEndPoint(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	/*//if (smProductModuleStatus->IsPickAndPlaceXAxisMotorHome == false)
	//{
	//	m_cProductShareVariables->SetAlarm(53005);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place X Axis motor not homing yet.");
	//	return m_cProductShareVariables->Error_MotorNotHomed;
	//}
	//if (m_cProductIOControl->IsPickAndPlaceModuleXAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(53001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place X Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place X Axis motor Set Start End Point");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	int nStartIndex = 0;
	int nUnitPresent = 0;
	//for (int i = 0; i < 6; i++)
	//{
	//	//if (smProductProduction->PickUpHeadStationResult[i].UnitPresent == 1)
	//	//{
	//		if (nStartIndex == 0)
	//		{
	//			nStartIndex++;
	//		}
	//		nUnitPresent = nUnitPresent + 2;
	//	//}
	//}
	nError = m_cProductMotorControl->AgitoPositionEventTriggerEventStartIndex(0, nStartIndex);
	//Sleep(5);
	nError = m_cProductMotorControl->AgitoPositionEventTriggerEventEndIndex(0, nNoOfTriggerPoint);
	//Sleep(5);
	//nError = m_cProductMotorControl->AgitoPositionEventTriggerEnable(0);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Set Pick And Place X Axis motor Start End Point %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}*/
	return 0;
}
int CProductMotorControl::PickAndPlace2XAxisMotorEnablePositionTrigger(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;


	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor Enable Trigger");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = m_cProductMotorControl->AgitoPositionEventTriggerEnable(1,0);
	//Sleep(5);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Enable Pick And Place 2 X Axis motor Position Trigger %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return 0;
}
int CProductMotorControl::PickAndPlace2XAxisMotorDisablePositionTrigger(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;

	if (smProductModuleStatus->IsPickAndPlace2XAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(56005);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	//if (m_cProductIOControl->IsPickAndPlace2XAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(56001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 X Axis DisableTrigger");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	nError = m_cProductMotorControl->AgitoPositionEventTriggerDisable(1,0);
	//Sleep(5);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(34001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during Enable Pick And Place 2 X Axis motor Position Trigger %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return 0;
}
bool CProductMotorControl::IsPickAndPlace2XAxisMotorSafeToMove()
{
	signed long PickAndPlace2YAxisMotorEncoder = ReadPickAndPlace2YAxisMotorEncoder();
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis not homing yet");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace2YAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis not homing yet");
		return false;
	}

	//if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
	//	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis not at up position");
	//	return false;
	//}
	//if (PickAndPlace2YAxisMotorEncoder + ReadSidewallVisionFrontModuleMotorEncoder() >20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 may collide with side wall vision front module.\n");
	//	return false;
	//}
	//if (PickAndPlace2YAxisMotorEncoder + ReadSidewallVisionRightModuleMotorEncoder()>20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 may collide with side wall vision right module.\n");
	//	return false;
	//}
	return true;
}
bool CProductMotorControl::IsPickAndPlace2XAxisMotorSafeToMoveRelative(signed long position)
{
	signed long PickAndPlace2YAxisMotorEncoder = ReadPickAndPlace2YAxisMotorEncoder();
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis not homing yet");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace2YAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis not homing yet");
		return false;
	}

	//if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
	//	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis not at up position");
	//	return false;
	//}
	//if (PickAndPlace2YAxisMotorEncoder + ReadSidewallVisionFrontModuleMotorEncoder() > 20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 may collide with side wall vision front module.\n");
	//	return false;
	//}
	//if (PickAndPlace2YAxisMotorEncoder + ReadSidewallVisionRightModuleMotorEncoder() > 20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 may collide with side wall vision right module.\n");
	//	return false;
	//}
	return true;
}
bool CProductMotorControl::IsPickAndPlace2XAxisMotorSafeToMoveAbsolute(signed long position)
{
	signed long PickAndPlace2YAxisMotorEncoder = ReadPickAndPlace2YAxisMotorEncoder();
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis not homing yet");
		return false;
	}
	if (smProductModuleStatus->IsPickAndPlace2YAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Y Axis not homing yet");
		return false;
	}

	//if (ReadPickAndPlace2ZAxisMotorEncoder() != smProductTeachPoint->PickAndPlace2ZAxisUpPosition
	//	&& ReadPickAndPlace2ZAxisMotorEncoder() < smProductTeachPoint->PickAndPlace2ZAxisUpPosition)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis not at up position");
	//	return false;
	//}
	//if (PickAndPlace2YAxisMotorEncoder + ReadSidewallVisionFrontModuleMotorEncoder() > 20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 may collide with side wall vision front module.\n");
	//	return false;
	//}
	//if (PickAndPlace2YAxisMotorEncoder + ReadSidewallVisionRightModuleMotorEncoder() > 20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 may collide with side wall vision right module.\n");
	//	return false;
	//}
	return true;
}
signed long CProductMotorControl::ReadPickAndPlace2XAxisMotorEncoder()
{
	int nError = 0;
	signed long slPosition;
	return ReadAgitoMotorPosition(1, 0, 0);
	//return m_cMotion->GetEncoderPosition(m_motorConfiguration[13].Axis);
}
#pragma endregion

#pragma region Pick And Place 1 Z Axis
int CProductMotorControl::PickAndPlace1ZAxisMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome = false;
	nError = THKServoOffZAxis(0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ZAxisMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = THKServoOnZAxis(0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor on error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ZAxisMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}

	m_cLogger->WriteLog("Pick And Place 1 Z Axis motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = THKStopMotor(0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 1 Z Axis motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 1 Z Axis motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ZAxisMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (IsPickAndPlace1ZAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(11012);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis homing");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = THKHomeMotorZAxisMotor(0);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(35001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Pick And Place 1 Z Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	else
	{
		smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome = true;
		//smProductModuleStatus->IsPickAndPlace1ThetaAxisMotorHome = true;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor home done.");
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ZAxisMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}

	m_cLogger->WriteLog("Pick And Place 1 Z Axis Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	// confirm again
	//nError = m_cProductMotorControl->THKSetTargetValue5(0, (signed long)smProductTeachPoint->PickAndPlace1ZAxisUpPosition + (signed long)smProductSetting->UnitThickness_um);
	if (nError != 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Error setting up Pick And Place 1 Z Axis Up Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Done setting up Pick And Place 1 Z Axis Up Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ZAxisMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ZAxisMotorMoveUpPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	signed long currentEncoder = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(11007);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace1ZAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(11012);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Pickup Head (Z Axis motor) move up");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	nError += THKReadEncoderValue(0, 0, &currentEncoder);
	nError += THKInchingValue(0, 0, ((smProductTeachPoint->PickAndPlace1ZAxisUpPosition + signed long(smProductSetting->UnitThickness_um)) - currentEncoder));
	nError += THKZAxisInchingUp(0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Pickup Head (Z Axis) move done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Pickup Head (Z Axis) send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ZAxisMotorMoveInputDownPosition(CMotionLibrary *cMotion, bool TrueToDown)
{
	int nError = 0;
	signed long currentEncoder = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(11007);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace1ZAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(11012);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (TrueToDown == true)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Pickup Head (Z Axis motor) move input tray down position");
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Pickup Head (Z Axis motor) move input tray softlanding position");
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	nError = THKReadEncoderValue(0, 0, &currentEncoder);
	signed long slPickAndPlace1ZAxisAtInputTrayDownPosition = smProductTeachPoint->PickAndPlace1ZAxisAtInputTrayTouchingPosition + signed long(smProductSetting->UnitThickness_um);
	if (TrueToDown == true)
	{
		nError += THKInchingValue(0, 0, (slPickAndPlace1ZAxisAtInputTrayDownPosition - currentEncoder));
	}
	else
	{
		nError += THKInchingValue(0, 0, (smProductTeachPoint->PickAndPlace1ZAxisAtInputTraySoftlandingPosition - currentEncoder));
	}
	nError += THKZAxisInching(0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Pickup Head (Z Axis) move done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Pickup Head (Z Axis) send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ZAxisMotorMoveOutputDownPosition(CMotionLibrary *cMotion, bool TrueToDown)
{
	int nError = 0;
	signed long currentEncoder = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(11007);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace1ZAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(11012);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (TrueToDown == true)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Pickup Head (Z Axis motor) move output tray down position");
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Pickup Head (Z Axis motor) move output tray softlanding position");
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	nError += THKReadEncoderValue(0, 0, &currentEncoder);
	signed long slPickAndPlace1ZAxisAtOutputTrayDownPosition = smProductTeachPoint->PickAndPlace1ZAxisAtOutputTrayTouchingPosition + signed long(smProductSetting->UnitThickness_um);
	if (TrueToDown == true)
	{
		nError += THKInchingValue(0, 0, (slPickAndPlace1ZAxisAtOutputTrayDownPosition - currentEncoder));
	}
	else
	{
		nError += THKInchingValue(0, 0, (smProductTeachPoint->PickAndPlace1ZAxisAtOutputTraySoftlandingPosition - currentEncoder));
	}
	nError += THKZAxisInching(0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Pickup Head (Z Axis) move done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Pickup Head (Z Axis) send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ZAxisMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (IsPickupHead1ZAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(11001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 Z Axis Motor not ready.\n");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(11007);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace1ZAxisMotorSafeToMoveRelative(movePos_um + smGeneral->nMotorEncoderPosition) == false)
	{
		m_cProductShareVariables->SetAlarm(11012);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	//confirm again
	if (movePos_um + smGeneral->nMotorEncoderPosition > smProductTeachPoint->PickAndPlace1ZAxisForwardLimitPosition ||
		movePos_um + smGeneral->nMotorEncoderPosition < smProductTeachPoint->PickAndPlace1ZAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 Z Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 1 Z Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Pickup Head (Z Axis) move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	//nError = cMotion->Reset(m_motorConfiguration[14].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(35001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Pickup Head (Z Axis motor) send command stop thread %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//sprintf_s(command, sizeof(command), "PRC=%u;BGC;AMC;", (int)((double)movePos_um / m_motorConfiguration[14].UnitInOnePulse));
	//nError = cMotion->SendCommand(m_motorConfiguration[14].ControllerDetails, command);
	nError += THKInchingValue(0, 0, (double)movePos_um);
	nError += THKZAxisInching(0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Pickup Head (Z Axis) move relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Pickup Head (Z Axis) send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ZAxisMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (IsPickupHead1ZAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(11001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 Z Axis Motor not ready.\n");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	if (IsPickAndPlace1ZAxisMotorSafeToMoveAbsolute(movePos_um) == false)
	{
		m_cProductShareVariables->SetAlarm(11012);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(11007);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	//confirm again
	if (movePos_um > smProductTeachPoint->PickAndPlace1ZAxisForwardLimitPosition ||
		movePos_um < smProductTeachPoint->PickAndPlace1ZAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 Z Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 1 Z Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	//nError = cMotion->Reset(m_motorConfiguration[14].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(35001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Pick And Place 1 Z Axis motor thread 0 %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	signed long encoderValue = 0;
	m_cProductMotorControl->THKReadEncoderValue(0, 0, &encoderValue);
	//sprintf_s(command, sizeof(command), "PAC=%u;BGC;AMC;", (int)((double)movePos_um / m_motorConfiguration[14].UnitInOnePulse));
	//nError = cMotion->SendCommand(m_motorConfiguration[14].ControllerDetails, command);
	nError += THKInchingValue(0, 0, (double)(movePos_um - encoderValue));
	nError += THKZAxisInching(0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ZAxisMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	signed long currentEncoder = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(11007);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace1ZAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(11012);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductProduction->PickAndPlace1ZAxisMovePosition > smProductTeachPoint->PickAndPlace1ZAxisForwardLimitPosition ||
		smProductProduction->PickAndPlace1ZAxisMovePosition < smProductTeachPoint->PickAndPlace1ZAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 Z Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cLogger->WriteLog("Position is out of Pick And Place 1 Z Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	nError += THKReadEncoderValue(0, 0, &currentEncoder);
	nError += THKInchingValue(0, 0, (smProductProduction->PickAndPlace1ZAxisMovePosition - currentEncoder));
	nError += THKZAxisInching(0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis move done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Z Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
bool CProductMotorControl::IsPickAndPlace1ZAxisMotorSafeToMove()
{
	signed long PickAndPlace1YAxisMotorEncoder = ReadPickAndPlace1YAxisMotorEncoder();
	//if (m_cProductIOControl->IsBottomVisionBacklightDownSensorOn() == false
	//	|| m_cProductIOControl->IsBottomVisionBacklightUpSensorOn() == true)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Bottom Vision Backlight not down.\n");
	//	return false;
	//}
	//if (PickAndPlace1YAxisMotorEncoder - ReadSidewallVisionLeftModuleMotorEncoder() < -20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis may collide with side wall vision left module.\n");
	//	return false;
	//}
	//if (PickAndPlace1YAxisMotorEncoder - ReadSidewallVisionRearModuleMotorEncoder() < -20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis may collide with side wall vision rear module.\n");
	//	return false;
	//}
	return true;
}
bool CProductMotorControl::IsPickAndPlace1ZAxisMotorSafeToMoveRelative(signed long position)
{
	//signed long PickAndPlace1YAxisMotorEncoder = ReadPickAndPlace1YAxisMotorEncoder();
	//if (m_cProductIOControl->IsSW2N3VisionLightingDownSensor() == false
	//	|| m_cProductIOControl->IsSW2N3VisionLightingUpSensor() == true)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Bottom Vision Backlight not down");
	//	return false;
	//}
	//if (PickAndPlace1YAxisMotorEncoder - ReadSidewallVisionLeftModuleMotorEncoder() < -20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis may collide with side wall vision left module.\n");
	//	return false;
	//}
	//if (PickAndPlace1YAxisMotorEncoder - ReadSidewallVisionRearModuleMotorEncoder() < -20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis may collide with side wall vision rear module.\n");
	//	return false;
	//}

	return true;
}
bool CProductMotorControl::IsPickAndPlace1ZAxisMotorSafeToMoveAbsolute(signed long position)
{
	signed long PickAndPlace1XAxisMotorEncoder = ReadPickAndPlace1XAxisMotorEncoder();
	signed long PickAndPlace1YAxisMotorEncoder = ReadPickAndPlace1YAxisMotorEncoder();
	if (smProductModuleStatus->IsPickAndPlace1XAxisMotorHome
		&& smProductModuleStatus->IsPickAndPlace1YAxisMotorHome
		&& PickAndPlace1XAxisMotorEncoder < smProductTeachPoint->PickAndPlace1XAxisAtS1AndBottomVisionPosition + (signed long)2000
		&& PickAndPlace1XAxisMotorEncoder > smProductTeachPoint->PickAndPlace1XAxisAtS1AndBottomVisionPosition - (signed long)2000
		&& PickAndPlace1YAxisMotorEncoder < smProductTeachPoint->PickAndPlace1YAxisAtS1AndBottomVisionPosition + (signed long)2000
		&& PickAndPlace1YAxisMotorEncoder > smProductTeachPoint->PickAndPlace1YAxisAtS1AndBottomVisionPosition - (signed long)2000
		)
	{

	}
	//else if (m_cProductIOControl->IsSW2N3VisionLightingDownSensor() == false
	//	|| m_cProductIOControl->IsSW2N3VisionLightingUpSensor() == true)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Bottom Vision Backlight not down");
	//	return false;
	//}
	//if (PickAndPlace1YAxisMotorEncoder - ReadSidewallVisionLeftModuleMotorEncoder() < -20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis may collide with side wall vision left module.\n");
	//	return false;
	//}
	//if (PickAndPlace1YAxisMotorEncoder - ReadSidewallVisionRearModuleMotorEncoder() < -20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis may collide with side wall vision rear module.\n");
	//	return false;
	//}
	return true;
}
signed long CProductMotorControl::ReadPickAndPlace1ZAxisMotorEncoder()
{
	int nError = 0;
	signed long slPosition;
	nError = THKReadEncoderValue(0, 0, &slPosition);
	if (slPosition < 0)
	{
		slPosition = 180000 - slPosition;
	}
	return slPosition;
}
#pragma endregion

#pragma region Pick And Place 2 Z Axis
int CProductMotorControl::PickAndPlace2ZAxisMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (IsPickupHead2ZAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(12001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 2 Z Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome = false;
	nError = THKServoOffZAxis(1);
	//nError = cMotion->MotorOff(m_motorConfiguration[14].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ZAxisMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (IsPickupHead2ZAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(12001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 2 Z Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	//nError = cMotion->MotorOn(m_motorConfiguration[14].Axis);
	nError = THKServoOnZAxis(1);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor on error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ZAxisMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Pick And Place 2 Z Axis motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	//smProductModuleStatus->IsInputTableThetaAxisMotorHome = false;
	//nError = cMotion->MotorStop(m_motorConfiguration[14].Axis);
	//nError= THKS
	nError = THKStopMotor(1);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 Z Axis motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 Z Axis motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	//nError = cMotion->Reset(m_motorConfiguration[14].Axis);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 Z Axis motor reset done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 Z Axis motor reset error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ZAxisMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (IsPickAndPlace2ZAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(12012);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	//if (IsPickupHead2ZAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(12001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 2 Z Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis homing");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	//nError = cMotion->Reset(m_motorConfiguration[14].Axis);
	//if (nError != 0)
	//{
	//	m_cProductShareVariables->SetAlarm(35001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Pick And Place Pickup Head 2 Z Axis motor thread 0 %u.", nError);
	//	return m_cProductShareVariables->Error_SendCommand;
	//}


	//if (nError != 0)
	//{
	//	m_cProductShareVariables->SetAlarm(35001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during reset Pick And Place Pickup Head 2 Z Axis home offset %u.", nError);
	//	return m_cProductShareVariables->Error_SendCommand;
	//}
	//nError = THKVacuumValveOff(1);
	nError = THKHomeMotorZAxisMotor(1);
	//nError = cMotion->MotorHomeAsychronous(m_motorConfiguration[14].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(35001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Pick And Place 2 Z Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	else
	{
		smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome = true;
		//smProductModuleStatus->IsPickAndPlace2ThetaAxisMotorHome = true;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor home done.");
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ZAxisMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Pick And Place 2 Z Axis Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	//nError = m_cProductMotorControl->THKSetTargetValue5(1, (signed long)smProductTeachPoint->PickAndPlace2ZAxisUpPosition + signed long(smProductSetting->UnitThickness_um));
	if (nError != 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Error setting up Pick And Place 2 Z Axis Up Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Done setting up Pick And Place 2 Z Axis Up Position %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}

	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 Z Axis motor setting done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ZAxisMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	//nError = cMotion->MotorStop(m_motorConfiguration[14].Axis);
	//sprintf_s(command, sizeof(command), "SPC=vSPC*(%u/100);ACC=vACC*(%u/100);DCC=vDCC*(%u/100);", speedPercent, accelerationPercent, accelerationPercent);
	//nError = cMotion->SendCommand(m_motorConfiguration[14].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ZAxisMotorMoveUpPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	signed long currentEncoder = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(12007);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace2ZAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(12012);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor move up");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	nError += THKReadEncoderValue(1, 0, &currentEncoder);
	nError += THKInchingValue(1, 0, ((smProductTeachPoint->PickAndPlace2ZAxisUpPosition + signed long(smProductSetting->UnitThickness_um)) - currentEncoder));
	nError += THKZAxisInchingUp(1);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis move done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ZAxisMotorMoveInputDownPosition(CMotionLibrary *cMotion, bool TrueToDown)
{
	int nError = 0;
	signed long currentEncoder = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(12007);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace2ZAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(12012);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (TrueToDown == true)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Pickup Head (Z Axis motor) move input tray down position");
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Pickup Head (Z Axis motor) move input tray softlanding position");
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	nError += THKReadEncoderValue(1, 0, &currentEncoder);
	signed long slPickAndPlace2ZAxisAtInputTrayDownPosition = smProductTeachPoint->PickAndPlace2ZAxisAtInputTrayTouchingPosition + signed long(smProductSetting->UnitThickness_um);
	if (TrueToDown == true)
	{
		nError += THKInchingValue(1, 0, (slPickAndPlace2ZAxisAtInputTrayDownPosition - currentEncoder));
	}
	else
	{
		nError += THKInchingValue(1, 0, (smProductTeachPoint->PickAndPlace2ZAxisAtInputTraySoftlandingPosition - currentEncoder));
	}
	nError += THKZAxisInching(1);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Pickup Head (Z Axis) move done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Pickup Head (Z Axis) send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ZAxisMotorMoveOutputDownPosition(CMotionLibrary *cMotion, bool TrueToDown)
{
	int nError = 0;
	signed long currentEncoder = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(12007);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace1ZAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(12012);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (TrueToDown == true)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Pickup Head (Z Axis motor) move Output tray down position");
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Pickup Head (Z Axis motor) move Output tray softlanding position");
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	nError += THKReadEncoderValue(1, 0, &currentEncoder);
	signed long slPickAndPlace2ZAxisAtOutputTrayDownPosition = smProductTeachPoint->PickAndPlace2ZAxisAtOutputTrayTouchingPosition + signed long(smProductSetting->UnitThickness_um);
	if (TrueToDown == true)
	{
		nError += THKInchingValue(1, 0, (slPickAndPlace2ZAxisAtOutputTrayDownPosition - currentEncoder));
	}
	else
	{
		nError += THKInchingValue(1, 0, (smProductTeachPoint->PickAndPlace2ZAxisAtOutputTraySoftlandingPosition - currentEncoder));
	}
	nError += THKZAxisInching(1);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Pickup Head (Z Axis) move done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Pickup Head (Z Axis) send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ZAxisMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (IsPickupHead2ZAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(12001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 2 Z Axis Motor not ready.\n");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(12007);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace2ZAxisMotorSafeToMoveRelative(movePos_um + smGeneral->nMotorEncoderPosition) == false)
	{
		m_cProductShareVariables->SetAlarm(12012);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um + smGeneral->nMotorEncoderPosition > smProductTeachPoint->PickAndPlace2ZAxisForwardLimitPosition ||
		movePos_um + smGeneral->nMotorEncoderPosition < smProductTeachPoint->PickAndPlace2ZAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 Z Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 2 Z Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	//nError = cMotion->Reset(m_motorConfiguration[14].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(35001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis motor send command stop thread %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//sprintf_s(command, sizeof(command), "PRC=%u;BGC;AMC;", (int)((double)movePos_um / m_motorConfiguration[14].UnitInOnePulse));
	//nError = cMotion->SendCommand(m_motorConfiguration[14].ControllerDetails, command);
	nError += THKInchingValue(1, 0, (double)movePos_um);
	nError += THKZAxisInching(1);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis move relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ZAxisMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_um)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (IsPickupHead2ZAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(12001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 2 Z Axis Motor not ready.\n");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(12007);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace2ZAxisMotorSafeToMoveAbsolute(movePos_um) == false)
	{
		m_cProductShareVariables->SetAlarm(12012);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (movePos_um > smProductTeachPoint->PickAndPlace2ZAxisForwardLimitPosition ||
		movePos_um < smProductTeachPoint->PickAndPlace2ZAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 Z Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 2 Z Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	//nError = cMotion->Reset(m_motorConfiguration[14].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(35001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Pick And Place 2 Z Axis motor thread 0 %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	signed long encoderValue = 0;
	m_cProductMotorControl->THKReadEncoderValue(1, 0, &encoderValue);
	//sprintf_s(command, sizeof(command), "PAC=%u;BGC;AMC;", (int)((double)movePos_um / m_motorConfiguration[14].UnitInOnePulse));
	//nError = cMotion->SendCommand(m_motorConfiguration[14].ControllerDetails, command);
	nError += THKInchingValue(1, 0, (double)(movePos_um - encoderValue));
	nError += THKZAxisInching(1);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ZAxisMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	signed long currentEncoder = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(12007);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace2ZAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(12012);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	//if (IsPickupHead2ZAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(12001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 2 Z Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 2 Z Axis motor move");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);

	if (smProductProduction->PickAndPlace2ZAxisMovePosition > smProductTeachPoint->PickAndPlace2ZAxisForwardLimitPosition ||
		smProductProduction->PickAndPlace2ZAxisMovePosition < smProductTeachPoint->PickAndPlace2ZAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 Z Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cLogger->WriteLog("Position is out of Pick And Place 2 Z Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	nError += THKReadEncoderValue(1, 0, &currentEncoder);
	nError += THKInchingValue(1, 0, (smProductProduction->PickAndPlace2ZAxisMovePosition - currentEncoder));
	nError += THKZAxisInching(1);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis move done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Z Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
bool CProductMotorControl::IsPickAndPlace2ZAxisMotorSafeToMove()
{
	signed long PickAndPlace2YAxisMotorEncoder = ReadPickAndPlace2YAxisMotorEncoder();
	//if (m_cProductIOControl->IsBottomVisionBacklightDownSensorOn() == false
	//	|| m_cProductIOControl->IsBottomVisionBacklightUpSensorOn() == true)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Bottom Vision Backlight not down");
	//	return false;
	//}
	//if (PickAndPlace2YAxisMotorEncoder + ReadSidewallVisionFrontModuleMotorEncoder() > 20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis may collide with side wall vision front module.\n");
	//	return false;
	//}
	//if (PickAndPlace2YAxisMotorEncoder + ReadSidewallVisionRightModuleMotorEncoder() > 20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis may collide with side wall vision right module.\n");
	//	return false;
	//}
	//if (ReadSidewallVisionFrontModuleMotorEncoder)
	return true;
}
bool CProductMotorControl::IsPickAndPlace2ZAxisMotorSafeToMoveRelative(signed long position)
{
	//signed long PickAndPlace2YAxisMotorEncoder = ReadPickAndPlace2YAxisMotorEncoder();
	//if (m_cProductIOControl->IsSW2N3VisionLightingDownSensor() == false
	//	|| m_cProductIOControl->IsSW2N3VisionLightingUpSensor() == true)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Bottom Vision Backlight not down");
	//	return false;
	//}
	//if (PickAndPlace2YAxisMotorEncoder + ReadSidewallVisionFrontModuleMotorEncoder() > 20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis may collide with side wall vision front module.\n");
	//	return false;
	//}
	//if (PickAndPlace2YAxisMotorEncoder + ReadSidewallVisionRightModuleMotorEncoder() > 20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis may collide with side wall vision right module.\n");
	//	return false;
	//}
	//if (ReadSidewallVisionFrontModuleMotorEncoder)

	return true;
}
bool CProductMotorControl::IsPickAndPlace2ZAxisMotorSafeToMoveAbsolute(signed long position)
{
	signed long PickAndPlace2XAxisMotorEncoder = ReadPickAndPlace2XAxisMotorEncoder();
	signed long PickAndPlace2YAxisMotorEncoder = ReadPickAndPlace2YAxisMotorEncoder();
	if (smProductModuleStatus->IsPickAndPlace2XAxisMotorHome
		&& smProductModuleStatus->IsPickAndPlace2YAxisMotorHome
		&& PickAndPlace2XAxisMotorEncoder < smProductTeachPoint->PickAndPlace2XAxisAtS1AndBottomVisionPosition + (signed long)2000
		&& PickAndPlace2XAxisMotorEncoder > smProductTeachPoint->PickAndPlace2XAxisAtS1AndBottomVisionPosition - (signed long)2000
		&& PickAndPlace2YAxisMotorEncoder < smProductTeachPoint->PickAndPlace2YAxisAtS1AndBottomVisionPosition + (signed long)2000
		&& PickAndPlace2YAxisMotorEncoder > smProductTeachPoint->PickAndPlace2YAxisAtS1AndBottomVisionPosition - (signed long)2000
		)
	{

	}
	//else if (m_cProductIOControl->IsSW2N3VisionLightingDownSensor() == false
	//	|| m_cProductIOControl->IsSW2N3VisionLightingUpSensor() == true)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Bottom Vision Backlight not down");
	//	return false;
	//}	
	//if (PickAndPlace2YAxisMotorEncoder + ReadSidewallVisionFrontModuleMotorEncoder() > 20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis may collide with side wall vision front module.\n");
	//	return false;
	//}
	//if (PickAndPlace2YAxisMotorEncoder + ReadSidewallVisionRightModuleMotorEncoder() > 20000)
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis may collide with side wall vision right module.\n");
	//	return false;
	//}
	//if (ReadSidewallVisionFrontModuleMotorEncoder)

	return true;
}
signed long CProductMotorControl::ReadPickAndPlace2ZAxisMotorEncoder()
{
	int nError = 0;
	signed long slPosition;
	nError = THKReadEncoderValue(1, 0, &slPosition);
	if (slPosition < 0)
	{
		slPosition = 180000 - slPosition;
	}
	return slPosition;
}
#pragma endregion

#pragma region Pick And Place 1 T Axis
int CProductMotorControl::PickAndPlace1ThetaAxisMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (IsPickupHead1RotationAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(11001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 Rotation Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsPickAndPlace1ThetaAxisMotorHome = false;
	//nError = cMotion->MotorOff(m_motorConfiguration[20].Axis);
	nError += THKServoOffThetaAxis(0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ThetaAxisMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (IsPickupHead1RotationAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(11001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 Rotation Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	//nError = cMotion->MotorOn(m_motorConfiguration[20].Axis);
	nError += THKServoOnThetaAxis(0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis motor on error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ThetaAxisMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Pick And Place 1 Theta Axis motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	//smProductModuleStatus->IsInputTableThetaAxisMotorHome = false;
	//nError = cMotion->MotorStop(m_motorConfiguration[20].Axis);
	nError += THKStopMotor(0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 1 Theta Axis motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 1 Theta Axis motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 1 Theta Axis motor reset done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 1 Theta Axis motor reset error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ThetaAxisMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (IsPickAndPlace1ThetaAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(11024);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis homing");
	nError = THKHomeThetaAxisMotor(0);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(35001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Pick And Place 1 Theta Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	else
	{
		//smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome = true;
		smProductModuleStatus->IsPickAndPlace1ThetaAxisMotorHome = true;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis motor home done.");
	}
	//while (smProductEvent->ExitRTX.Set == false)
	//{
	//	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	//	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	//	if (IsPickupHead1RotationAxisMotorInPosition() == false)
	//	{
	//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 Rotation Axis motor home start %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	//		break;
	//	}
	//	else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
	//	{
	//		m_cProductShareVariables->SetAlarm(11004);
	//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 Rotation Axis motor home start timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	//		return m_cProductShareVariables->Error_MotionTimeOut;
	//	}
	//	RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	//}
	//while (smProductEvent->ExitRTX.Set == false)
	//{
	//	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	//	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	//	if (IsPickupHead1RotationAxisMotorInPosition() == true)
	//	{
	//		smProductModuleStatus->IsPickAndPlacePickupHead1RotationAxisMotorHome = true;
	//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 Rotation Axis motor home done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	//		break;
	//	}
	//	else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
	//	{
	//		m_cProductShareVariables->SetAlarm(11004);
	//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 Rotation Axis motor home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	//		return m_cProductShareVariables->Error_MotionTimeOut;
	//	}
	//	RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	//}

	//if (smProductEvent->JobSlow.Set == true)
	//{
	//	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	//	nError = cMotion->SetControllerVariable(m_motorConfiguration[20].ControllerDetails, "vSLOW", (signed long)1);
	//	if (nError == 0)
	//	{
	//		return 0;
	//	}
	//	else if (nError != 0)
	//	{
	//		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	//		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during set all MC1 slow on %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	//	}
	//}
	//else
	//{
	return 0;
	//}
	return -1;
}
int CProductMotorControl::PickAndPlace1ThetaAxisMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Pick And Place 1 Theta Axis Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	// nError += cMotion->SetControllerVariable(m_motorConfiguration[20].ControllerDetails, "vIPTTCTR", (signed long)(((double)smProductTeachPoint->InputTableThetaAxisCenterPosition) / m_motorConfiguration[20].UnitInOnePulse));
	// nError += cMotion->SetControllerVariable(m_motorConfiguration[20].ControllerDetails, "vIPTTLD", (signed long)(((double)smProductTeachPoint->InputTableThetaAxisLoadUnloadPosition) / m_motorConfiguration[20].UnitInOnePulse));
	// nError += cMotion->SetControllerVariable(m_motorConfiguration[20].ControllerDetails, "vIPTTBAR", (signed long)(((double)(smProductTeachPoint->InputTableThetaAxisLoadUnloadPosition + smProductSetting->BarcodeThetaPosition_mDegree)) / m_motorConfiguration[20].UnitInOnePulse));
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 1 Theta Axis motor setting done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ThetaAxisMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	//nError = cMotion->MotorStop(m_motorConfiguration[20].Axis);
	//sprintf_s(command, sizeof(command), "SPC=vSPC*(%u/100);ACC=vACC*(%u/100);DCC=vDCC*(%u/100);", speedPercent, accelerationPercent, accelerationPercent);
	//nError = cMotion->SendCommand(m_motorConfiguration[20].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ThetaAxisMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	signed long currentEncoder = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace1ThetaAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(11020);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace1ThetaAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(11024);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductProduction->PickAndPlace1ThetaAxisMovePosition > smProductTeachPoint->PickAndPlace1ThetaAxisForwardLimitPosition ||
		smProductProduction->PickAndPlace1ThetaAxisMovePosition < smProductTeachPoint->PickAndPlace1ThetaAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 Theta Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cLogger->WriteLog("Position is out of Pick And Place 1 Theta Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	//if (IsPickupHead1RotationAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(11001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 Rotation Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 Rotation Axis motor move");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);

	nError += THKReadEncoderValue(0, 1, &currentEncoder);
	nError += THKInchingValue(0, 1, (smProductProduction->PickAndPlace1ThetaAxisMovePosition - currentEncoder));
	nError += THKThetaAxisInching(0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis move done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Theta Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ThetaAxisMotorMoveStandbyPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	signed long currentEncoder = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (IsPickAndPlace1ThetaAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(11024);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductModuleStatus->IsPickAndPlace1ThetaAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(11020);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis Axis motor move to Standby position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	nError += THKReadEncoderValue(0, 1, &currentEncoder);
	nError += THKInchingValue(0, 1, (smProductTeachPoint->PickAndPlace1ThetaAxisStandbyPosition - currentEncoder));
	nError += THKThetaAxisInching(0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis move done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Theta Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ThetaAxisMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_mDegree)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (IsPickAndPlace1ThetaAxisMotorSafeToMoveRelative(movePos_mDegree + smGeneral->nMotorEncoderPosition) == false)
	{
		m_cProductShareVariables->SetAlarm(11024);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	//if (IsPickupHead1RotationAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(11001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 Rotation Axis Motor not ready.\n");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	if (smProductModuleStatus->IsPickAndPlace1ThetaAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(11020);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (movePos_mDegree + smGeneral->nMotorEncoderPosition > 720000 ||
		movePos_mDegree + smGeneral->nMotorEncoderPosition < -360000)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 1 Theta Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 1 Theta Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	//nError = cMotion->Reset(m_motorConfiguration[20].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(35001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Theta Axis motor send command stop thread %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//sprintf_s(command, sizeof(command), "PRC=%u;BGC;AMC;", (int)((double)movePos_mDegree / m_motorConfiguration[20].UnitInOnePulse));
	//nError = cMotion->SendCommand(m_motorConfiguration[20].ControllerDetails, command);
	nError += THKInchingValue(0, 1, movePos_mDegree);
	nError += THKThetaAxisInching(0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis move relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Theta Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace1ThetaAxisMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_mDegree)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (IsPickAndPlace1ThetaAxisMotorSafeToMoveAbsolute(movePos_mDegree) == false)
	{
		m_cProductShareVariables->SetAlarm(11024);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	//if (IsPickupHead1RotationAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(11001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 Rotation Axis Motor not ready.\n");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	if (smProductModuleStatus->IsPickAndPlace1ThetaAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(11020);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}

	//if (movePos_mDegree > smProductTeachPoint->InputTableThetaAxisForwardLimitPosition ||
	//		movePos_mDegree < smProductTeachPoint->InputTableThetaAxisReverseLimitPosition)
	//{
	//	sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place X Limit\n");
	//	m_cProductShareVariables->triggerUpdateMessage();
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place X Limit\n");
	//	return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	//}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	//nError = cMotion->Reset(m_motorConfiguration[20].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(35001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Pick And Place 1 Theta Axis motor thread 0 %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	signed long encoderValue = 0;
	m_cProductMotorControl->THKReadEncoderValue(0, 1, &encoderValue);
	//sprintf_s(command, sizeof(command), "PAC=%u;BGC;AMC;", (int)((double)movePos_mDegree / m_motorConfiguration[20].UnitInOnePulse));
	//nError = cMotion->SendCommand(m_motorConfiguration[20].ControllerDetails, command);
	nError += THKInchingValue(0, 1, (double)(movePos_mDegree - encoderValue));
	nError += THKThetaAxisInching(0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Theta Axis move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 1 Theta Axis move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
bool CProductMotorControl::IsPickAndPlace1ThetaAxisMotorSafeToMove()
{
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis Motor Not Yet Home");
		return false;
	}
	return true;
}
bool CProductMotorControl::IsPickAndPlace1ThetaAxisMotorSafeToMoveRelative(signed long position)
{
	int ret = 0;
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis Motor Not Yet Home");
		return false;
	}
	return true;
}
bool CProductMotorControl::IsPickAndPlace1ThetaAxisMotorSafeToMoveAbsolute(signed long position)
{
	int ret = 0;
	if (smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Z Axis Motor Not Yet Home");
		return false;
	}
	return true;
}
signed long CProductMotorControl::ReadPickAndPlace1ThetaAxisMotorEncoder()
{
	int nError = 0;
	signed long slPosition;
	nError = THKReadEncoderValue(0, 1, &slPosition);
	return slPosition;
}
#pragma endregion

#pragma region Pick And Place 2 T Axis
int CProductMotorControl::PickAndPlace2ThetaAxisMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (IsPickupHead2RotationAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(12001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 2 Rotation Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsPickAndPlace2ThetaAxisMotorHome = false;
	//nError = cMotion->MotorOff(m_motorConfiguration[20].Axis);
	nError = THKServoOffThetaAxis(1);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ThetaAxisMotorOn(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (IsPickupHead2RotationAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(12001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 2 Rotation Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis motor On");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	//nError = cMotion->MotorOn(m_motorConfiguration[20].Axis);
	nError = THKServoOnThetaAxis(1);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis motor on done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis motor on error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ThetaAxisMotorStop(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Pick And Place 2 Theta Axis motor stop\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	//smProductModuleStatus->IsInputTableThetaAxisMotorHome = false;
	//nError = cMotion->MotorStop(m_motorConfiguration[20].Axis);
	nError = THKStopMotor(1);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 Theta Axis motor stop done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 Theta Axis motor stop error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 Theta Axis motor reset done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 Theta Axis motor reset error send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ThetaAxisMotorHome(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (IsPickAndPlace2ThetaAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(12024);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	//if (IsPickupHead2RotationAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(12001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 2 Rotation Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis homing");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	//nError = cMotion->Reset(m_motorConfiguration[20].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(35001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Pick And Place 2 Theta Axis motor thread 0 %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	//nError = cMotion->SetControllerVariable(m_motorConfiguration[20].ControllerDetails, "vIPTTHM", (signed long)0);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(35001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during reset Pick And Place 2 Theta Axis home offset %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}

	//nError = cMotion->MotorHomeAsychronous(m_motorConfiguration[20].Axis);
	//nError = THKVacuumValveOff(1);
	nError = THKHomeThetaAxisMotor(1);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(35001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during home Pick And Place 2 Theta Axis motor %u.", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	else
	{
		//smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome = true;
		smProductModuleStatus->IsPickAndPlace2ThetaAxisMotorHome = true;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis motor home done.");
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ThetaAxisMotorSettingUp(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cLogger->WriteLog("Pick And Place 2 Theta Axis Motor setting up\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	// nError += cMotion->SetControllerVariable(m_motorConfiguration[20].ControllerDetails, "vIPTTCTR", (signed long)(((double)smProductTeachPoint->InputTableThetaAxisCenterPosition) / m_motorConfiguration[20].UnitInOnePulse));
	// nError += cMotion->SetControllerVariable(m_motorConfiguration[20].ControllerDetails, "vIPTTLD", (signed long)(((double)smProductTeachPoint->InputTableThetaAxisLoadUnloadPosition) / m_motorConfiguration[20].UnitInOnePulse));
	// nError += cMotion->SetControllerVariable(m_motorConfiguration[20].ControllerDetails, "vIPTTBAR", (signed long)(((double)(smProductTeachPoint->InputTableThetaAxisLoadUnloadPosition + smProductSetting->BarcodeThetaPosition_mDegree)) / m_motorConfiguration[20].UnitInOnePulse));
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cLogger->WriteLog("Pick And Place 2 Theta Axis motor setting done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ThetaAxisMotorSetSpeedAndAcceleration(CMotionLibrary *cMotion, int speedPercent, int accelerationPercent)
{
	int nError = 0;
	char command[80];
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis Motor set speed and acceleration");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	//nError = cMotion->MotorStop(m_motorConfiguration[20].Axis);
	//sprintf_s(command, sizeof(command), "SPC=vSPC*(%u/100);ACC=vACC*(%u/100);DCC=vDCC*(%u/100);", speedPercent, accelerationPercent, accelerationPercent);
	//nError = cMotion->SendCommand(m_motorConfiguration[20].ControllerDetails, command);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis motor setting done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ThetaAxisMotorMove(CMotionLibrary *cMotion)
{
	int nError = 0;
	signed long currentEncoder = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2, lnClockStart3;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace2ThetaAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(12019);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace2ThetaAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(12024);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductProduction->PickAndPlace2ThetaAxisMovePosition > smProductTeachPoint->PickAndPlace2ThetaAxisForwardLimitPosition ||
		smProductProduction->PickAndPlace2ThetaAxisMovePosition < smProductTeachPoint->PickAndPlace2ThetaAxisReverseLimitPosition)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 Theta Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cLogger->WriteLog("Position is out of Pick And Place 2 Theta Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}
	//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 2 Rotation Axis motor move");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);

	nError += THKReadEncoderValue(1, 1, &currentEncoder);
	nError += THKInchingValue(1, 1, (smProductProduction->PickAndPlace2ThetaAxisMovePosition - currentEncoder));
	nError += THKThetaAxisInching(1);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis move done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Theta Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ThetaAxisMotorMoveStandbyPosition(CMotionLibrary *cMotion)
{
	int nError = 0;
	signed long currentEncoder = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (smProductModuleStatus->IsPickAndPlace2ThetaAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(12019);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis motor not homing yet.");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (IsPickAndPlace2ThetaAxisMotorSafeToMove() == false)
	{
		m_cProductShareVariables->SetAlarm(12024);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	//if (IsPickupHead2RotationAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(12001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 2 Rotation Axis Motor not ready.");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis Axis motor move to Standby position");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	nError += THKReadEncoderValue(1, 1, &currentEncoder);
	nError += THKInchingValue(1, 1, (smProductTeachPoint->PickAndPlace2ThetaAxisStandbyPosition - currentEncoder));
	nError += THKThetaAxisInching(1);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis move done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Theta Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ThetaAxisMotorMoveRelative(CMotionLibrary *cMotion, signed long movePos_mDegree)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	if (IsPickAndPlace2ThetaAxisMotorSafeToMoveRelative(movePos_mDegree + smGeneral->nMotorEncoderPosition) == false)
	{
		m_cProductShareVariables->SetAlarm(12024);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	//if (IsPickupHead2RotationAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(12001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 2 Rotation Axis Motor not ready.\n");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	if (smProductModuleStatus->IsPickAndPlace2ThetaAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(12019);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}
	if (movePos_mDegree + smGeneral->nMotorEncoderPosition > 720000 ||
		movePos_mDegree + smGeneral->nMotorEncoderPosition < -360000)
	{
		sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place 2 Theta Limit\n");
		m_cProductShareVariables->triggerUpdateMessage();
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place 2 Theta Limit\n");
		return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis move relative\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	//nError = cMotion->Reset(m_motorConfiguration[20].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(35001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Theta Axis motor send command stop thread %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	//sprintf_s(command, sizeof(command), "PRC=%u;BGC;AMC;", (int)((double)movePos_mDegree / m_motorConfiguration[20].UnitInOnePulse));
	//nError = cMotion->SendCommand(m_motorConfiguration[20].ControllerDetails, command);
	nError += THKInchingValue(1, 1, movePos_mDegree);
	nError += THKThetaAxisInching(1);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis move relative done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Theta Axis send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
int CProductMotorControl::PickAndPlace2ThetaAxisMotorMoveAbsolute(CMotionLibrary *cMotion, signed long movePos_mDegree)
{
	int nError = 0;
	char command[80];

	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.\n");
		return m_cProductShareVariables->Error_Disable;
	}
	//if (IsPickupHead2RotationAxisMotorReady() == false)
	//{
	//	m_cProductShareVariables->SetAlarm(12001);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 2 Rotation Axis Motor not ready.\n");
	//	return m_cProductShareVariables->Error_Motor;
	//}
	if (IsPickAndPlace2ThetaAxisMotorSafeToMoveAbsolute(movePos_mDegree) == false)
	{
		m_cProductShareVariables->SetAlarm(12024);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis motor Not Safe To Move");
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductModuleStatus->IsPickAndPlace2ThetaAxisMotorHome == false)
	{
		m_cProductShareVariables->SetAlarm(12019);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis motor not homing yet.\n");
		return m_cProductShareVariables->Error_MotorNotHomed;
	}

	//if (movePos_mDegree > smProductTeachPoint->InputTableThetaAxisForwardLimitPosition ||
	//		movePos_mDegree < smProductTeachPoint->InputTableThetaAxisReverseLimitPosition)
	//{
	//	sprintf_s(smGeneral->MessageStatus, sizeof(smGeneral->MessageStatus), "Position is out of Pick And Place X Limit\n");
	//	m_cProductShareVariables->triggerUpdateMessage();
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Position is out of Pick And Place X Limit\n");
	//	return m_cProductShareVariables->Error_MotorPositionOutOfLimit;
	//}

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis move absolute\n");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);

	//nError = cMotion->Reset(m_motorConfiguration[20].Axis);
	if (nError != 0)
	{
		m_cProductShareVariables->SetAlarm(35001);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error during stop Pick And Place 2 Theta Axis motor thread 0 %u.\n", nError);
		return m_cProductShareVariables->Error_SendCommand;
	}
	signed long encoderValue = 0;
	m_cProductMotorControl->THKReadEncoderValue(1, 1, &encoderValue);
	//sprintf_s(command, sizeof(command), "PAC=%u;BGC;AMC;", (int)((double)movePos_mDegree / m_motorConfiguration[20].UnitInOnePulse));
	//nError = cMotion->SendCommand(m_motorConfiguration[20].ControllerDetails, command);
	nError += THKInchingValue(1, 1, (double)(movePos_mDegree - encoderValue));
	nError += THKThetaAxisInching(1);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Theta Axis move absolute done %ums.\n", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Error Pick And Place 2 Theta Axis move absolute send command %u %ums.\n", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
bool CProductMotorControl::IsPickAndPlace2ThetaAxisMotorSafeToMove()
{
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis Motor Not Yet Home");
		return false;
	}
	return true;
}
bool CProductMotorControl::IsPickAndPlace2ThetaAxisMotorSafeToMoveRelative(signed long position)
{
	int ret = 0;
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis Motor Not Yet Home");
		return false;
	}
	return true;
}
bool CProductMotorControl::IsPickAndPlace2ThetaAxisMotorSafeToMoveAbsolute(signed long position)
{
	int ret = 0;
	if (smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Z Axis Motor Not Yet Home");
		return false;
	}
	return true;
}
signed long CProductMotorControl::ReadPickAndPlace2ThetaAxisMotorEncoder()
{
	int nError = 0;
	signed long slPosition;
	nError = THKReadEncoderValue(1, 1, &slPosition);
	return slPosition;
}
#pragma endregion

int CProductMotorControl::PickAndPlace1THKMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace1Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 THK motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsPickAndPlace1ZAxisMotorHome = false;
	nError = THKServoOff(0);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 THK motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 THK motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}

int CProductMotorControl::PickAndPlace2THKMotorOff(CMotionLibrary *cMotion)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan;
	if (smProductCustomize->EnablePickAndPlace2Module == false)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Module is disabled.");
		return m_cProductShareVariables->Error_Disable;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 THK motor off");
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	smProductModuleStatus->IsPickAndPlace2ZAxisMotorHome = false;
	nError = THKServoOff(1);
	if (nError == 0)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 THK motor off done %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->SetAlarm(35001);
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 THK motor off error send command %u %ums.", nError, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return m_cProductShareVariables->Error_SendCommand;
	}
	return -1;
}
bool CProductMotorControl::IsAllPickupHeadAtSafetyPosition()
{
	if (ReadPickAndPlace1ZAxisMotorEncoder() < -8000)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 1 Pickup Head at Down Position.\n");
		return false;
	}
	if (ReadPickAndPlace2ZAxisMotorEncoder() < -8000)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place 2 Pickup Head at Down Position.\n");
		return false;
	}
	return true;
}

#pragma region KingStar
int CProductMotorControl::THKInitialize(unsigned int NoOfIndex)
{
	int nError = 0;
	EnterCriticalSection(&csKingStarSendCommand);
	nError = m_cMotion->m_kingstarController->KSInitialize();
	//Sleep(15);
	if (nError == 0)
	{

		LeaveCriticalSection(&csKingStarSendCommand);
		return 0;
	}
	else
	{

		LeaveCriticalSection(&csKingStarSendCommand);
		return nError;
	}
}
int CProductMotorControl::THKConnect(unsigned int NoOfIndex)
{
	int nError = 0;
	EnterCriticalSection(&csKingStarSendCommand);
	//nError = THKReadMotorServoOnOff(NoOfIndex);
	//if (nError == -1)
	//{
	//nError = m_cMotion->Connect(m_cProductMotorControl->m_motorConfiguration[16].Axis);
	//m_cMotion->
	//nError = m_cMotion->m_kingstarController->KSInitialize();
	//Sleep(15);
	nError = m_cMotion->m_kingstarController->KSConnect();
	//nError = m_cMotion->m_kingstarController->m_nErrorCode;
	if (nError != 0)
	{
		m_cLogger->WriteLog("Connect error %s", m_cMotion->m_kingstarController->m_strErrorMsg);
		return -1;
	}
	else
	{
		Sleep(100);
		smProductEvent->InitializeMotionController7Done.Set = true;
	}
	Sleep(15);
	if (nError == 0)
	{
		if (smProductCustomize->EnablePickAndPlace1Module == true)
			nError += THKResetAlarm(0);

		if (smProductCustomize->EnablePickAndPlace2Module == true)
			nError += THKResetAlarm(1);
		if (nError != 0)
		{

			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head Fail Reset Alarm.");
			LeaveCriticalSection(&csKingStarSendCommand);
			return -1;
		}
		LeaveCriticalSection(&csKingStarSendCommand);
		return 0;
	}
	else
	{

		LeaveCriticalSection(&csKingStarSendCommand);
		return nError;
	}
	//}
	//else
	//{
	//	smProductModuleStatus->IsKingStarConnected = true;
	//	return 0;
	//}
}
int CProductMotorControl::THKReconnect(unsigned int NoOfIndex)
{
	int nError = 0;
	EnterCriticalSection(&csKingStarSendCommand);
	//nError = THKReadMotorServoOnOff(NoOfIndex);
	//if (nError == -1)
	//{
	//nError = m_cMotion->Connect(m_cProductMotorControl->m_motorConfiguration[16].Axis);
	//m_cMotion->
	nError = m_cMotion->m_kingstarController->KSDisconnect();
	Sleep(15);
	nError = m_cMotion->m_kingstarController->KSInitialize();
	Sleep(15);
	nError = m_cMotion->m_kingstarController->KSConnect();
	//nError = m_cMotion->m_kingstarController->m_nErrorCode;
	if (nError != 0)
	{
		m_cLogger->WriteLog("KingStar: %s", m_cMotion->m_kingstarController->m_strErrorMsg);

		LeaveCriticalSection(&csKingStarSendCommand);
		return -1;
	}
	Sleep(15);
	if (nError == 0)
	{
		if (smProductCustomize->EnablePickAndPlace1Module == true)
			nError += THKResetAlarm(0);

		if (smProductCustomize->EnablePickAndPlace2Module == true)
			nError += THKResetAlarm(1);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head Fail Reset Alarm.");
			LeaveCriticalSection(&csKingStarSendCommand);
			return -1;
		}
		LeaveCriticalSection(&csKingStarSendCommand);
		return 0;
	}
	else
	{
		LeaveCriticalSection(&csKingStarSendCommand);
		return nError;
	}
	//}
	//else
	//{
	//	smProductModuleStatus->IsKingStarConnected = true;
	//	return 0;
	//}
}
int CProductMotorControl::THKResetAlarm(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", NoOfIndex + 1);
			return nError;
		}
	}
	EnterCriticalSection(&csKingStarSendCommand);
	if (NoOfIndex == 0)
	{
		if (smProductCustomize->EnablePickAndPlace1Module == true)
		{
			nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 4);
			Sleep(5);
			nError += m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
		}
	}
	if (NoOfIndex == 1)
	{
		if (smProductCustomize->EnablePickAndPlace2Module == true)
		{
			nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 4);
			Sleep(5);
			nError += m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
		}
	}
	LeaveCriticalSection(&csKingStarSendCommand);
	return nError;
}
int CProductMotorControl::THKDisconnect(unsigned int NoOfIndex)
{
	//m_cMotion->Disconnect(m_cProductMotorControl->m_motorConfiguration[16].Axis);
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSDisconnect();
	smProductEvent->InitializeMotionController7Done.Set = false;
	Sleep(5);
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}
int CProductMotorControl::THKUserSettingOrigin(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	//if (IsTHKZAxisSafeToMove(NoOfIndex) == false)
	//{
	//	return m_cProductShareVariables->Error_MotorNotSafeToMove;
	//}
	if (THKReadMotorServoOnOff(NoOfIndex, 0) == 0)
	{
		//nError = THKServoOn(NoOfIndex);
		//if (nError != 0)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 motor On Motor Fail.");
		//	return nError;
		//}
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor z inching %d.", (NoOfIndex + 1));
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Z Inching command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10009);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Z Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Z Inching Command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10009);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Z Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching Error.", (NoOfIndex + 1));
	}

	if (THKReadControllerStatus(NoOfIndex, 3, 0) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head %dInching error 2.", (NoOfIndex + 1));
	}
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 136);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	LeaveCriticalSection(&csKingStarSendCommand);

	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
		{
			EnterCriticalSection(&csKingStarSendCommand);
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			LeaveCriticalSection(&csKingStarSendCommand);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head inching start %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10008);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head inching start timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		int nAlarmCode = THKReadAlarm(NoOfIndex);
		if (nAlarmCode == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Sequence Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (nAlarmCode != 0)
		{
			THKResetAlarm(NoOfIndex);
			//m_cProductShareVariables->SetAlarm(10005);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move With Error Code %d in %ums.", (NoOfIndex + 1), nAlarmCode, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10006);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Sequence Done timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}

int CProductMotorControl::THKServoOn(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", NoOfIndex + 1);
			return nError;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor On command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10001);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor On timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor on %d.", (NoOfIndex + 1));
	if (THKReadMotorServoOnOff(NoOfIndex, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Is Already Motor On.", (NoOfIndex + 1));
		return 0;
	}
	else if (THKReadMotorServoOnOff(NoOfIndex, 0) == 0)
	{
		EnterCriticalSection(&csKingStarSendCommand);
		m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 129);
		m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
		//LeaveCriticalSection(&csKingStarSendReadCommand);
		//EnterCriticalSection(&csKingStarSendReadCommand);
		//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
		LeaveCriticalSection(&csKingStarSendCommand);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//THKReadMotorServoStatus(NoOfIndex, 0);
			//if (THKReadControllerStatus(NoOfIndex) == 1)
			if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
			{
				EnterCriticalSection(&csKingStarSendCommand);
				m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
				LeaveCriticalSection(&csKingStarSendCommand);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor On command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10001);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor On timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//THKReadMotorServoStatus(NoOfIndex, 0);
			//if (THKReadControllerStatus(NoOfIndex) == 1)
			if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
			{
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return 0;
				break;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10002);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}

		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			THKReadMotorServoStatus(NoOfIndex, 0);
			if (smProductGeneral->nMotorOnStatus == 1)
			{
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head motor On done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return 0;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10001);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Motor On timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Read Motor Status Error.", (NoOfIndex + 1));
		return -1;
	}
	return 0;
}
int CProductMotorControl::THKServoOnZAxis(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", NoOfIndex + 1);
			return nError;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor On command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10001);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor On timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor on %d.", (NoOfIndex + 1));
	if (THKReadMotorServoOnOff(NoOfIndex, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Is Already Motor On.", (NoOfIndex + 1));
		return 0;
	}
	else if (THKReadMotorServoOnOff(NoOfIndex, 0) == 0)
	{
		EnterCriticalSection(&csKingStarSendCommand);
		m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 147);
		m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
		//LeaveCriticalSection(&csKingStarSendReadCommand);
		//EnterCriticalSection(&csKingStarSendReadCommand);
		//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
		LeaveCriticalSection(&csKingStarSendCommand);

		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//THKReadMotorServoStatus(NoOfIndex, 0);
			//if (THKReadControllerStatus(NoOfIndex) == 1)
			if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
			{
				EnterCriticalSection(&csKingStarSendCommand);
				m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
				LeaveCriticalSection(&csKingStarSendCommand);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor On command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10001);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor On timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//THKReadMotorServoStatus(NoOfIndex, 0);
			//if (THKReadControllerStatus(NoOfIndex) == 1)
			if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
			{
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return 0;
				break;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10002);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			THKReadMotorServoStatus(NoOfIndex, 0);
			if (smProductGeneral->nMotorOnStatus == 1)
			{
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head motor On done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return 0;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10001);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Motor On timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Read Motor Status Error.", (NoOfIndex + 1));
		return -1;
	}
	return 0;
}
int CProductMotorControl::THKServoOnThetaAxis(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", NoOfIndex + 1);
			return nError;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Check done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10001);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor On timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Check2 Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor on %d.", (NoOfIndex + 1));
	if (THKReadMotorServoOnOff(NoOfIndex, 1) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Is Already Motor On.", (NoOfIndex + 1));
		return 0;
	}
	else if (THKReadMotorServoOnOff(NoOfIndex,1) == 0)
	{
		EnterCriticalSection(&csKingStarSendCommand);
		m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 148);
		m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
		//LeaveCriticalSection(&csKingStarSendReadCommand);
		//EnterCriticalSection(&csKingStarSendReadCommand);
		//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
		LeaveCriticalSection(&csKingStarSendCommand);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//THKReadMotorServoStatus(NoOfIndex, 0);
			//if (THKReadControllerStatus(NoOfIndex) == 1)
			if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
			{
				EnterCriticalSection(&csKingStarSendCommand);
				m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
				LeaveCriticalSection(&csKingStarSendCommand);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Check done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10001);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor On timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//THKReadMotorServoStatus(NoOfIndex, 0);
			//if (THKReadControllerStatus(NoOfIndex) == 1)
			if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
			{
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Check2 Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return 0;
				break;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10002);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			THKReadMotorServoStatus(NoOfIndex, 1);
			if (smProductGeneral->nMotorOnStatus == 1)
			{
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head motor On done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return 0;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10001);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Motor On timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Read Motor Status Error.", (NoOfIndex + 1));
		return -1;
	}
	return 0;
}
int CProductMotorControl::THKServoOff(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;

	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", NoOfIndex + 1);
			return nError;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor off %d.", (NoOfIndex + 1));
	if (THKReadMotorServoOnOff(NoOfIndex, 0) == 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Is Already Motor Off.", (NoOfIndex + 1));
		return 0;
	}
	else if (THKReadMotorServoOnOff(NoOfIndex, 0) == 1)
	{
		EnterCriticalSection(&csKingStarSendCommand);
		m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 130);
		m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		//EnterCriticalSection(&csKingStarSendReadCommand);
		//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
		//LeaveCriticalSection(&csKingStarSendReadCommand);
		//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
		LeaveCriticalSection(&csKingStarSendCommand);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//THKReadMotorServoStatus(NoOfIndex, 0);
			//if (THKReadControllerStatus(NoOfIndex) == 1)
			if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
			{
				EnterCriticalSection(&csKingStarSendCommand);
				m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
				LeaveCriticalSection(&csKingStarSendCommand);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10003);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//THKReadMotorServoStatus(NoOfIndex, 0);
			//if (THKReadControllerStatus(NoOfIndex) == 1)
			if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
			{
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return 0;
				break;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10003);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			THKReadMotorServoStatus(NoOfIndex, 0);
			if (smProductGeneral->nMotorOnStatus == 0)
			{
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head motor Off done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return 0;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10003);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Motor Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Read Motor Status Error.", NoOfIndex + 1);
		return -1;
	}
	return 0;
}
int CProductMotorControl::THKServoOffZAxis(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;

	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", NoOfIndex + 1);
			return nError;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor off %d.", (NoOfIndex + 1));
	if (THKReadMotorServoOnOff(NoOfIndex, 0) == 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Is Already Motor Off.", (NoOfIndex + 1));
		return 0;
	}
	else if (THKReadMotorServoOnOff(NoOfIndex, 0) == 1)
	{
		EnterCriticalSection(&csKingStarSendCommand);
		m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 149);
		m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		//EnterCriticalSection(&csKingStarSendReadCommand);
		//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
		//LeaveCriticalSection(&csKingStarSendReadCommand);
		//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
		LeaveCriticalSection(&csKingStarSendCommand);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//THKReadMotorServoStatus(NoOfIndex, 0);
			//if (THKReadControllerStatus(NoOfIndex) == 1)
			if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
			{
				EnterCriticalSection(&csKingStarSendCommand);
				m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
				LeaveCriticalSection(&csKingStarSendCommand);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10003);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//THKReadMotorServoStatus(NoOfIndex, 0);
			//if (THKReadControllerStatus(NoOfIndex) == 1)
			if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
			{
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return 0;
				break;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10003);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			THKReadMotorServoStatus(NoOfIndex, 0);
			if (smProductGeneral->nMotorOnStatus == 0)
			{
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head motor Off done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return 0;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10003);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Motor Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Read Motor Status Error.", NoOfIndex + 1);
		return -1;
	}
	return 0;
}
int CProductMotorControl::THKServoOffThetaAxis(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;

	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", NoOfIndex + 1);
			return nError;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10003);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor off %d.", (NoOfIndex + 1));
	if (THKReadMotorServoOnOff(NoOfIndex, 1) == 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Is Already Motor Off.", (NoOfIndex + 1));
		return 0;
	}
	else if (THKReadMotorServoOnOff(NoOfIndex, 1) == 1)
	{
		EnterCriticalSection(&csKingStarSendCommand);
		m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 150);
		m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		//EnterCriticalSection(&csKingStarSendReadCommand);
		//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
		//LeaveCriticalSection(&csKingStarSendReadCommand);
		//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
		LeaveCriticalSection(&csKingStarSendCommand);
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//THKReadMotorServoStatus(NoOfIndex, 0);
			//if (THKReadControllerStatus(NoOfIndex) == 1)
			if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
			{
				EnterCriticalSection(&csKingStarSendCommand);
				m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
				LeaveCriticalSection(&csKingStarSendCommand);
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				break;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10003);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//THKReadMotorServoStatus(NoOfIndex, 0);
			//if (THKReadControllerStatus(NoOfIndex) == 1)
			if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
			{
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				//return 0;
				break;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10003);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Motor Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
		while (smProductEvent->ExitRTX.Set == false)
		{
			RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			THKReadMotorServoStatus(NoOfIndex, 1);
			if (smProductGeneral->nMotorOnStatus == 0)
			{
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head motor Off done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return 0;
			}
			else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
			{
				m_cProductShareVariables->SetAlarm(10003);
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Motor Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return m_cProductShareVariables->Error_MotionTimeOut;
			}
			RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
		}
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Read Motor Status Error.", NoOfIndex + 1);
		return -1;
	}
	return 0;
}
int CProductMotorControl::THKHomeMotor(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (IsTHKZAxisSafeToMoveUp(NoOfIndex) == false)
	{
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	if (THKReadMotorServoOnOff(NoOfIndex, 3) == 0)
	{
		nError += THKServoOnZAxis(NoOfIndex);
		nError += THKServoOnThetaAxis(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head motor On Motor Fail.", (NoOfIndex + 1));
			return nError;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor home %d.", (NoOfIndex + 1));

	if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Error.", (NoOfIndex + 1));
	}

	if (THKReadControllerStatus(NoOfIndex, 3, 0) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing error 2.", (NoOfIndex + 1));
	}

	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 133);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	LeaveCriticalSection(&csKingStarSendCommand);

	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
		{
			EnterCriticalSection(&csKingStarSendCommand);
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			LeaveCriticalSection(&csKingStarSendCommand);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head homing start %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head homing start timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head homing Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head homing timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}


	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Home Done.", NoOfIndex + 1);
	//while (smProductEvent->ExitRTX.Set == false)
	//{
	//	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	//	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

	//	if (THKReadControllerStatus(NoOfIndex) == 1)
	//	{
	nError = m_cProductMotorControl->THKInchingValue(NoOfIndex, 0, -1000);//0 for z 
	nError += m_cProductMotorControl->THKZAxisInching(NoOfIndex);
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching After Home Done.", NoOfIndex + 1);
	if (nError == 0)
	{
		nError = THKSetOriginValue(NoOfIndex, 0, 0);
		nError += THKResetForceOriginValue(NoOfIndex);
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Reset Origin After Home Done.", NoOfIndex + 1);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Set Origin Fail %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return nError;
		}
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head motor Home done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head motor Move Down Fail %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return nError;
	}
	//	}
	//	else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
	//	{
	//		m_cProductShareVariables->SetAlarm(42002);
	//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 wait Motor Home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	//		return m_cProductShareVariables->Error_MotionTimeOut;
	//	}
	//	RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	//}
	return 0;
}
int CProductMotorControl::THKHomeMotorZAxisMotor(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	//if (IsTHKZAxisSafeToMove(NoOfIndex) == false)
	//{
	//	return m_cProductShareVariables->Error_MotorNotSafeToMove;
	//}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	if (THKReadMotorServoOnOff(NoOfIndex, 0) == 0)
	{
		nError = THKServoOnZAxis(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head motor On Motor Fail.", (NoOfIndex + 1));
			return nError;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor home %d.", (NoOfIndex + 1));

	if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Error.", (NoOfIndex + 1));
	}

	if (THKReadControllerStatus(NoOfIndex, 3, 0) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing error 2.", (NoOfIndex + 1));
	}

	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 151);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	LeaveCriticalSection(&csKingStarSendCommand);

	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
		{
			EnterCriticalSection(&csKingStarSendCommand);
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			LeaveCriticalSection(&csKingStarSendCommand);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head homing start %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head homing start timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			THKUserOriginSetting(NoOfIndex,0);
			THKUserSettingOrigin(NoOfIndex);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head homing Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head homing timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}


	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Home Done.", NoOfIndex + 1);
	//while (smProductEvent->ExitRTX.Set == false)
	//{
	//	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	//	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

	//	if (THKReadControllerStatus(NoOfIndex) == 1)
	//	{
	//nError = m_cProductMotorControl->THKInchingValue(NoOfIndex, 0, -1000);//0 for z 
	//nError += m_cProductMotorControl->THKZAxisInching(NoOfIndex);
	//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching After Home Done.", NoOfIndex + 1);
	//if (nError == 0)
	//{
	//	//1.0.0.0c Thor 20220415
	//	//nError = THKSetOriginValue(NoOfIndex, 0, 0);
	//	//--
	//	//nError += THKResetForceOriginValue(NoOfIndex);
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Reset Origin After Home Done.", NoOfIndex + 1);
	//	if (nError != 0)
	//	{
	//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Set Origin Fail %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	//		return nError;
	//	}
	//	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head motor Home done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	//	return 0;
	//}
	//else
	//{
	//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head motor Move Down Fail %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	//	return nError;
	//}
	//	}
	//	else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
	//	{
	//		m_cProductShareVariables->SetAlarm(42002);
	//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 wait Motor Home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	//		return m_cProductShareVariables->Error_MotionTimeOut;
	//	}
	//	RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	//}
	return 0;
}
int CProductMotorControl::THKHomeThetaAxisMotor(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	//if (IsTHKZAxisSafeToMove(NoOfIndex) == false)
	//{
	//	return m_cProductShareVariables->Error_MotorNotSafeToMove;
	//}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	if (THKReadMotorServoOnOff(NoOfIndex, 1) == 0)
	{
		nError = THKServoOnThetaAxis(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head motor On Motor Fail.", (NoOfIndex + 1));
			return nError;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor home %d.", (NoOfIndex + 1));

	if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Error.", (NoOfIndex + 1));
	}

	if (THKReadControllerStatus(NoOfIndex, 3, 0) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing error 2.", (NoOfIndex + 1));
	}

	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 152);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	LeaveCriticalSection(&csKingStarSendCommand);

	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
		{
			EnterCriticalSection(&csKingStarSendCommand);
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			LeaveCriticalSection(&csKingStarSendCommand);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head homing start %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head homing start timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head homing Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->HOMING_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head homing timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}


	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Home Done.", NoOfIndex + 1);
	//while (smProductEvent->ExitRTX.Set == false)
	//{
	//	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	//	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		//if (THKReadControllerStatus(NoOfIndex) == 1)
		//{
			//nError = m_cProductMotorControl->THKInchingValue(NoOfIndex, 0, -1000);//0 for z 
			//nError += m_cProductMotorControl->THKZAxisInching(NoOfIndex);
			//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching After Home Done.", NoOfIndex + 1);
			//if (nError == 0)
			//{
			//1.0.0.0c Thor 20220415
			nError = THKSetOriginValue(NoOfIndex, 0, 0);
			//--
			nError += THKResetForceOriginValue(NoOfIndex);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Reset Origin After Home Done.", NoOfIndex + 1);
			if (nError != 0)
			{
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Set Origin Fail %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return nError;
			}
			else
			{
				lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
				m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head motor Home done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
				return 0;
			}
			//}
			//else
			//{
			//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head motor Move Down Fail %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//	return nError;
			//}
	//	}
	//	else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
	//	{
	//		m_cProductShareVariables->SetAlarm(42002);
	//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 wait Motor Home timeout %ums.", lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	//		return m_cProductShareVariables->Error_MotionTimeOut;
	//	}
	//	RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	//}
	return 0;
}
int CProductMotorControl::THKZAxisInching(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	//if (IsTHKZAxisSafeToMove(NoOfIndex) == false)
	//{
	//	return m_cProductShareVariables->Error_MotorNotSafeToMove;
	//}
	if (THKReadMotorServoOnOff(NoOfIndex, 0) == 0)
	{
		//nError = THKServoOn(NoOfIndex);
		//if (nError != 0)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 motor On Motor Fail.");
		//	return nError;
		//}
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor z inching %d.", (NoOfIndex + 1));
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Z Inching command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10009);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Z Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Z Inching Command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10009);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Z Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching Error.", (NoOfIndex + 1));
	}

	if (THKReadControllerStatus(NoOfIndex, 3, 0) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head %dInching error 2.", (NoOfIndex + 1));
	}
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 134);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	LeaveCriticalSection(&csKingStarSendCommand);

	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
		{
			EnterCriticalSection(&csKingStarSendCommand);
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			LeaveCriticalSection(&csKingStarSendCommand);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head inching start %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10008);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head inching start timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		int nAlarmCode = THKReadAlarm(NoOfIndex);
		if (nAlarmCode == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Sequence Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (nAlarmCode != 0)
		{
			THKResetAlarm(NoOfIndex);
			m_cProductShareVariables->SetAlarm(10005);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move With Error Code %d in %ums.", (NoOfIndex + 1), nAlarmCode, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_Motor;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10006);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Sequence Done timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::THKZAxisInchingUp(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (IsTHKZAxisSafeToMoveUp(NoOfIndex) == false)
	{
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (THKReadMotorServoOnOff(NoOfIndex, 0) == 0)
	{
		//nError = THKServoOn(NoOfIndex);
		//if (nError != 0)
		//{
		//	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head 1 motor On Motor Fail.");
		//	return nError;
		//}
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor z inching up %d.", (NoOfIndex + 1));
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Z Inching up command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10009);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Z Inching up timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Z Inching Command Up Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10009);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Z Inching up timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching Up Error.", (NoOfIndex + 1));
	}

	if (THKReadControllerStatus(NoOfIndex, 3, 0) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head %dInching up error 2.", (NoOfIndex + 1));
	}
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 134);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	LeaveCriticalSection(&csKingStarSendCommand);

	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
		{
			EnterCriticalSection(&csKingStarSendCommand);
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			LeaveCriticalSection(&csKingStarSendCommand);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head inching up start %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10008);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head inching start up timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching up Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching up timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching command up done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching up timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		int nAlarmCode = THKReadAlarm(NoOfIndex);
		if (nAlarmCode == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Sequence up Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (nAlarmCode != 0)
		{
			THKResetAlarm(NoOfIndex);
			m_cProductShareVariables->SetAlarm(10005);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move up With Error Code %u in %ums.", (NoOfIndex + 1), nAlarmCode, lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_Motor;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10006);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Sequence up Done timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::THKThetaAxisInching(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (THKReadMotorServoOnOff(NoOfIndex, 1) == 0)
	{
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Theta Inching command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10007);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Theta Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Theta Inching Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10007);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Theta Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor Theta inching %d.", (NoOfIndex + 1));

	if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching Error.", (NoOfIndex + 1));
	}

	if (THKReadControllerStatus(NoOfIndex, 3, 0) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Inching error 2.", (NoOfIndex + 1));
	}
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 135);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	LeaveCriticalSection(&csKingStarSendCommand);

	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
		{
			EnterCriticalSection(&csKingStarSendCommand);
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			LeaveCriticalSection(&csKingStarSendCommand);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Theta inching start %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10010);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Theta inching start timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Theta Inching Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10007);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Theta Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Theta Inching command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10007);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Theta Inching timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		if (THKReadAlarm(NoOfIndex) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Theta Inching Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (THKReadAlarm(NoOfIndex) != 0)
		{
			THKResetAlarm(NoOfIndex);
			m_cProductShareVariables->SetAlarm(10005);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Error %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_Motor;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10007);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Inching Theta Done timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return 0;
}
int CProductMotorControl::THKPick(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (IsTHKZAxisSafeToMove(NoOfIndex) == false)
	{
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (THKReadMotorServoOnOff(NoOfIndex, 3) == 0)
	{
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
			LeaveCriticalSection(&csKingStarSendCommand);
			return nError;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Pick command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10011);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Pick timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head %d Pick Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10011);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Pick timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	//if (NoOfIndex == 0)
	//{
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Start Pick.", (NoOfIndex + 1));
	EnterCriticalSection(&csKingStarSendCommand);
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head In Pick.", (NoOfIndex + 1));
	if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Pick Error.", (NoOfIndex + 1));
	}

	if (THKReadControllerStatus(NoOfIndex, 3, 0) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Pick error 2.", (NoOfIndex + 1));
	}
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 1);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);


	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Done Pick.", (NoOfIndex + 1));
	LeaveCriticalSection(&csKingStarSendCommand);
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head After Pick.", (NoOfIndex + 1));
	//}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
		{
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Pick start %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10011);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Pick timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Pick Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10011);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Pick timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	if (THKReadControllerStatus(NoOfIndex, 3, 1) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Sequence Stop %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return -1;
	}

	if (THKReadControllerStatus(NoOfIndex, 3, 2) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Sequence TimeOut %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return -1;
	}

	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Pick command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10011);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Pick timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		if (THKReadAlarm(NoOfIndex) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Sequence Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (THKReadAlarm(NoOfIndex) != 0)
		{
			THKResetAlarm(NoOfIndex);
			m_cProductShareVariables->SetAlarm(10005);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Error %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_Motor;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10006);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Sequence Done timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return -1;
}
int CProductMotorControl::IsTHKZAxisSafeToMove(unsigned int NoOfIndex)
{
	if (NoOfIndex == 0)
	{
		if (smProductModuleStatus->IsPickAndPlace1XAxisMoving == true
			|| smProductModuleStatus->IsPickAndPlace1YAxisMoving == true)
		{
			return false;
		}
	}
	else if (NoOfIndex == 1)
	{
		if (smProductModuleStatus->IsPickAndPlace2XAxisMoving == true
			|| smProductModuleStatus->IsPickAndPlace2YAxisMoving == true)
		{
			return false;
		}
	}

	return true;
}
int CProductMotorControl::IsTHKZAxisSafeToMoveUp(unsigned int NoOfIndex)
{
	//if (NoOfIndex == 0)
	//{
	//	if (smProductModuleStatus->IsPickAndPlace1XAxisMoving == true
	//		|| smProductModuleStatus->IsPickAndPlace1YAxisMoving == true)
	//	{
	//		return false;
	//	}
	//}
	//else if (NoOfIndex == 1)
	//{
	//	if (smProductModuleStatus->IsPickAndPlace2XAxisMoving == true
	//		|| smProductModuleStatus->IsPickAndPlace2YAxisMoving == true)
	//	{
	//		return false;
	//	}
	//}

	return true;
}
int CProductMotorControl::THKSoftlandingPick(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (IsTHKZAxisSafeToMove(NoOfIndex) == false)
	{
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (THKReadMotorServoOnOff(NoOfIndex, 3) == 0)
	{
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
			LeaveCriticalSection(&csKingStarSendCommand);
			return nError;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Pick command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10012);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Pick timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Pick Command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10012);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Pick Command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	//if (NoOfIndex == 0)
	//{
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Start Pick.", (NoOfIndex + 1));
	EnterCriticalSection(&csKingStarSendCommand);
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head In Pick.", (NoOfIndex + 1));
	if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Pick Error.", (NoOfIndex + 1));
	}

	if (THKReadControllerStatus(NoOfIndex, 3, 0) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Pick error 2.", (NoOfIndex + 1));
	}
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 1);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);


	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Done Pick.", (NoOfIndex + 1));
	LeaveCriticalSection(&csKingStarSendCommand);
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head After Pick.", (NoOfIndex + 1));
	//}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
		{
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Pick start %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10012);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Pick timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Pick Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10012);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Pick timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	if (smProductEvent->GGUI_RSEQ_DRY_RUN_MODE.Set == false)
	{
		if (THKReadControllerStatus(NoOfIndex, 3, 1) == 1)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Pick Sequence Stop %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return -1;
		}

		if (THKReadControllerStatus(NoOfIndex, 3, 2) == 1)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Pick Sequence TimeOut %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return -1;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Pick command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10012);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Pick timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		if (THKReadAlarm(NoOfIndex) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Sequence Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (THKReadAlarm(NoOfIndex) != 0)
		{
			THKResetAlarm(NoOfIndex);
			m_cProductShareVariables->SetAlarm(10005);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Error %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_Motor;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10006);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Sequence Done timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return 0;
}
int CProductMotorControl::THKSoftlandingPlace(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (IsTHKZAxisSafeToMove(NoOfIndex) == false)
	{
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (THKReadMotorServoOnOff(NoOfIndex, 3) == 0)
	{
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
			LeaveCriticalSection(&csKingStarSendCommand);
			return nError;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10013);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10013);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor softlanding place %d.", (NoOfIndex + 1));
	EnterCriticalSection(&csKingStarSendCommand);

	if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Place Error.", (NoOfIndex + 1));
	}

	if (THKReadControllerStatus(NoOfIndex, 3, 0) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Place error 2.", (NoOfIndex + 1));
	}
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 2);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);

	LeaveCriticalSection(&csKingStarSendCommand);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
		{
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Place Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10014);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Place timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Place Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
			//return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10014);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Place timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)
		{
			//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Place command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10014);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Place timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		if (THKReadAlarm(NoOfIndex) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Sequence Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (THKReadAlarm(NoOfIndex) != 0)
		{
			THKResetAlarm(NoOfIndex);
			m_cProductShareVariables->SetAlarm(10005);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Error %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_Motor;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10006);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Sequence Done timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return 0;
}
int CProductMotorControl::THKPlace(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (IsTHKZAxisSafeToMove(NoOfIndex) == false)
	{
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (THKReadMotorServoOnOff(NoOfIndex, 3) == 0)
	{
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
			LeaveCriticalSection(&csKingStarSendCommand);
			return nError;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10013);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10013);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor softlanding place %d.", (NoOfIndex + 1));
	EnterCriticalSection(&csKingStarSendCommand);

	if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place Error.", (NoOfIndex + 1));
	}

	if (THKReadControllerStatus(NoOfIndex, 3, 0) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place error 2.", (NoOfIndex + 1));
	}
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 6);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);

	LeaveCriticalSection(&csKingStarSendCommand);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
		{
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10014);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
			//return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10014);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)
		{
			//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10014);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		if (THKReadAlarm(NoOfIndex) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Sequence Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (THKReadAlarm(NoOfIndex) != 0)
		{
			THKResetAlarm(NoOfIndex);
			m_cProductShareVariables->SetAlarm(10005);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Error %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_Motor;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > 10000)
		{
			m_cProductShareVariables->SetAlarm(10006);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Sequence Done timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return 0;
}
int CProductMotorControl::THKAutoCalibrationPlace(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (IsTHKZAxisSafeToMove(NoOfIndex) == false)
	{
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (THKReadMotorServoOnOff(NoOfIndex, 3) == 0)
	{
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
			LeaveCriticalSection(&csKingStarSendCommand);
			return nError;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10013);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10013);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Place command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor softlanding place %d.", (NoOfIndex + 1));
	EnterCriticalSection(&csKingStarSendCommand);

	if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Place Error.", (NoOfIndex + 1));
	}

	if (THKReadControllerStatus(NoOfIndex, 3, 0) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Place error 2.", (NoOfIndex + 1));
	}
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 4);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);

	LeaveCriticalSection(&csKingStarSendCommand);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
		{
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Place Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10014);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Place timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Place Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
			//return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10014);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Place timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)
		{
			//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Place command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10014);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Place timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		if (THKReadAlarm(NoOfIndex) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Sequence Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (THKReadAlarm(NoOfIndex) != 0)
		{
			THKResetAlarm(NoOfIndex);
			m_cProductShareVariables->SetAlarm(10005);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Error %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_Motor;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10006);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Sequence Done timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return 0;
}
int CProductMotorControl::THKRotationSequence(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (THKReadMotorServoOnOff(NoOfIndex, 3) == 0)
	{
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
			LeaveCriticalSection(&csKingStarSendCommand);
			return nError;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Rotation command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(42002);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Rotation command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Rotation command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10015);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Rotation command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor Rotation %d.", (NoOfIndex + 1));
	EnterCriticalSection(&csKingStarSendCommand);

	if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Rotation Error.", (NoOfIndex + 1));
	}

	if (THKReadControllerStatus(NoOfIndex, 3, 0) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Rotation error 2.", (NoOfIndex + 1));
	}
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 4);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);

	LeaveCriticalSection(&csKingStarSendCommand);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
		{
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Rotation Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10015);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Rotation timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Rotation Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
			//return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10015);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Rotation timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)
		{
			//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Rotation command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10014);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Softlanding Place timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		if (THKReadAlarm(NoOfIndex) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Rotation Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (THKReadAlarm(NoOfIndex) != 0)
		{
			THKResetAlarm(NoOfIndex);
			m_cProductShareVariables->SetAlarm(10005);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Error %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_Motor;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10006);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Sequence Done timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return 0;
}
int CProductMotorControl::THKMoveUpWithRotationSequence(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (THKReadMotorServoOnOff(NoOfIndex, 3) == 0)
	{
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
			LeaveCriticalSection(&csKingStarSendCommand);
			return nError;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10016);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10016);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor Move Up %d.", (NoOfIndex + 1));
	EnterCriticalSection(&csKingStarSendCommand);

	if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up Error.", (NoOfIndex + 1));
	}

	if (THKReadControllerStatus(NoOfIndex, 3, 0) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up error 2.", (NoOfIndex + 1));
	}
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 3);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);

	LeaveCriticalSection(&csKingStarSendCommand);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
		{
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10016);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
			//return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10016);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)
		{
			//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10016);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		if (THKReadAlarm(NoOfIndex) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (THKReadAlarm(NoOfIndex) != 0)
		{
			THKResetAlarm(NoOfIndex);
			m_cProductShareVariables->SetAlarm(10005);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up Error %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_Motor;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10016);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Move Up Done timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return 0;
}
int CProductMotorControl::THKMoveUpSequence(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (THKReadMotorServoOnOff(NoOfIndex, 3) == 0)
	{
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
		if (nError != 0)
		{
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.");
			LeaveCriticalSection(&csKingStarSendCommand);
			return nError;
		}
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10016);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10016);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor Move Up %d.", (NoOfIndex + 1));
	EnterCriticalSection(&csKingStarSendCommand);

	if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up Error.", (NoOfIndex + 1));
	}

	if (THKReadControllerStatus(NoOfIndex, 3, 0) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up error 2.", (NoOfIndex + 1));
	}
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 5);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);

	LeaveCriticalSection(&csKingStarSendCommand);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
		{
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10016);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
			//return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10016);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)
		{
			//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10016);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		if (THKReadAlarm(NoOfIndex) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (THKReadAlarm(NoOfIndex) != 0)
		{
			THKResetAlarm(NoOfIndex);
			m_cProductShareVariables->SetAlarm(10005);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Up Error %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_Motor;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10016);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Move Up Done timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return 0;
}
int CProductMotorControl::THKStopMotor(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		LeaveCriticalSection(&csKingStarSendCommand);
		return nError;
	}
	//RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//while (smProductEvent->ExitRTX.Set == false)
	//{
	//	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	//	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	//	//THKReadMotorServoStatus(NoOfIndex, 0);
	//	//if (THKReadControllerStatus(NoOfIndex) == 1)
	//	if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
	//	{
	//		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Stop command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	//		break;
	//	}
	//	else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
	//	{
	//		m_cProductShareVariables->SetAlarm(10017);
	//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Stop command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	//		return m_cProductShareVariables->Error_MotionTimeOut;
	//	}
	//	RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	//}
	//RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//while (smProductEvent->ExitRTX.Set == false)
	//{
	//	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	//	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	//	//THKReadMotorServoStatus(NoOfIndex, 0);
	//	//if (THKReadControllerStatus(NoOfIndex) == 1)
	//	if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
	//	{
	//		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Stop command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	//		//return 0;
	//		break;
	//	}
	//	else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
	//	{
	//		m_cProductShareVariables->SetAlarm(10017);
	//		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Stop command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	//		return m_cProductShareVariables->Error_MotionTimeOut;
	//	}
	//	RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	//}

		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	int nControllerStatusCommandDone = THKReadControllerStatus(NoOfIndex, 0, 0);
	int nControllerStatusSequenceRunning = THKReadControllerStatus(NoOfIndex, 3, 0);
	if (nControllerStatusCommandDone != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head command not done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
	}

	else if (THKReadControllerStatus(NoOfIndex, 3, 0) != 0)//Group 3: Controller Status, Status 1:Sequence running
	{
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Command not Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		//return 0;
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Stop Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
		return 0;
	}

	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 2);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	LeaveCriticalSection(&csKingStarSendCommand);

	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		if (THKReadControllerStatus(NoOfIndex) == 1)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Stop Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10017);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Stop timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return 0;
}
int CProductMotorControl::THKVacuumValveOn(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		LeaveCriticalSection(&csKingStarSendCommand);
		return nError;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum valve on command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10018);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum on timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum on command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10018);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum on command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor vacuum valve on %d.", (NoOfIndex + 1));
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 142);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	LeaveCriticalSection(&csKingStarSendCommand);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
		{
			EnterCriticalSection(&csKingStarSendCommand);
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			LeaveCriticalSection(&csKingStarSendCommand);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum valve on command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10018);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum on timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum on command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10018);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum on command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		if (THKReadVacuumStatus(NoOfIndex) == 1)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum On Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10018);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Vacuum On timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return 0;
}
int CProductMotorControl::THKVacuumValveOff(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum valve off command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10019);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum off command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10019);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum off command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor vacuum valve off %d.", (NoOfIndex + 1));
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 143);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	LeaveCriticalSection(&csKingStarSendCommand);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
		{
			EnterCriticalSection(&csKingStarSendCommand);
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			LeaveCriticalSection(&csKingStarSendCommand);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum valve off command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10019);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum off command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10019);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum off command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		if (THKReadVacuumStatus(NoOfIndex) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Vacuum Off Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10019);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Vacuum Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return 0;
}
int CProductMotorControl::THKReleaseValveOn(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head valve on command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10020);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head valve on timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head valve on command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10020);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head valve on command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor release valve on %d.", (NoOfIndex + 1));
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 144);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	LeaveCriticalSection(&csKingStarSendCommand);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
		{
			EnterCriticalSection(&csKingStarSendCommand);
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			LeaveCriticalSection(&csKingStarSendCommand);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head valve on command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10020);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head valve on timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head valve on command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10020);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head valve on command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		if (THKReadValveStatus(NoOfIndex) == 1)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Valve On Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10020);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Valve On timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return 0;
}
int CProductMotorControl::THKReleaseValveOff(unsigned int NoOfIndex)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head valve off command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10021);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Valve Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Valve off command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10021);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Valve off command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor release valve off %d.", (NoOfIndex + 1));
	EnterCriticalSection(&csKingStarSendCommand);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 145);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	LeaveCriticalSection(&csKingStarSendCommand);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)//
		{
			EnterCriticalSection(&csKingStarSendCommand);
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			LeaveCriticalSection(&csKingStarSendCommand);
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head valve off command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10021);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Valve Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Valve off command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10021);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Valve off command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		if (THKReadValveStatus(NoOfIndex) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Valve Off Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10021);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Valve Off timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return 0;
}
int CProductMotorControl::THKSequenceTrigger(unsigned int NoOfIndex, unsigned int nNoOfSequence)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (IsTHKZAxisSafeToMove(NoOfIndex) == false)
	{
		return m_cProductShareVariables->Error_MotorNotSafeToMove;
	}
	if (THKReadMotorServoOnOff(NoOfIndex, 3) == 0)
	{
		return m_cProductShareVariables->Error_Motor;
	}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Sequence command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10006);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Sequence timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Sequence command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10006);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Sequence command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor trigger sequence %d.", (NoOfIndex + 1));
	EnterCriticalSection(&csKingStarSendCommand);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	nError = m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, nNoOfSequence);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	nError += m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);

	RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
	lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
	LeaveCriticalSection(&csKingStarSendCommand);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		if (THKReadControllerStatus(NoOfIndex) == 1)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Sequence Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			nError += m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10006);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Sequence Done timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;

		if (THKReadAlarm(NoOfIndex) == 0)
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Sequence Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return 0;
		}
		else if (THKReadAlarm(NoOfIndex) != 0)
		{
			THKResetAlarm(NoOfIndex);
			m_cProductShareVariables->SetAlarm(10005);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Move Error %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_Motor;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10006);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head wait Sequence Done timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}

	return 0;
}
int CProductMotorControl::THKSetOriginValue(unsigned int NoOfIndex, unsigned int nAxisNo, signed long Value)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Set origin command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10022);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Set Origin timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Set origin command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10022);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Set origin command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Motor set origin %d.", (NoOfIndex + 1));
	//EnterCriticalSection(&csKingStarSendCommand);
	if (nAxisNo == 0)
	{
		EnterCriticalSection(&csKingStarSendReadCommand);
		nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 20, (WORD)Value);
		nError = m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 136);
		m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
		nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
		nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
		nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
		nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
		nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);

		m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
		LeaveCriticalSection(&csKingStarSendReadCommand);
	}
	else if (nAxisNo == 1)
	{
		EnterCriticalSection(&csKingStarSendReadCommand);
		nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 22, (WORD)Value);
		nError = m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 137);
		m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
		nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
		nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
		nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
		nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
		nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);

		m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
		LeaveCriticalSection(&csKingStarSendReadCommand);
	}
	else
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Set Origin.", (NoOfIndex + 1));
		//LeaveCriticalSection(&csKingStarSendCommand);
		return -1;
	}
	//LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}
int CProductMotorControl::THKResetForceOriginValue(unsigned int NoOfIndex)
{
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	int nError = 0;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Reset Force Origin command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10023);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Reset Force Origin timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Reset Force Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10023);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Reset Force timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Start Reset Force.", (NoOfIndex + 1));

	m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head In Reset Force.", (NoOfIndex + 1));
	if (THKReadControllerStatus(NoOfIndex, 0, 0) == 1)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Reset Force Error.", (NoOfIndex + 1));
	}

	if (THKReadControllerStatus(NoOfIndex, 3, 0) == 1)//Group 3: Controller Status, Status 1:Sequence running
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Reset Force error 2.", (NoOfIndex + 1));
	}
	EnterCriticalSection(&csKingStarSendCommand);
	m_cProductShareVariables->m_lnPeriod_1ms.QuadPart = 10000;
	m_cMotion->m_kingstarController->KSWriteOutputByte(NoOfIndex, 2, 140);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	//RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);

	RtGetClockTime(CLOCK_FASTEST, &lnClockStart);
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	//EnterCriticalSection(&csKingStarSendReadCommand);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	//LeaveCriticalSection(&csKingStarSendReadCommand);
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}
int CProductMotorControl::THKSetTargetValue(unsigned int NoOfIndex, unsigned int nNoOfTargetValue, signed long Value)
{
	//1 = Down Position
	//2 = Up Position
	//3 = Force Value
	//4 = Pressure Value
	int nError = 0;
	WORD wValue;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}

	EnterCriticalSection(&csKingStarSendCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, (2 + (nNoOfTargetValue * 2)), Value);
	nError = m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, (2 + (nNoOfTargetValue * 2)), &wValue);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}

int CProductMotorControl::THKSetTargetValue1(unsigned int NoOfIndex, signed long Value)
{
	//1 = Down Position
	//2 = Up Position
	//3 = Force Value
	//4 = Pressure Value
	int nError = 0;
	WORD wValue;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 4, Value);
	//nError = m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 4, &wValue);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}

int CProductMotorControl::THKSetTargetValue2(unsigned int NoOfIndex, signed long Value)
{
	//1 = Down Position
	//2 = Up Position
	//3 = Force Value
	//4 = Pressure Value
	int nError = 0;
	WORD wValue;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 6, Value);
	//nError = m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 6, &wValue);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}

int CProductMotorControl::THKSetTargetValue3(unsigned int NoOfIndex, signed long Value)
{
	int nError = 0;
	WORD wValue;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 8, Value);
	//nError = m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 8, &wValue);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}

int CProductMotorControl::THKSetTargetValue4(unsigned int NoOfIndex, double Value)
{
	//1 = Down Position
	//2 = Up Position
	//3 = Force Value
	//4 = Pressure Value
	int nError = 0;
	WORD wValue;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	//nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 10, Value);
	nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 10, WORD(Value / 0.01));
	if (nError == 0)
	{
		m_cLogger->WriteLog("Done setting up Pick Up Force Target to %lf.",(double)Value);
	}
	else
	{
		m_cLogger->WriteLog("Error Setting Up Pick Up Force Target.");
	}
	//nError = m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 10, &wValue);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}

int CProductMotorControl::THKSetTargetValue5(unsigned int NoOfIndex, double Value)
{
	//1 = Down Position
	//2 = Up Position
	//3 = Force Value
	//4 = Pressure Value
	int nError = 0;
	WORD wValue;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 12, WORD(Value / 0.01));
	//nError = m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 12, &wValue);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}

int CProductMotorControl::THKSetTargetValue6(unsigned int NoOfIndex, signed long Value)
{
	//1 = Down Position
	//2 = Up Position
	//3 = Force Value
	//4 = Pressure Value
	int nError = 0;
	WORD wValue;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 14, Value);
	//nError = m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 14, &wValue);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}

int CProductMotorControl::THKSetTargetValue7(unsigned int NoOfIndex, signed long Value)
{
	//1 = Down Position
	//2 = Up Position
	//3 = Force Value
	//4 = Pressure Value
	int nError = 0;
	WORD wValue;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}

	if ((Value / 10) < 18000 && (Value / 10) > -18000)
	{
		//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 26, (WORD)(Value / 10));
	}
	else if ((Value / 10) >= 18000)
	{
		Value = Value - 360000;
		//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 26, (WORD)(Value / 10));
	}
	else if ((Value / 10) <= -18000)
	{
		Value = Value + 360000;
		//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 26, (WORD)(Value / 10));
	}

	/*if (Value > 180000 || Value < -179999)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Set Value.", (NoOfIndex + 1));
		return -1;
	}*/

	EnterCriticalSection(&csKingStarSendCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 16, (Value/10));
	//nError = m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 16, &wValue);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}

int CProductMotorControl::THKSetTargetValue8(unsigned int NoOfIndex, signed long Value)
{
	//1 = Down Position
	//2 = Up Position
	//3 = Force Value
	//4 = Pressure Value
	int nError = 0;
	WORD wValue;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 18, Value);
	//nError = m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 18, &wValue);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}

int CProductMotorControl::THKSetTargetValue9(unsigned int NoOfIndex, signed long Value)
{
	//1 = Down Position
	//2 = Up Position
	//3 = Force Value
	//4 = Pressure Value
	int nError = 0;
	WORD wValue;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 32, Value);
	//nError = m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 32, &wValue);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}

int CProductMotorControl::THKSetTargetValue10(unsigned int NoOfIndex, signed long Value)
{
	//1 = Down Position
	//2 = Up Position
	//3 = Force Value
	//4 = Pressure Value
	int nError = 0;
	WORD wValue;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 34, Value);
	//nError = m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 34, &wValue);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}

int CProductMotorControl::THKSetTargetValue11(unsigned int NoOfIndex, signed long Value)
{
	//1 = Down Position
	//2 = Up Position
	//3 = Force Value
	//4 = Pressure Value
	int nError = 0;
	WORD wValue;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 36, Value);
	//nError = m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 36, &wValue);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}

int CProductMotorControl::THKSetTargetValue12(unsigned int NoOfIndex, signed long Value)
{
	//1 = Down Position
	//2 = Up Position
	//3 = Force Value
	//4 = Pressure Value
	int nError = 0;
	WORD wValue;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}

	EnterCriticalSection(&csKingStarSendCommand);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 0);
	nError = m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 38, (Value));
	//nError = m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 38, &wValue);
	//m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 0, 1);
	//nError = m_cProductMotorControl->THKReadStartSequenceResult(NoOfIndex, 0);
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}

int CProductMotorControl::THKUserOriginSetting(unsigned int NoOfIndex, unsigned int nAxisNo)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	if (nAxisNo == 0)//Z um
	{
		m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 20, (WORD)0);
	}
	else if (nAxisNo == 1)//theta 0.01 degree
	{
		m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 22, (WORD)(0));
	}
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}
int CProductMotorControl::THKInchingValue(unsigned int NoOfIndex, unsigned int nAxisNo, signed long Value)
{
	int nError = 0;
	LARGE_INTEGER lnClockStart, lnClockEnd, lnClockSpan, lnClockStart2;
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 0, 0) == 0)//
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing command done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	RtGetClockTime(CLOCK_FASTEST, &lnClockStart2);
	while (smProductEvent->ExitRTX.Set == false)
	{
		RtGetClockTime(CLOCK_FASTEST, &lnClockEnd);
		lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
		//THKReadMotorServoStatus(NoOfIndex, 0);
		//if (THKReadControllerStatus(NoOfIndex) == 1)
		if (THKReadControllerStatus(NoOfIndex, 3, 0) == 0)//Group 3: Controller Status, Status 1:Sequence running
		{
			lnClockSpan.QuadPart = lnClockEnd.QuadPart - lnClockStart2.QuadPart;
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Command Done %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			//return 0;
			break;
		}
		else if (lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount > m_cProductShareVariables->MOTION_TIMEOUT)
		{
			m_cProductShareVariables->SetAlarm(10004);
			m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Homing Command timeout %ums.", (NoOfIndex + 1), lnClockSpan.QuadPart / m_cProductShareVariables->m_TimeCount);
			return m_cProductShareVariables->Error_MotionTimeOut;
		}
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	if (nAxisNo == 0)//Z um
	{
		if (Value <= 30000 && Value >= -30000)
		{
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 24, (WORD)Value);
		}
		else
		{
			LeaveCriticalSection(&csKingStarSendCommand);
			return -1;
		}
	}
	else if (nAxisNo == 1)//theta 0.01 degree
	{
		if ((Value / 10) < 18000 && (Value / 10) > -18000)
		{
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 26, (WORD)(Value / 10));
		}
		else if ((Value / 10) > 18000)
		{
			Value = Value - 360000;
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 26, (WORD)(Value / 10));
		}
		else if ((Value / 10) < -18000)
		{
			Value = Value + 360000;
			m_cMotion->m_kingstarController->KSWriteOutputWord(NoOfIndex, 26, (WORD)(Value / 10));
		}
		else 
		{
			LeaveCriticalSection(&csKingStarSendCommand);
			return -1;
		}
	}
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}
int CProductMotorControl::THKReadEncoderValue(unsigned int NoOfIndex, unsigned int nAxisNo, signed long* Value)
{
	WORD wValue;
	int nError = 0;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	if (nAxisNo == 0)//Z um
	{
		m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 8, &wValue);
		*Value = (signed long)wValue;
		if (*Value <= 30000 && *Value >= 0)
		{
			*Value = (signed long)wValue;
		}
		else
		{
			*Value = (signed long)(-1 * (0xFFFF - (wValue)+1));
		}
	}
	else if (nAxisNo == 1)//theta 0.01 degree
	{
		m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 22, &wValue);
		*Value = (signed long)wValue;
		if (*Value <= 18000 && *Value >= -18000)
		{
			*Value = *Value * 10;
		}
		else
		{
			*Value = (signed long)(-10 * (0xFFFF - (wValue)+1));
		}
	}
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}
int CProductMotorControl::THKReadForceValue(unsigned int NoOfIndex, double* Value)
{
	WORD wValue;
	int nError = 0;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 34, &wValue);
	*Value = (double)wValue;//0.01N
	if (*Value >= 0 && *Value <= 10000)
	{
		*Value = (signed long)wValue*0.01;
	}
	else
	{
		*Value = (double)(-0.01 * (0xFFFF - (wValue)+1));
	}
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}
int CProductMotorControl::THKReadPressureValue(unsigned int NoOfIndex, double* Value)
{
	WORD wValue;
	int nError = 0;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 36, &wValue);
	*Value = (double)wValue;//kPA
	if (*Value >= 0 && *Value <= 300)
	{
		*Value = (signed long)wValue;
	}
	else
	{
		*Value = (signed long)(-1 * (0xFFFF - (wValue)+1));
	}
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}
int CProductMotorControl::THKReadFlowRateValue(unsigned int NoOfIndex, double* Value)
{
	WORD wValue;
	int nError = 0;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 38, &wValue);
	//*Value = 0.01 *(double)wValue;//0.01L/min
	//*Value = (signed long)(-0.01 * (0xFFFF - (wValue)));
	*Value = (double)wValue;//0.01L/min
	if (*Value >= 0 && *Value <= 3000)
	{
		*Value = (signed long)wValue*0.01;
	}
	else
	{
		*Value = (double)(-0.01 * (0xFFFF - (wValue)+1));
	}
	LeaveCriticalSection(&csKingStarSendCommand);
	return 0;
}
int CProductMotorControl::THKReadMotorServoOnOff(unsigned int NoOfIndex, unsigned int AxisNo)
{
	BYTE byte;
	int nError = 0;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	nError = m_cMotion->m_kingstarController->KSReadInputByte(NoOfIndex, 4, &byte);
	LeaveCriticalSection(&csKingStarSendCommand);
	if (nError == 0)
	{
		if (AxisNo == 0)//Z
		{
			if ((byte & 0x40) == 0x40)
				return 1;
			else
				return 0;
		}
		else if (AxisNo == 1)//Theta
		{
			if ((byte & 0x80) == 0x80)
				return 1;
			else
				return 0;
		}
		else if (AxisNo == 3)//Both
		{
			if ((byte & 0x01) == 0x01)
				return 1;
			else
				return 0;
		}
	}
	else
	{
		return -1;
	}
	return -1;
}
int CProductMotorControl::THKReadMotorServoStatus(unsigned int NoOfIndex, unsigned int nAxisNo)
{
	BYTE byte;
	int nError = 0;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSReadInputByte(NoOfIndex, 4, &byte);
	LeaveCriticalSection(&csKingStarSendCommand);
	if (nAxisNo == 0)
	{
		if ((byte & 0x40) == 0x40)
			smProductGeneral->nMotorOnStatus = 1;
		else
			smProductGeneral->nMotorOnStatus = 0;
		if ((byte & 0x04) == 0x4)
			smProductGeneral->nMotorMovingStatus = 1;
		else
			smProductGeneral->nMotorMovingStatus = 0;

		/*if (IsPickupHead1ZAxisMotorReady() == true)
			smProductGeneral->nMotorAlarmOn = 0;
		else
			smProductGeneral->nMotorAlarmOn = 1;*/

	}
	else if (nAxisNo == 1)
	{
		if ((byte & 0x80) == 0x80)
			smProductGeneral->nMotorOnStatus = 1;
		else
			smProductGeneral->nMotorOnStatus = 0;
		if ((byte & 0x08) == 0x8)
			smProductGeneral->nMotorMovingStatus = 1;
		else
			smProductGeneral->nMotorMovingStatus = 0;

		/*if (IsPickupHead1RotationAxisMotorReady() == true)
			smProductGeneral->nMotorAlarmOn = 0;
		else
			smProductGeneral->nMotorAlarmOn = 1;*/
	}
	return 0;
}
int CProductMotorControl::THKReadMotorHomeStatus(unsigned int NoOfIndex)
{
	int nError = 0;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	BYTE byte;
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSReadInputByte(NoOfIndex, 4, &byte);
	LeaveCriticalSection(&csKingStarSendCommand);
	if ((byte & 0x02) == 0x02)
		return 1;
	else
		return 0;
}
int CProductMotorControl::THKReadVacuumStatus(unsigned int NoOfIndex)
{
	int nError = 0;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	BYTE byte;
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSReadInputByte(NoOfIndex, 5, &byte);
	LeaveCriticalSection(&csKingStarSendCommand);
	if ((byte & 0x01) == 0x01)
		return 1;
	else
		return 0;
}
int CProductMotorControl::THKReadValveStatus(unsigned int NoOfIndex)
{
	BYTE byte;
	int nError = 0;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSReadInputByte(NoOfIndex, 5, &byte);
	LeaveCriticalSection(&csKingStarSendCommand);
	if ((byte & 0x02) == 0x02)
		return 1;
	else
		return 0;
}
int CProductMotorControl::THKReadAlarm(unsigned int NoOfIndex)
{
	WORD byte;
	int nError = 0;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", (NoOfIndex + 1));
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, 6, &byte);
	LeaveCriticalSection(&csKingStarSendCommand);
	if ((byte & 0x01) == 0x01)
		return -1;
	if ((byte & 0x02) == 0x02)
		return -2;
	if ((byte & 0x04) == 0x04)
		return -3;
	if ((byte & 0x08) == 0x08)
		return -4;
	if ((byte & 0x10) == 0x10)
		return -5;
	if ((byte & 0x20) == 0x20)
		return -6;
	if ((byte & 0x40) == 0x40)
		return -7;
	if ((byte & 0x80) == 0x80)
		return -8;
	if ((byte & 0x100) == 0x100)
		return -9;

	return 0;
}

int CProductMotorControl::THKReadStartSequenceResult(unsigned int NoOfIndex, int ByteOffset)
{
	m_cProductShareVariables->m_lnPeriod_1ms.QuadPart = 10000;
	RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	return 0;
	//WORD word;
	//while (smProductEvent->ExitRTX.Set == false)
	//{
	//	m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, ByteOffset, &word);
	//	if ((word & 0x01) == 0x01)
	//	{
	//		break;
	//	}
	//	m_cProductShareVariables->m_lnPeriod_1ms.QuadPart = 10000;
	//	RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);

	//}
	//return 0;
}

int CProductMotorControl::THKReadStopRunningResult(unsigned int NoOfIndex, int ByteOffset)
{
	WORD word;
	while (smProductEvent->ExitRTX.Set == false)
	{
		m_cMotion->m_kingstarController->KSReadInputWord(NoOfIndex, ByteOffset, &word);
		if (word & 0x02 == 0x02)
		{
			break;
		}
		m_cProductShareVariables->m_lnPeriod_1ms.QuadPart = 10000;
		RtSleepFt(&m_cProductShareVariables->m_lnPeriod_1ms);
	}
	return 0;
}

int CProductMotorControl::THKReadControllerStatus(unsigned int NoOfIndex)
{
	BYTE byte;
	int nError = 0;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", NoOfIndex + 1);
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSReadInputByte(NoOfIndex, 3, &byte);
	LeaveCriticalSection(&csKingStarSendCommand);
	if ((byte & 0x01) == 0x01)
		return 1;
	else
		return 0;
}
//Group 0: Status 0:Sequence start; Group 3: Controller Status, Status 0:Sequence running
int CProductMotorControl::THKReadControllerStatus(unsigned int NoOfIndex, int group, int nStatus)
{
	BYTE byte;
	int nError = 0;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", NoOfIndex + 1);
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSReadInputByte(NoOfIndex, group, &byte);
	LeaveCriticalSection(&csKingStarSendCommand);
	//m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place Pickup Head %d status: %d.", group, byte);
	if ((byte & (1 << nStatus)) == (1 << nStatus))
		return 1;
	else
		return 0;
}
int CProductMotorControl::THKReadRunningStatus(unsigned int NoOfIndex, unsigned int nAxisNo)
{
	BYTE byte;
	int nError = 0;
	if (smProductEvent->InitializeMotionController7Done.Set == false)
	{
		nError = m_cProductMotorControl->THKConnect(NoOfIndex);
	}
	if (nError != 0)
	{
		m_cProductShareVariables->UpdateMessageToGUIAndLog("Pick And Place %d Pickup Head Fail To Connect.", NoOfIndex + 1);
		return nError;
	}
	EnterCriticalSection(&csKingStarSendCommand);
	m_cMotion->m_kingstarController->KSReadInputByte(NoOfIndex, 4, &byte);
	LeaveCriticalSection(&csKingStarSendCommand);
	if (nAxisNo == 0)
	{
		if ((byte & 0x04) == 0x04)
			return 1;
		else
			return 0;
	}
	else if (nAxisNo == 1)
	{
		if ((byte & 0x10) == 0x10)
			return 1;
		else
			return 0;
	}
}
#pragma endregion THK

#pragma region Agito
SOCKET s;
SOCKET s2;
WSADATA wsadata;
SOCKADDR_IN target;
//int iResult;
char sendbuf[256];
int length[1];
int recvbuflen = DEFAULT_BUFLEN;
char recvbuf[DEFAULT_BUFLEN];

int CProductAgito::setParam(unsigned int uController, unsigned int uAxis, CANCODE uCANCode, unsigned int uIndex, long iValue, char*Result, int*length)
{
	//static char byteCommandArray[9];
	unsigned int iCANcode = unsigned int(uCANCode);
	//int length = 7;

	char valueArray[sizeof(int)];
	std::memcpy(valueArray, &iValue, sizeof(int));
	//Array.Reverse(valueArray);
	int n = sizeof(valueArray) / sizeof(valueArray[0]);
	ArrayReverse(valueArray, n);

	Result[0] = 0x00; // first byte for length setting

	Result[0] = 0x00; // first byte for length setting
	if (iCANcode > 0xFF)
	{
		//byteCommandArray[2] = Convert.ToByte(iCANcode & 0xFF);
		//byteCommandArray[1] = Convert.ToByte((uAxis << 2) | ((iCANcode >> 8) & 0x03));
		Result[2] = char(iCANcode & 0xFF);
		Result[1] = char((uAxis << 2) | ((iCANcode >> 8) & 0x03));
	}
	else
	{
		//byteCommandArray[1] = Convert.ToByte(uAxis << 2);
		//byteCommandArray[2] = Convert.ToByte(uCANCode);
		Result[1] = char(uAxis << 2);
		Result[2] = char(uCANCode);
	}
	if (uIndex > 0)
	{
		//byte[] bytes = BitConverter.GetBytes(uIndex);
		//BYTE* bytes = static_cast<BYTE*>(static_cast<void*>(&uIndex));
		char bytes[sizeof(int)];
		std::memcpy(bytes, &uIndex, sizeof(int));


		Result[3] = bytes[1];
		Result[4] = bytes[0]; //bytes[0] should be LSB
		for (int d = 5, s = 0; s < 4; d++, s++)
		{
			Result[d] = valueArray[s];
		}
		length[0] = 9;
		//byteCommandArray[0] = 9; // length of message in first byte
	}
	else
	{
		for (int d = 3, s = 0; s < 4; d++, s++)
		{
			Result[d] = valueArray[s];
		}
		length[0] = 7;
		//byteCommandArray[0] = 7; // length of message in first byte
	}
	return 0;
}
int CProductAgito::setParam1(unsigned int uController, unsigned int uAxis, CANCODE uCANCode, unsigned int uIndex, long iValue, char*Result, int*length)
{
	//static char byteCommandArray[9];
	unsigned int iCANcode = unsigned int(uCANCode);
	//int length = 7;

	char valueArray[sizeof(int)];
	std::memcpy(valueArray, &iValue, sizeof(int));
	//Array.Reverse(valueArray);
	int n = sizeof(valueArray) / sizeof(valueArray[0]);
	ArrayReverse(valueArray, n);

	Result[0] = 0x00; // first byte for length setting

	Result[0] = 0x00; // first byte for length setting
	if (iCANcode > 0xFF)
	{
		//byteCommandArray[2] = Convert.ToByte(iCANcode & 0xFF);
		//byteCommandArray[1] = Convert.ToByte((uAxis << 2) | ((iCANcode >> 8) & 0x03));
		Result[2] = char(iCANcode & 0xFF);
		Result[1] = char((uAxis << 2) | ((iCANcode >> 8) & 0x03));
	}
	else
	{
		//byteCommandArray[1] = Convert.ToByte(uAxis << 2);
		//byteCommandArray[2] = Convert.ToByte(uCANCode);
		Result[1] = char(uAxis << 2);
		Result[2] = char(uCANCode);
	}
	if (uIndex > 0)
	{
		//byte[] bytes = BitConverter.GetBytes(uIndex);
		//BYTE* bytes = static_cast<BYTE*>(static_cast<void*>(&uIndex));
		char bytes[sizeof(int)];
		std::memcpy(bytes, &uIndex, sizeof(int));


		Result[3] = bytes[1];
		Result[4] = bytes[0]; //bytes[0] should be LSB
		for (int d = 5, s = 0; s < 4; d++, s++)
		{
			Result[d] = valueArray[s];
		}
		length[0] = 9;
		//byteCommandArray[0] = 9; // length of message in first byte
	}
	else
	{
		for (int d = 3, s = 0; s < 4; d++, s++)
		{
			Result[d] = valueArray[s];
		}
		length[0] = 7;
		//byteCommandArray[0] = 7; // length of message in first byte
	}
	return 0;
}

int CProductAgito::getParam(unsigned int uController, unsigned int uAxis, CANCODE uCANCode, unsigned int uIndex, char*Result, int*length)
{
	EnterCriticalSection(&csAgitoGetParam);
	unsigned int iCANcode = unsigned int(uCANCode);
	length[0] = 3;

	Result[0] = 0x00; // first byte for length setting
	if (iCANcode > 0xFF)
	{
		//byteCommandArray[2] = Convert.ToByte(iCANcode & 0xFF);
		//byteCommandArray[1] = Convert.ToByte((uAxis << 2) | ((iCANcode >> 8) & 0x03));
		Result[2] = char(iCANcode & 0xFF);
		Result[1] = char((uAxis << 2) | ((iCANcode >> 8) & 0x03));
	}
	else
	{
		//byteCommandArray[1] = Convert.ToByte(uAxis << 2);
		//byteCommandArray[2] = Convert.ToByte(uCANCode);
		Result[1] = char(uAxis << 2);
		Result[2] = char(uCANCode);
	}
	if (uIndex > 0)
	{
		//byte[] bytes = BitConverter.GetBytes(uIndex);
		//BYTE* bytes = static_cast<BYTE*>(static_cast<void*>(&uIndex));
		char bytes[sizeof(int)];

		Result[3] = bytes[1];
		Result[4] = bytes[0]; //bytes[0] should be LSB
		length[0] = 5;
		//byteCommandArray[0] = 9; // length of message in first byte
	}
	LeaveCriticalSection(&csAgitoGetParam);
	return 0;
}
int CProductAgito::getParam1(unsigned int uController, unsigned int uAxis, CANCODE uCANCode, unsigned int uIndex, char*Result, int*length)
{
	EnterCriticalSection(&csAgitoGetParam);
	unsigned int iCANcode = unsigned int(uCANCode);
	length[0] = 3;

	Result[0] = 0x00; // first byte for length setting
	if (iCANcode > 0xFF)
	{
		//byteCommandArray[2] = Convert.ToByte(iCANcode & 0xFF);
		//byteCommandArray[1] = Convert.ToByte((uAxis << 2) | ((iCANcode >> 8) & 0x03));
		Result[2] = char(iCANcode & 0xFF);
		Result[1] = char((uAxis << 2) | ((iCANcode >> 8) & 0x03));
	}
	else
	{
		//byteCommandArray[1] = Convert.ToByte(uAxis << 2);
		//byteCommandArray[2] = Convert.ToByte(uCANCode);
		Result[1] = char(uAxis << 2);
		Result[2] = char(uCANCode);
	}
	if (uIndex > 0)
	{
		//byte[] bytes = BitConverter.GetBytes(uIndex);
		//BYTE* bytes = static_cast<BYTE*>(static_cast<void*>(&uIndex));
		char bytes[sizeof(int)];

		Result[3] = bytes[1];
		Result[4] = bytes[0]; //bytes[0] should be LSB
		length[0] = 5;
		//byteCommandArray[0] = 9; // length of message in first byte
	}
	LeaveCriticalSection(&csAgitoGetParam);
	return 0;
}
void CProductAgito::ArrayReverse(char arr[], int n)
{
	for (int low = 0, high = n - 1; low < high; low++, high--)
	{
		std::swap(arr[low], arr[high]);
	}
}

int CProductMotorControl::AgitoStartMotor(unsigned int uAxis)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->getParam(0, uAxis, m_Agito->Begin, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	/*m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	return iResult;
}

int CProductMotorControl::AgitoStartMotor(unsigned int uController, unsigned int uAxis)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->getParam(uController, uAxis, m_Agito->Begin, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	/*m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	return iResult;
}
int CProductMotorControl::AgitoStartMotor1(unsigned int uController, unsigned int uAxis)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->getParam1(uController, uAxis, m_Agito->Begin, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	/*m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	return iResult;
}

int CProductMotorControl::AgitoServoOn(unsigned int uAxis, int iValue)
{
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	char Result[50];
	int iResult;

	iResult = m_Agito->setParam(0, uAxis, m_Agito->MotorOn, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	/*m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	return iResult;
}

int CProductMotorControl::AgitoServoOn(unsigned int uController, unsigned int uAxis, int iValue)
{
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	char Result[50];
	int iResult;

	iResult = m_Agito->setParam(uController, uAxis, m_Agito->MotorOn, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	/*m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	return iResult;
}

int CProductMotorControl::AgitoStopMotor(unsigned int uAxis)
{
	char Result[50];
	int iResult;
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	iResult = m_Agito->getParam(0, uAxis, m_Agito->Stop, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	/*m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	return iResult;
}
int CProductMotorControl::AgitoStopMotor(unsigned int uController, unsigned int uAxis)
{
	char Result[50];
	int iResult;
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	iResult = m_Agito->getParam(uController, uAxis, m_Agito->Stop, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	/*m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	return iResult;
}
int CProductMotorControl::AgitoGenData(unsigned int uAxis, unsigned int uIndex, signed long iValue)
{
	char Result[50];
	char ReturnData[10];
	int iResult;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->GenData, uIndex, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], ReturnData);
	/*m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	return iResult;
}
int CProductMotorControl::AgitoGenData(unsigned int uController, unsigned int uAxis, unsigned int uIndex, signed long iValue)
{
	char Result[50];
	char ReturnData[10];
	int iResult;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->GenData, uIndex, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], ReturnData);
	/*m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	return iResult;
}

int CProductMotorControl::AgitoAbortMotor(unsigned int uAxis)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->getParam(0, uAxis, m_Agito->Abort, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	/*m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	return iResult;
}
int CProductMotorControl::AgitoAbortMotor(unsigned int uController, unsigned int uAxis)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->getParam(uController, uAxis, m_Agito->Abort, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	/*m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	return iResult;
}

int CProductMotorControl::AgitoGantry(unsigned int uAxis, int iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->GantryOn, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	/*m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	return iResult;
}
int CProductMotorControl::AgitoGantry(unsigned int uController, unsigned int uAxis, int iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->GantryOn, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	/*m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	return iResult;
}

int CProductMotorControl::AgitoHomeMotor(unsigned int uAxis)
{
	char Result[50];
	memset(Result, 0, sizeof(Result));
	memset(length, 0, sizeof(length));
	int iResult;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->HomingOn, 0, 1, Result, length);
	//char Result_HardCode[] = { 0x02, 0x06, 0x01, 0x54, 0x00, 0x00, 0x00, 0x01 ,0x06, 0x05, 0x54, 0x00, 0x00, 0x00, 0x01 };
	//if (uAxis == 0)
	//{
	//	//m_cProductMotorControl->AgitoSend(Result_HardCode, sizeof(Result_HardCode));
	//	m_cProductMotorControl->AgitoSendAndReceive(Result_HardCode, sizeof(Result_HardCode), Result);
	//}
	//else
	{
		m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
		//m_cProductMotorControl->AgitoSend(Result, length[0]);
	}
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoHomeMotor(unsigned int uController, unsigned int uAxis)
{
	char Result[50];
	memset(Result, 0, sizeof(Result));
	memset(length, 0, sizeof(length));
	int iResult;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->HomingOn, 0, 1, Result, length);
	char Result_HardCode[] = { 0x02, 0x06, 0x01, 0x54, 0x00, 0x00, 0x00, 0x01 ,0x06, 0x05, 0x54, 0x00, 0x00, 0x00, 0x01 };
	if (uAxis == 0)
	{
		//m_cProductMotorControl->AgitoSend(Result_HardCode, sizeof(Result_HardCode));
		m_cProductMotorControl->AgitoSendAndReceive(uController, Result_HardCode, sizeof(Result_HardCode), Result);
	}
	else
	{
		m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
		//m_cProductMotorControl->AgitoSend(Result, length[0]);
	}
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoMotorAbsolute(unsigned int uAxis, long iValue)
{
	char Result[50];
	int iResult = 0;
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	m_Agito->setParam(0, uAxis, m_Agito->AbsTrgt, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	/*iResult = m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	return iResult;
}
int CProductMotorControl::AgitoMotorAbsolute(unsigned int uController, unsigned int uAxis, long iValue)
{
	char Result[50];
	int iResult = 0;
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	m_Agito->setParam(uController, uAxis, m_Agito->AbsTrgt, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	/*iResult = m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	return iResult;
}
int CProductMotorControl::AgitoMotorAbsolute1(unsigned int uController, unsigned int uAxis, long iValue)
{
	char Result[50];
	int iResult = 0;
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	m_Agito->setParam1(uController, uAxis, m_Agito->AbsTrgt, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive1(uController, Result, length[0], Result);
	/*iResult = m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	return iResult;
}
int CProductMotorControl::AgitoMotorAbsolute(unsigned int uAxis, double diValue)
{
	char Result[50];
	int iResult = 0;
	if (uAxis == 3)
	{
		diValue = diValue / 1.5;
	}
	else
	{
		diValue = diValue / 0.078125;
	}
	m_Agito->setParam(0, uAxis, m_Agito->AbsTrgt, 0, long(diValue), Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	/*iResult = m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	return iResult;
}
int CProductMotorControl::AgitoMotorAbsolute(unsigned int uController, unsigned int uAxis, double diValue)
{
	char Result[50];
	int iResult = 0;
	if (uAxis == 3)
	{
		diValue = diValue / 1.5;
	}
	else
	{
		diValue = diValue / 0.078125;
	}
	m_Agito->setParam(uController, uAxis, m_Agito->AbsTrgt, 0, long(diValue), Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	/*iResult = m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	return iResult;
}

int CProductMotorControl::AgitoMotorRelative(unsigned int uAxis, long iValue)
{
	char Result[50];
	int iResult;
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	iResult = m_Agito->setParam(0, uAxis, m_Agito->RelTrgt, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoMotorRelative(unsigned int uController, unsigned int uAxis, long iValue)
{
	char Result[50];
	int iResult;
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->RelTrgt, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoMotorRelative1(unsigned int uController, unsigned int uAxis, long iValue)
{
	char Result[50];
	int iResult;
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	iResult = m_Agito->setParam1(uController, uAxis, m_Agito->RelTrgt, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive1(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoMotorRelative(unsigned int uAxis, double diValue)
{
	char Result[50];
	int iResult;
	if (uAxis == 3)
	{
		diValue = diValue / 1.5;
	}
	else
	{
		diValue = diValue / 0.078125;
	}
	iResult = m_Agito->setParam(0, uAxis, m_Agito->RelTrgt, 0, (long)diValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoMotorRelative(unsigned int uController, unsigned int uAxis, double diValue)
{
	char Result[50];
	int iResult;
	if (uAxis == 3)
	{
		diValue = diValue / 1.5;
	}
	else
	{
		diValue = diValue / 0.078125;
	}
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->RelTrgt, 0, (long)diValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoMotorAcceleration(unsigned int uAxis, long iValue)
{
	char Result[50];
	int iResult;
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	iResult = m_Agito->setParam(0, uAxis, m_Agito->Accel, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoMotorAcceleration(unsigned int uController, unsigned int uAxis, long iValue)
{
	char Result[50];
	int iResult;
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->Accel, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoMotorDeceleration(unsigned int uAxis, long iValue)
{
	char Result[50];
	int iResult;
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	iResult = m_Agito->setParam(0, uAxis, m_Agito->Decel, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoMotorDeceleration(unsigned int uController, unsigned int uAxis, long iValue)
{
	char Result[50];
	int iResult;
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->Decel, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoMotorSpeed(unsigned int uAxis, long iValue)
{
	char Result[50];
	int iResult;
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	iResult = m_Agito->setParam(0, uAxis, m_Agito->Speed, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoMotorSpeed(unsigned int uController, unsigned int uAxis, long iValue)
{
	char Result[50];
	int iResult;
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->Speed, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoMotorSpeed(unsigned int uAxis, long iValue, long iIntargetTolValue, long Acceleration, long Deceleration)
{
	char Result[9];
	char Result1[50];
	char ResultSend[50];
	int iResult;
	int intlength[1];
	int inttotallength = 0;
	ArraySpeednInTargetTol.clear();
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	Acceleration = Acceleration / 0.078125;
	Deceleration = Deceleration / 0.078125;

	ArraySpeednInTargetTol.push_back(0x02);
	inttotallength++;
	ArraySpeednInTargetTol.push_back(0x06);
	iResult = m_Agito->setParam(0, uAxis, m_Agito->Speed, 0, iValue, Result, intlength);
	ArraySpeednInTargetTol.push_back(Result[1]);
	ArraySpeednInTargetTol.push_back(Result[2]);
	ArraySpeednInTargetTol.push_back(Result[3]);
	ArraySpeednInTargetTol.push_back(Result[4]);
	ArraySpeednInTargetTol.push_back(Result[5]);
	ArraySpeednInTargetTol.push_back(Result[6]);
	inttotallength += intlength[0];
	ArraySpeednInTargetTol.push_back(0x06);
	iResult = m_Agito->setParam(0, uAxis, m_Agito->InTargetTol, 0, iIntargetTolValue, Result, intlength);
	ArraySpeednInTargetTol.push_back(Result[1]);
	ArraySpeednInTargetTol.push_back(Result[2]);
	ArraySpeednInTargetTol.push_back(Result[3]);
	ArraySpeednInTargetTol.push_back(Result[4]);
	ArraySpeednInTargetTol.push_back(Result[5]);
	ArraySpeednInTargetTol.push_back(Result[6]);
	inttotallength += intlength[0];
	ArraySpeednInTargetTol.push_back(0x06);
	iResult = m_Agito->setParam(0, uAxis, m_Agito->Accel, 0, Acceleration, Result, intlength);
	ArraySpeednInTargetTol.push_back(Result[1]);
	ArraySpeednInTargetTol.push_back(Result[2]);
	ArraySpeednInTargetTol.push_back(Result[3]);
	ArraySpeednInTargetTol.push_back(Result[4]);
	ArraySpeednInTargetTol.push_back(Result[5]);
	ArraySpeednInTargetTol.push_back(Result[6]);
	inttotallength += intlength[0];
	ArraySpeednInTargetTol.push_back(0x06);
	iResult = m_Agito->setParam(0, uAxis, m_Agito->Decel, 0, Deceleration, Result, intlength);
	ArraySpeednInTargetTol.push_back(Result[1]);
	ArraySpeednInTargetTol.push_back(Result[2]);
	ArraySpeednInTargetTol.push_back(Result[3]);
	ArraySpeednInTargetTol.push_back(Result[4]);
	ArraySpeednInTargetTol.push_back(Result[5]);
	ArraySpeednInTargetTol.push_back(Result[6]);
	inttotallength += intlength[0];

	for (int i = 0; i < ArraySpeednInTargetTol.size(); i++)
	{
		ResultSend[i] = ArraySpeednInTargetTol[i];
	}

	m_cProductMotorControl->AgitoSendAndReceive(ResultSend, inttotallength, Result1);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoMotorSpeed(unsigned int uController, unsigned int uAxis, long iValue, long iIntargetTolValue, long Acceleration, long Deceleration)
{
	char Result[9];
	char Result1[50];
	char ResultSend[50];
	int iResult;
	int intlength[1];
	int inttotallength = 0;
	ArraySpeednInTargetTol.clear();
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	Acceleration = Acceleration / 0.078125;
	Deceleration = Deceleration / 0.078125;

	ArraySpeednInTargetTol.push_back(0x02);
	inttotallength++;
	ArraySpeednInTargetTol.push_back(0x06);
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->Speed, 0, iValue, Result, intlength);
	ArraySpeednInTargetTol.push_back(Result[1]);
	ArraySpeednInTargetTol.push_back(Result[2]);
	ArraySpeednInTargetTol.push_back(Result[3]);
	ArraySpeednInTargetTol.push_back(Result[4]);
	ArraySpeednInTargetTol.push_back(Result[5]);
	ArraySpeednInTargetTol.push_back(Result[6]);
	inttotallength += intlength[0];
	ArraySpeednInTargetTol.push_back(0x06);
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->InTargetTol, 0, iIntargetTolValue, Result, intlength);
	ArraySpeednInTargetTol.push_back(Result[1]);
	ArraySpeednInTargetTol.push_back(Result[2]);
	ArraySpeednInTargetTol.push_back(Result[3]);
	ArraySpeednInTargetTol.push_back(Result[4]);
	ArraySpeednInTargetTol.push_back(Result[5]);
	ArraySpeednInTargetTol.push_back(Result[6]);
	inttotallength += intlength[0];
	ArraySpeednInTargetTol.push_back(0x06);
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->Accel, 0, Acceleration, Result, intlength);
	ArraySpeednInTargetTol.push_back(Result[1]);
	ArraySpeednInTargetTol.push_back(Result[2]);
	ArraySpeednInTargetTol.push_back(Result[3]);
	ArraySpeednInTargetTol.push_back(Result[4]);
	ArraySpeednInTargetTol.push_back(Result[5]);
	ArraySpeednInTargetTol.push_back(Result[6]);
	inttotallength += intlength[0];
	ArraySpeednInTargetTol.push_back(0x06);
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->Decel, 0, Deceleration, Result, intlength);
	ArraySpeednInTargetTol.push_back(Result[1]);
	ArraySpeednInTargetTol.push_back(Result[2]);
	ArraySpeednInTargetTol.push_back(Result[3]);
	ArraySpeednInTargetTol.push_back(Result[4]);
	ArraySpeednInTargetTol.push_back(Result[5]);
	ArraySpeednInTargetTol.push_back(Result[6]);
	inttotallength += intlength[0];

	for (int i = 0; i < ArraySpeednInTargetTol.size(); i++)
	{
		ResultSend[i] = ArraySpeednInTargetTol[i];
	}

	m_cProductMotorControl->AgitoSendAndReceive(uController, ResultSend, inttotallength, Result1);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoMotorSpeed1(unsigned int uController, unsigned int uAxis, long iValue, long iIntargetTolValue, long Acceleration, long Deceleration)
{
	char Result[9];
	char Result1[50];
	char ResultSend[50];
	int iResult;
	int intlength[1];
	int inttotallength = 0;
	ArraySpeednInTargetTol1.clear();
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	Acceleration = Acceleration / 0.078125;
	Deceleration = Deceleration / 0.078125;

	ArraySpeednInTargetTol1.push_back(0x02);
	inttotallength++;
	ArraySpeednInTargetTol1.push_back(0x06);
	iResult = m_Agito->setParam1(uController, uAxis, m_Agito->Speed, 0, iValue, Result, intlength);
	ArraySpeednInTargetTol1.push_back(Result[1]);
	ArraySpeednInTargetTol1.push_back(Result[2]);
	ArraySpeednInTargetTol1.push_back(Result[3]);
	ArraySpeednInTargetTol1.push_back(Result[4]);
	ArraySpeednInTargetTol1.push_back(Result[5]);
	ArraySpeednInTargetTol1.push_back(Result[6]);
	inttotallength += intlength[0];
	ArraySpeednInTargetTol1.push_back(0x06);
	iResult = m_Agito->setParam1(uController, uAxis, m_Agito->InTargetTol, 0, iIntargetTolValue, Result, intlength);
	ArraySpeednInTargetTol1.push_back(Result[1]);
	ArraySpeednInTargetTol1.push_back(Result[2]);
	ArraySpeednInTargetTol1.push_back(Result[3]);
	ArraySpeednInTargetTol1.push_back(Result[4]);
	ArraySpeednInTargetTol1.push_back(Result[5]);
	ArraySpeednInTargetTol1.push_back(Result[6]);
	inttotallength += intlength[0];
	ArraySpeednInTargetTol1.push_back(0x06);
	iResult = m_Agito->setParam1(uController, uAxis, m_Agito->Accel, 0, Acceleration, Result, intlength);
	ArraySpeednInTargetTol1.push_back(Result[1]);
	ArraySpeednInTargetTol1.push_back(Result[2]);
	ArraySpeednInTargetTol1.push_back(Result[3]);
	ArraySpeednInTargetTol1.push_back(Result[4]);
	ArraySpeednInTargetTol1.push_back(Result[5]);
	ArraySpeednInTargetTol1.push_back(Result[6]);
	inttotallength += intlength[0];
	ArraySpeednInTargetTol1.push_back(0x06);
	iResult = m_Agito->setParam1(uController, uAxis, m_Agito->Decel, 0, Deceleration, Result, intlength);
	ArraySpeednInTargetTol1.push_back(Result[1]);
	ArraySpeednInTargetTol1.push_back(Result[2]);
	ArraySpeednInTargetTol1.push_back(Result[3]);
	ArraySpeednInTargetTol1.push_back(Result[4]);
	ArraySpeednInTargetTol1.push_back(Result[5]);
	ArraySpeednInTargetTol1.push_back(Result[6]);
	inttotallength += intlength[0];

	for (int i = 0; i < ArraySpeednInTargetTol1.size(); i++)
	{
		ResultSend[i] = ArraySpeednInTargetTol1[i];
	}

	m_cProductMotorControl->AgitoSendAndReceive1(uController, ResultSend, inttotallength, Result1);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}


int CProductMotorControl::AgitoMotorSpeedGotError(unsigned int uController, unsigned int uAxis, long iValue, long iIntargetTolValue, long Acceleration, long Deceleration)
{
	char Result[9];
	char Result1[50];
	char ResultSend[50];
	int iResult;
	int intlength[1];
	int inttotallength = 0;
	ArraySpeednInTargetTol.clear();
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	Acceleration = Acceleration / 0.078125;
	Deceleration = Deceleration / 0.078125;

	ArraySpeednInTargetTol.push_back(0x02);
	inttotallength++;
	ArraySpeednInTargetTol.push_back(0x06);
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->Speed, 0, iValue, Result, intlength);
	ArraySpeednInTargetTol.push_back(Result[1]);
	ArraySpeednInTargetTol.push_back(Result[2]);
	ArraySpeednInTargetTol.push_back(Result[3]);
	ArraySpeednInTargetTol.push_back(Result[4]);
	ArraySpeednInTargetTol.push_back(Result[5]);
	ArraySpeednInTargetTol.push_back(Result[6]);
	inttotallength += intlength[0];
	ArraySpeednInTargetTol.push_back(0x06);
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->InTargetTol, 0, iIntargetTolValue, Result, intlength);
	ArraySpeednInTargetTol.push_back(Result[1]);
	ArraySpeednInTargetTol.push_back(Result[2]);
	ArraySpeednInTargetTol.push_back(Result[3]);
	ArraySpeednInTargetTol.push_back(Result[4]);
	ArraySpeednInTargetTol.push_back(Result[5]);
	ArraySpeednInTargetTol.push_back(Result[6]);
	inttotallength += intlength[0];
	ArraySpeednInTargetTol.push_back(0x06);
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->Accel, 0, Acceleration, Result, intlength);
	ArraySpeednInTargetTol.push_back(Result[1]);
	ArraySpeednInTargetTol.push_back(Result[2]);
	ArraySpeednInTargetTol.push_back(Result[3]);
	ArraySpeednInTargetTol.push_back(Result[4]);
	ArraySpeednInTargetTol.push_back(Result[5]);
	ArraySpeednInTargetTol.push_back(Result[6]);
	inttotallength += intlength[0];
	ArraySpeednInTargetTol.push_back(0x06);
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->Decel, 0, Deceleration, Result, intlength);
	ArraySpeednInTargetTol.push_back(Result[1]);
	ArraySpeednInTargetTol.push_back(Result[2]);
	ArraySpeednInTargetTol.push_back(Result[3]);
	ArraySpeednInTargetTol.push_back(Result[4]);
	ArraySpeednInTargetTol.push_back(Result[5]);
	ArraySpeednInTargetTol.push_back(Result[6]);
	inttotallength += intlength[0];

	for (int i = 0; i < ArraySpeednInTargetTol.size(); i++)
	{
		ResultSend[i] = ArraySpeednInTargetTol[i];
	}

	m_cProductMotorControl->AgitoSendAndReceive(uController, ResultSend, inttotallength, Result1);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoMotorJerk(unsigned int uAxis, long iValue)
{
	char Result[50];
	int iResult;
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	iResult = m_Agito->setParam(0, uAxis, m_Agito->Jerk, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoMotorJerk(unsigned int uController, unsigned int uAxis, long iValue)
{
	char Result[50];
	int iResult;
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->Jerk, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoEmergencyDec(unsigned int uAxis, long iValue)
{
	char Result[50];
	int iResult;
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	iResult = m_Agito->setParam(0, uAxis, m_Agito->EmrgDec, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoEmergencyDec(unsigned int uController, unsigned int uAxis, long iValue)
{
	char Result[50];
	int iResult;
	if (uAxis == 3)
	{
		iValue = iValue / 1.5;
	}
	else
	{
		iValue = iValue / 0.078125;
	}
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->EmrgDec, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoMotionMode(unsigned int uAxis, int iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->MotionMode, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoMotionMode(unsigned int uController, unsigned int uAxis, int iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->MotionMode, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int AgitoMotorPosition(unsigned int uAxis)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->getParam(0, uAxis, m_Agito->Pos, 0, Result, length);
	m_cProductMotorControl->AgitoSend(Result, length[0]);
	return 0;
}
int AgitoMotorPosition(unsigned int uController, unsigned int uAxis)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->getParam(uController, uAxis, m_Agito->Pos, 0, Result, length);
	m_cProductMotorControl->AgitoSend(uController, Result, length[0]);
	return 0;
}

signed long CProductMotorControl::ReadAgitoMotorPosition(unsigned int uAxis)
{
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	int currentNo_1 = 0;
	char num[9];
	long iResult;
	char Result[7];
	char Return[6];
	signed long R_Result;
	iResult = m_Agito->getParam(0, uAxis, m_Agito->Pos, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Return);
	//AgitoMotorPosition(uAxis);
	//char chAllData[512] = { '/0' };
	//for (int i = 0; i < sizeof(Return); i++)
	//{
	//	m_cLogger->WriteLog("Receivec:%c\n", Return[i]);
	//	//sprintf_s(chData, sizeof(chData), "%s", Return[i]);
	//	strcat(chAllData, &Return[i]);
	//}
	//m_cLogger->WriteLog("Receive:%s\n", Return);
	//m_cLogger->WriteLog("ReceiveAll:%s\n", chAllData);
	//memset(chAllData, 0, sizeof(chAllData));

	//m_cProductMotorControl->AgitoReceive(Return);
	for (int i = 0; i < 4; i++)
	{
		num[currentNo_1] = (Return[i + 1] & 0xF0) >> 4;
		num[currentNo_1] = convertData(num[currentNo_1]);
		currentNo_1++;
		num[currentNo_1] = Return[i + 1] & 0x0F;
		num[currentNo_1] = convertData(num[currentNo_1]);
		currentNo_1++;

	}
	num[currentNo_1] = { 0x00 };

	R_Result = convert(num) * 0.078125;
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	return R_Result;

}
signed long CProductMotorControl::ReadAgitoMotorPosition(unsigned int uController, unsigned int uAxis)
{
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	int currentNo_1 = 0;
	char num[9];
	long iResult;
	char Result[7];
	char Return[6];
	signed long R_Result;
	iResult = m_Agito->getParam(uController, uAxis, m_Agito->Pos, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Return);
	//AgitoMotorPosition(uAxis);
	//char chAllData[512] = { '/0' };
	//for (int i = 0; i < sizeof(Return); i++)
	//{
	//	m_cLogger->WriteLog("Receivec:%c\n", Return[i]);
	//	//sprintf_s(chData, sizeof(chData), "%s", Return[i]);
	//	strcat(chAllData, &Return[i]);
	//}
	//m_cLogger->WriteLog("Receive:%s\n", Return);
	//m_cLogger->WriteLog("ReceiveAll:%s\n", chAllData);
	//memset(chAllData, 0, sizeof(chAllData));

	//m_cProductMotorControl->AgitoReceive(Return);
	for (int i = 0; i < 4; i++)
	{
		num[currentNo_1] = (Return[i + 1] & 0xF0) >> 4;
		num[currentNo_1] = convertData(num[currentNo_1]);
		currentNo_1++;
		num[currentNo_1] = Return[i + 1] & 0x0F;
		num[currentNo_1] = convertData(num[currentNo_1]);
		currentNo_1++;

	}
	num[currentNo_1] = { 0x00 };

	R_Result = convert(num) * 0.078125;
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	return R_Result;

}

double CProductMotorControl::ReadAgitoMotorPosition(unsigned int uAxis, int differentiate)
{
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	int currentNo_1 = 0;
	char num[9];
	long iResult;
	char Return[10];
	double R_Result;
	char Result[50];
	iResult = m_Agito->getParam(0, uAxis, m_Agito->Pos, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Return);
	//AgitoMotorPosition(uAxis);
	//m_cProductMotorControl->AgitoReceive(Return);
	for (int i = 0; i < 4; i++)
	{
		num[currentNo_1] = (Return[i + 1] & 0xF0) >> 4;
		num[currentNo_1] = convertData(num[currentNo_1]);
		currentNo_1++;
		num[currentNo_1] = Return[i + 1] & 0x0F;
		num[currentNo_1] = convertData(num[currentNo_1]);
		currentNo_1++;

	}
	num[currentNo_1] = { 0x00 };
	if (uAxis == 3)
	{
		R_Result = convert(num) * 1.5;
	}
	else
	{
		R_Result = convert(num) * 0.078125;
	}
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	return R_Result;

}
double CProductMotorControl::ReadAgitoMotorPosition(unsigned int uController, unsigned int uAxis, int differentiate)
{
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	int currentNo_1 = 0;
	char num[9];
	long iResult;
	char Return[10];
	double R_Result;
	char Result[50];
	iResult = m_Agito->getParam(uController, uAxis, m_Agito->Pos, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Return);
	//AgitoMotorPosition(uAxis);
	//m_cProductMotorControl->AgitoReceive(Return);
	for (int i = 0; i < 4; i++)
	{
		num[currentNo_1] = (Return[i + 1] & 0xF0) >> 4;
		num[currentNo_1] = convertData(num[currentNo_1]);
		currentNo_1++;
		num[currentNo_1] = Return[i + 1] & 0x0F;
		num[currentNo_1] = convertData(num[currentNo_1]);
		currentNo_1++;

	}
	num[currentNo_1] = { 0x00 };
	if (uAxis == 3)
	{
		R_Result = convert(num) * 1.5;
	}
	else
	{
		R_Result = convert(num) * 0.078125;
	}
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	return R_Result;

}

int CProductMotorControl::ReadAgitoMotorOnOff(unsigned int uAxis)
{
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	char Result[50];
	char Result2[50];
	int iResult;

	iResult = m_Agito->getParam(0, uAxis, m_Agito->MotorOn, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result2);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	if (Result2[4] == 0x01)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}
int CProductMotorControl::ReadAgitoMotorOnOff(unsigned int uController, unsigned int uAxis)
{
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	char Result[50];
	char Result2[50];
	int iResult;

	iResult = m_Agito->getParam(uController, uAxis, m_Agito->MotorOn, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result2);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	if (Result2[4] == 0x01)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

int CProductMotorControl::ReadAgitoMotorHomeStat(unsigned int uAxis)
{
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	char Result[50];
	char Result_1[50];
	int iResult;
	iResult = m_Agito->getParam(0, uAxis, m_Agito->HomingStat, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result_1);

	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	if (Result_1[4] == 0x64)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}
int CProductMotorControl::ReadAgitoMotorHomeStat(unsigned int uController, unsigned int uAxis)
{
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	char Result[50];
	char Result_1[50];
	int iResult;
	iResult = m_Agito->getParam(uController, uAxis, m_Agito->HomingStat, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result_1);

	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	if (Result_1[4] == 0x64)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

int CProductMotorControl::ReadAgitoMotorMoving(unsigned int uAxis)
{
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	char Result[50];
	char Result2[50];
	int iResult;
	iResult = m_Agito->getParam(0, uAxis, m_Agito->MotionStat, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result2);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	if (Result2[4] == 0x01)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}
int CProductMotorControl::ReadAgitoMotorMoving(unsigned int uController, unsigned int uAxis)
{
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	char Result[50];
	char Result2[50];
	int iResult;
	iResult = m_Agito->getParam(uController, uAxis, m_Agito->MotionStat, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result2);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	if (Result2[4] == 0x01)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

int CProductMotorControl::ReadAgitoMotorLimit(unsigned int uAxis)
{
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	char Result[50];
	char Result2[50];
	int iResult;
	iResult = m_Agito->getParam(0, uAxis, m_Agito->LimitsStat, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result2);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	if (Result2[4] == 0x01)
	{
		return 1;
	}
	else if (Result2[4] == 0x02)
	{
		return 2;
	}
	else if (Result2[4] == 0x03)
	{
		return 3;
	}
	else
	{
		return 0;
	}
}
int CProductMotorControl::ReadAgitoMotorLimit(unsigned int uController, unsigned int uAxis)
{
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	char Result[50];
	char Result2[50];
	int iResult;
	iResult = m_Agito->getParam(uController, uAxis, m_Agito->LimitsStat, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result2);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	if (Result2[4] == 0x01)
	{
		return 1;
	}
	else if (Result2[4] == 0x02)
	{
		return 2;
	}
	else if (Result2[4] == 0x03)
	{
		return 3;
	}
	else
	{
		return 0;
	}
}

int CProductMotorControl::AgitoPositionEventTriggerEnable(unsigned int uAxis)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->EventOn, 0, 1, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoPositionEventTriggerEnable(unsigned int uController, unsigned int uAxis)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->EventOn, 0, 1, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoOutputFunction(unsigned int uAxis, unsigned int uIndex, signed long iValue)
{
	char Result[50];
	char Return[50];
	int iResult = 0;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->DOutSelect, uIndex, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Return);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoOutputFunction(unsigned int uController, unsigned int uAxis, unsigned int uIndex, signed long iValue)
{
	char Result[50];
	char Return[50];
	int iResult = 0;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->DOutSelect, uIndex, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Return);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoOutputTriggerOnOffIO0(unsigned int uAxis, signed long iValue)
{
	char Result[50];
	char Return[50];
	int iResult = 0;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->DOutPort, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Return);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoOutputTriggerOnOffIO0(unsigned int uController, unsigned int uAxis, signed long iValue)
{
	char Result[50];
	char Return[50];
	int iResult = 0;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->DOutPort, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Return);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoOutputTriggerOnOff(unsigned int uAxis, unsigned int IONumber, signed long iValue)
{
	char Result[50];
	char Return[50];
	int iResult = 0;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->DOutPort, IONumber, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Return);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoOutputTriggerOnOff(unsigned int uController, unsigned int uAxis, unsigned int IONumber, signed long iValue)
{
	char Result[50];
	char Return[50];
	int iResult = 0;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->DOutPort, IONumber, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Return);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoPositionEventTriggerDisable(unsigned int uAxis)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->EventOn, 0, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoPositionEventTriggerDisable(unsigned int uController, unsigned int uAxis)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->EventOn, 0, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoPositionEventTriggerPulseWidth(unsigned int uAxis, signed long iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->EventPulseWid, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoPositionEventTriggerPulseWidth(unsigned int uController, unsigned int uAxis, signed long iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->EventPulseWid, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoPositionEventTriggerEventType(unsigned int uAxis, signed long iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->EventType, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoPositionEventTriggerEventType(unsigned int uController, unsigned int uAxis, signed long iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->EventType, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoPositionEventTriggerEventBeginPosition(unsigned int uAxis, signed long iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->EventBegPos, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoPositionEventTriggerEventBeginPosition(unsigned int uController, unsigned int uAxis, signed long iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->EventBegPos, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoPositionEventTriggerEventEndPosition(unsigned int uAxis, signed long iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->EventEndPos, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoPositionEventTriggerEventEndPosition(unsigned int uController, unsigned int uAxis, signed long iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->EventEndPos, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoPositionEventTriggerEventGap(unsigned int uAxis, signed long iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->EventGap, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoPositionEventTriggerEventGap(unsigned int uController, unsigned int uAxis, signed long iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->EventGap, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoPositionEventTriggerEventSelect(unsigned int uAxis, signed long iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->EventSelect, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoPositionEventTriggerEventSelect(unsigned int uController, unsigned int uAxis, signed long iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->EventSelect, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoPositionEventTriggerEventStartIndex(unsigned int uAxis, signed long iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->EventTableBeg, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoPositionEventTriggerEventStartIndex(unsigned int uController, unsigned int uAxis, signed long iValue)
{
	char Result[50];
	int iResult;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->EventTableBeg, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoPositionEventTriggerEventEndIndex(unsigned int uAxis, signed long iValue)
{
	char Result[50];
	char Result2[50];
	int iResult;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->EventTableEnd, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result2);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoPositionEventTriggerEventEndIndex(unsigned int uController, unsigned int uAxis, signed long iValue)
{
	char Result[50];
	char Result2[50];
	int iResult;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->EventTableEnd, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result2);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoPositionEventTriggerEventTable(unsigned int uAxis, unsigned int uIndex, signed long iValue)
{
	char Result[50];
	char Result2[50];
	int iResult;
	iValue = iValue / 0.078125;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->EventTable, uIndex, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result2);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoPositionEventTriggerEventTable(unsigned int uController, unsigned int uAxis, unsigned int uIndex, signed long iValue)
{
	char Result[50];
	char Result2[50];
	int iResult;
	iValue = iValue / 0.078125;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->EventTable, uIndex, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result2);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoPositionEventTriggerEventTableSelect(unsigned int uAxis, unsigned int uIndex, signed long iValue)
{
	char Result[50];
	char Result2[50];
	int iResult;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->EventTableSel, uIndex, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result2);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoPositionEventTriggerEventTableSelect(unsigned int uController, unsigned int uAxis, unsigned int uIndex, signed long iValue)
{
	char Result[50];
	char Result2[50];
	int iResult;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->EventTableSel, uIndex, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result2);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoPositionEventTriggerEventTableSelectAndEventTable(unsigned int uAxis, unsigned int uIndex, signed long iValue)
{
	char Result[9];
	char Result2[50];
	int iResult;
	iResult = m_Agito->setParam(0, uAxis, m_Agito->EventTableSel, uIndex, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(Result, length[0], Result2);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}
int CProductMotorControl::AgitoPositionEventTriggerEventTableSelectAndEventTable(unsigned int uController, unsigned int uAxis, unsigned int uIndex, signed long iValue)
{
	char Result[9];
	char Result2[50];
	int iResult;
	iResult = m_Agito->setParam(uController, uAxis, m_Agito->EventTableSel, uIndex, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result2);
	//m_cProductMotorControl->AgitoSend(Result, length[0]);
	//m_cProductMotorControl->AgitoReceive(Result);
	return iResult;
}

int CProductMotorControl::AgitoTCPIPConnect(const char*IPAddress, int PortNo)
{
	int error = WSAStartup(0x0202, &wsadata);
	int iResult;

	if (error)
		return false;

#if UNDER_RTSS
	if (wsadata.wVersion != 0x0002)
#else
	if (wsadata.wVersion != 0x0202)
#endif
	{
		WSACleanup(); //Clean up Winsock
		return false;
	}
	target.sin_family = AF_INET;      // address family Internet
	target.sin_port = htons(PortNo); //Port to connect on
	target.sin_addr.s_addr = inet_addr(IPAddress); //Target IP
	//inet_pton(AF_INET, IPAddress, &target.sin_addr);

	s = socket(AF_INET, SOCK_STREAM, 0); //Create socket

	if (s == INVALID_SOCKET)
	{
		return false; //Couldn't create the socket
	}

	//Try connecting...

	if (iResult = connect(s, (SOCKADDR *)&target, sizeof(target)) == SOCKET_ERROR)
	{
		return 1;                 //Couldn't connect
	}
	return 0;

}

int CProductMotorControl::AgitoTCPIPConnect(unsigned int uController, const char*IPAddress, int PortNo)
{
	EnterCriticalSection(&csAgitoSendCommand);
	int error = WSAStartup(0x0202, &wsadata);
	int iResult;

	if (error)
		return false;

#if UNDER_RTSS
	if (wsadata.wVersion != 0x0002)
#else
	if (wsadata.wVersion != 0x0202)
#endif
	{
		WSACleanup(); //Clean up Winsock
		return false;
	}
	target.sin_family = AF_INET;      // address family Internet
	target.sin_port = htons(PortNo); //Port to connect on
	target.sin_addr.s_addr = inet_addr(IPAddress); //Target IP
	//inet_pton(AF_INET, IPAddress, &target.sin_addr);

	if (uController == 0)
	{
		s = socket(AF_INET, SOCK_STREAM, 0); //Create socket

		if (s == INVALID_SOCKET)
		{
			m_cLogger->WriteLog("Invalid Socket 1.\n"); 
			LeaveCriticalSection(&csAgitoSendCommand);
			return false; //Couldn't create the socket
		}

		//Try connecting...

		if (iResult = connect(s, (SOCKADDR *)&target, sizeof(target)) == SOCKET_ERROR)
		{
			m_cLogger->WriteLog("Couldnt Connect 1.\n"); 
			LeaveCriticalSection(&csAgitoSendCommand);
			return 1;                 //Couldn't connect
		}
	}
	else if (uController == 1)
	{
		s2 = socket(AF_INET, SOCK_STREAM, 0); //Create socket

		if (s2 == INVALID_SOCKET)
		{
			m_cLogger->WriteLog("Invalid Socket 2.\n"); 
			LeaveCriticalSection(&csAgitoSendCommand);
			return false; //Couldn't create the socket
		}

		//Try connecting...

		if (iResult = connect(s2, (SOCKADDR *)&target, sizeof(target)) == SOCKET_ERROR)
		{
			m_cLogger->WriteLog("Couldnt Connect 2.\n");
			LeaveCriticalSection(&csAgitoSendCommand); 
			return 1;                 //Couldn't connect
		}
	}
	LeaveCriticalSection(&csAgitoSendCommand);
	m_cLogger->WriteLog("Leave.\n");
	return 0;

}

int CProductMotorControl::AgitoTCPIPConnect1(unsigned int uController, const char*IPAddress, int PortNo)
{
	EnterCriticalSection(&csAgitoSendCommand);
	int error = WSAStartup(0x0202, &wsadata);
	int iResult;

	if (error)
		return false;

#if UNDER_RTSS
	if (wsadata.wVersion != 0x0002)
#else
	if (wsadata.wVersion != 0x0202)
#endif
	{
		WSACleanup(); //Clean up Winsock
		return false;
	}
	target.sin_family = AF_INET;      // address family Internet
	target.sin_port = htons(PortNo); //Port to connect on
	target.sin_addr.s_addr = inet_addr(IPAddress); //Target IP
	//inet_pton(AF_INET, IPAddress, &target.sin_addr);

	if (uController == 0)
	{
		s = socket(AF_INET, SOCK_STREAM, 0); //Create socket

		if (s == INVALID_SOCKET)
		{
			m_cLogger->WriteLog("Invalid Socket 1.\n");
			LeaveCriticalSection(&csAgitoSendCommand);
			return false; //Couldn't create the socket
		}

		//Try connecting...

		if (iResult = connect(s, (SOCKADDR *)&target, sizeof(target)) == SOCKET_ERROR)
		{
			m_cLogger->WriteLog("Couldnt Connect 1.\n");
			LeaveCriticalSection(&csAgitoSendCommand);
			return 1;                 //Couldn't connect
		}
	}
	else if (uController == 1)
	{
		s2 = socket(AF_INET, SOCK_STREAM, 0); //Create socket

		if (s2 == INVALID_SOCKET)
		{
			m_cLogger->WriteLog("Invalid Socket 2.\n"); 
			LeaveCriticalSection(&csAgitoSendCommand);
			return false; //Couldn't create the socket
		}

		//Try connecting...

		if (iResult = connect(s2, (SOCKADDR *)&target, sizeof(target)) == SOCKET_ERROR)
		{
			m_cLogger->WriteLog("Couldnt Connect 2.\n");
			LeaveCriticalSection(&csAgitoSendCommand);
			return 1;                 //Couldn't connect
		}
	}
	LeaveCriticalSection(&csAgitoSendCommand);
	m_cLogger->WriteLog("Leave.\n");
	return 0;

}

int CProductMotorControl::AgitoSendAndReceive(const char*Data, int length, char*R_Data)
{
	EnterCriticalSection(&csAgitoSendCommand);
	int iResult = 0;
	//char chData[80];
	//sprintf_s(chData, sizeof(chData), "Send:%s\n", Data);
	//m_cLogger->WriteLog(chData);
	//memset(chData, 0, sizeof(chData));
	m_cProductMotorControl->AgitoSend(Data, length);
	m_cProductMotorControl->AgitoReceive(R_Data);
	//sprintf_s(chData, sizeof(chData), "Receive:%s\n", R_Data);
	//m_cLogger->WriteLog(chData);
	//memset(chData, 0, sizeof(chData));
	LeaveCriticalSection(&csAgitoSendCommand);
	return 0;
}

int CProductMotorControl::AgitoSendAndReceive(unsigned int uController, const char*Data, int length, char*R_Data)
{
	EnterCriticalSection(&csAgitoSendCommand);
	int iResult = 0;
	//char chData[80];
	//sprintf_s(chData, sizeof(chData), "Send:%s\n", Data);
	//m_cLogger->WriteLog(chData);
	//memset(chData, 0, sizeof(chData));
	m_cProductMotorControl->AgitoSend(uController, Data, length);
	m_cProductMotorControl->AgitoReceive(uController, R_Data);
	//sprintf_s(chData, sizeof(chData), "Receive:%s\n", R_Data);
	//m_cLogger->WriteLog(chData);
	//memset(chData, 0, sizeof(chData));
	LeaveCriticalSection(&csAgitoSendCommand);
	return 0;
}

int CProductMotorControl::AgitoSendAndReceive1(unsigned int uController, const char*Data, int length, char*R_Data)
{
	EnterCriticalSection(&csAgitoSendCommand);
	int iResult = 0;
	//char chData[80];
	//sprintf_s(chData, sizeof(chData), "Send:%s\n", Data);
	//m_cLogger->WriteLog(chData);
	//memset(chData, 0, sizeof(chData));
	m_cProductMotorControl->AgitoSend1(uController, Data, length);
	m_cProductMotorControl->AgitoReceive1(uController, R_Data);
	//sprintf_s(chData, sizeof(chData), "Receive:%s\n", R_Data);
	//m_cLogger->WriteLog(chData);
	//memset(chData, 0, sizeof(chData));
	LeaveCriticalSection(&csAgitoSendCommand);
	return 0;
}

int CProductMotorControl::AgitoSend(const char*Data, int length)
{
	int iResult = 0;
	//Sleep(50);
	//strncpy_s(sendbuf, Data, sizeof(Data));
	char chData[80];
	char chAllData[80];
	//for (int i = 0; i < length; i++)
	//{
	//	sprintf_s(chData, sizeof(chData), "Send:%c\n", Data[i]);
		//m_cLogger->WriteLog(chData);
	//	memset(chData, 0, sizeof(chData));
	//}
	//for (int i = 0; i < recvbuflen; i++)
	//{
	//	sprintf_s(chData, sizeof(chData), "%s", Data[i]);
	//	strcat(chAllData, chData);
	//}
	//m_cLogger->WriteLog("Send:%s\n", chAllData);
	//memset(chData, 0, sizeof(chData));

	iResult = send(s, Data, length, 0);
	return 0;
}

int CProductMotorControl::AgitoSend(unsigned int uController, const char*Data, int length)
{
	int iResult = 0;
	//Sleep(50);
	//strncpy_s(sendbuf, Data, sizeof(Data));
	char chData[80];
	char chAllData[80];
	//for (int i = 0; i < length; i++)
	//{
	//	sprintf_s(chData, sizeof(chData), "Send:%c\n", Data[i]);
		//m_cLogger->WriteLog(chData);
	//	memset(chData, 0, sizeof(chData));
	//}
	//for (int i = 0; i < recvbuflen; i++)
	//{
	//	sprintf_s(chData, sizeof(chData), "%s", Data[i]);
	//	strcat(chAllData, chData);
	//}
	//m_cLogger->WriteLog("Send:%s\n", chAllData);
	//memset(chData, 0, sizeof(chData));
	if(uController == 0)
		iResult = send(s, Data, length, 0);
	else if (uController == 1)
		iResult = send(s2, Data, length, 0);
	return 0;
}

int CProductMotorControl::AgitoSend1(unsigned int uController, const char*Data, int length)
{
	int iResult = 0;
	//Sleep(50);
	//strncpy_s(sendbuf, Data, sizeof(Data));
	char chData[80];
	char chAllData[80];
	//for (int i = 0; i < length; i++)
	//{
	//	sprintf_s(chData, sizeof(chData), "Send:%c\n", Data[i]);
		//m_cLogger->WriteLog(chData);
	//	memset(chData, 0, sizeof(chData));
	//}
	//for (int i = 0; i < recvbuflen; i++)
	//{
	//	sprintf_s(chData, sizeof(chData), "%s", Data[i]);
	//	strcat(chAllData, chData);
	//}
	//m_cLogger->WriteLog("Send:%s\n", chAllData);
	//memset(chData, 0, sizeof(chData));
	if (uController == 0)
		iResult = send(s, Data, length, 0);
	else if (uController == 1)
		iResult = send(s2, Data, length, 0);
	return 0;
}

int CProductMotorControl::AgitoReceive(char*R_Data)
{
	fd_set set;
	struct timeval timeout;
	char chData[80];
	char chAllData[80];
	int recv_size = 0;
	FD_ZERO(&set);
	FD_SET(s, &set);
	timeout.tv_sec = 0;
	timeout.tv_usec = 1000000;
	int iResult = 0;
	int rv = select(s + 1, &set, NULL, NULL, &timeout);
	if (rv == SOCKET_ERROR)
	{
		return -1;
	}
	else if (rv == 0)
	{
		return -1;
	}
	else
	{
		recv_size = recv(s, R_Data, recvbuflen, 0);

		//for (int i = 0; i < recvbuflen; i++)
		//{
		//	sprintf_s(chData, sizeof(chData), "%s", R_Data[i]);
		//	strcat(chAllData, chData);			
		//}
		//m_cLogger->WriteLog("Receive:%s\n",R_Data);
		//memset(chData, 0, sizeof(chData));
		if (recv_size == SOCKET_ERROR)
		{
			return -1;
		}
		else if (recv_size == 0)
		{
			return -1;
		}
		else
		{
			return 0;
		}
	}
	return 0;
}
int CProductMotorControl::AgitoReceive(unsigned int uController, char*R_Data)
{
	fd_set set;
	struct timeval timeout;
	char chData[80];
	char chAllData[80];
	int recv_size = 0;
	timeout.tv_sec = 0;
	timeout.tv_usec = 1000000;
	int iResult = 0;
	FD_ZERO(&set);
	if (uController == 0)
	{
		FD_SET(s, &set);
		int rv = select(s + 1, &set, NULL, NULL, &timeout);
	}		
	else if(uController == 1)
	{
		FD_SET(s2, &set);
		int rv = select(s2 + 1, &set, NULL, NULL, &timeout);
	}
	int rv = select(s + 1, &set, NULL, NULL, &timeout);
	if (rv == SOCKET_ERROR)
	{
		return -1;
	}
	else if (rv == 0)
	{
		return -1;
	}
	else
	{
		if (uController == 0)
		{
			recv_size = recv(s, R_Data, recvbuflen, 0);
		}
		else if (uController == 1)
		{
			recv_size = recv(s2, R_Data, recvbuflen, 0);
		}

		//for (int i = 0; i < recvbuflen; i++)
		//{
		//	sprintf_s(chData, sizeof(chData), "%s", R_Data[i]);
		//	strcat(chAllData, chData);			
		//}
		//m_cLogger->WriteLog("Receive:%s\n",R_Data);
		//memset(chData, 0, sizeof(chData));
		if (recv_size == SOCKET_ERROR)
		{
			return -1;
		}
		else if (recv_size == 0)
		{
			return -1;
		}
		else
		{
			return 0;
		}
	}
	return 0;
}
int CProductMotorControl::AgitoReceive1(unsigned int uController, char*R_Data)
{
	fd_set set;
	struct timeval timeout;
	char chData[80];
	char chAllData[80];
	int recv_size = 0;
	timeout.tv_sec = 0;
	timeout.tv_usec = 1000000;
	int iResult = 0;
	FD_ZERO(&set);
	if (uController == 0)
	{
		FD_SET(s, &set);
		int rv = select(s + 1, &set, NULL, NULL, &timeout);
	}
	else if (uController == 1)
	{
		FD_SET(s2, &set);
		int rv = select(s2 + 1, &set, NULL, NULL, &timeout);
	}
	int rv = select(s + 1, &set, NULL, NULL, &timeout);
	if (rv == SOCKET_ERROR)
	{
		return -1;
	}
	else if (rv == 0)
	{
		return -1;
	}
	else
	{
		if (uController == 0)
		{
			recv_size = recv(s, R_Data, recvbuflen, 0);
		}
		else if (uController == 1)
		{
			recv_size = recv(s2, R_Data, recvbuflen, 0);
		}

		//for (int i = 0; i < recvbuflen; i++)
		//{
		//	sprintf_s(chData, sizeof(chData), "%s", R_Data[i]);
		//	strcat(chAllData, chData);			
		//}
		//m_cLogger->WriteLog("Receive:%s\n",R_Data);
		//memset(chData, 0, sizeof(chData));
		if (recv_size == SOCKET_ERROR)
		{
			return -1;
		}
		else if (recv_size == 0)
		{
			return -1;
		}
		else
		{
			return 0;
		}
	}
	return 0;
}
int CProductMotorControl::AgitoClosePort()
{
	closesocket(s);
	return 0;
}
int CProductMotorControl::AgitoClosePort(unsigned int uController)
{
	EnterCriticalSection(&csAgitoSendCommand);
	if(uController == 0)
		closesocket(s);
	else if (uController == 1)
		closesocket(s2);
	LeaveCriticalSection(&csAgitoSendCommand);

	return 0;
}
int CProductMotorControl::convert(char num[]) {
	int len = strlen(num);
	int base = 1;
	int temp = 0;

	for (int i = len - 1; i >= 0; i--) {
		if (num[i] >= '0' && num[i] <= '9') {
			temp += (num[i] - 48)*base;
			base = base * 16;
		}
		else if (num[i] >= 'A' && num[i] <= 'F') {
			temp += (num[i] - 55)*base;
			base = base * 16;
		}
	}
	//memset(num, 0, sizeof(num));
	return temp;
}
// wc 20042022
int CProductMotorControl::AgitoMotorEnableLockPosition(unsigned int uController, unsigned int uAxis, int iValue)
{
	char Result[50];
	int iResult;

	iResult = m_Agito->setParam(uController, uAxis, m_Agito->LockEn, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Result);
	/*m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	return iResult;
}
int CProductMotorControl::AgitoMotorEnableLockPosition1(unsigned int uController, unsigned int uAxis, int iValue)
{
	char Result[50];
	int iResult;

	iResult = m_Agito->setParam1(uController, uAxis, m_Agito->LockEn, 0, iValue, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive1(uController, Result, length[0], Result);
	/*m_cProductMotorControl->AgitoSend(Result, length[0]);
	m_cProductMotorControl->AgitoReceive(Result);*/
	return iResult;
}
double CProductMotorControl::ReadAgitoMotorLockPosition(unsigned int uController, unsigned int uAxis, int differentiate)
{
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	int currentNo_1 = 0;
	char num[9];
	long iResult;
	char Return[10];
	double R_Result;
	char Result[50];
	iResult = m_Agito->getParam(uController, uAxis, m_Agito->LockVal, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive(uController, Result, length[0], Return);
	//AgitoMotorPosition(uAxis);
	//m_cProductMotorControl->AgitoReceive(Return);
	for (int i = 0; i < 4; i++)
	{
		num[currentNo_1] = (Return[i + 1] & 0xF0) >> 4;
		num[currentNo_1] = convertData(num[currentNo_1]);
		currentNo_1++;
		num[currentNo_1] = Return[i + 1] & 0x0F;
		num[currentNo_1] = convertData(num[currentNo_1]);
		currentNo_1++;

	}
	num[currentNo_1] = { 0x00 };
	if (uAxis == 3)
	{
		R_Result = convert(num) * 1.5;
	}
	else
	{
		R_Result = convert(num) * 0.078125;
	}
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	return R_Result;

}
double CProductMotorControl::ReadAgitoMotorLockPosition1(unsigned int uController, unsigned int uAxis, int differentiate)
{
	EnterCriticalSection(&csAgitoGetParamSendReceive);
	int currentNo_1 = 0;
	char num[9];
	long iResult;
	char Return[10];
	double R_Result;
	char Result[50];
	iResult = m_Agito->getParam1(uController, uAxis, m_Agito->LockVal, 0, Result, length);
	m_cProductMotorControl->AgitoSendAndReceive1(uController, Result, length[0], Return);
	//AgitoMotorPosition(uAxis);
	//m_cProductMotorControl->AgitoReceive(Return);
	for (int i = 0; i < 4; i++)
	{
		num[currentNo_1] = (Return[i + 1] & 0xF0) >> 4;
		num[currentNo_1] = convertData(num[currentNo_1]);
		currentNo_1++;
		num[currentNo_1] = Return[i + 1] & 0x0F;
		num[currentNo_1] = convertData(num[currentNo_1]);
		currentNo_1++;

	}
	num[currentNo_1] = { 0x00 };
	if (uAxis == 3)
	{
		R_Result = convert(num) * 1.5;
	}
	else
	{
		R_Result = convert(num) * 0.078125;
	}
	LeaveCriticalSection(&csAgitoGetParamSendReceive);
	return R_Result;

}
//--
char CProductMotorControl::convertData(char num)
{
	switch (num)
	{
	case 0:
		return { 0x30 };
	case 1:
		return { 0x31 };
	case 2:
		return { 0x32 };
	case 3:
		return { 0x33 };
	case 4:
		return { 0x34 };
	case 5:
		return { 0x35 };
	case 6:
		return { 0x36 };
	case 7:
		return { 0x37 };
	case 8:
		return { 0x38 };
	case 9:
		return { 0x39 };
	case 10:
		return { 0x41 };
	case 11:
		return { 0x42 };
	case 12:
		return { 0x43 };
	case 13:
		return { 0x44 };
	case 14:
		return { 0x45 };
	case 15:
		return { 0x46 };
	}
}
#pragma endregion